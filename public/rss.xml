<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[mrsingsing]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>http://mrsingsing.com</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 14 Apr 2020 17:31:01 GMT</lastBuildDate><item><title><![CDATA[龙猫 X 基于事件链的自动化测试方案复盘]]></title><description><![CDATA[大纲： 基于龙猫 X 事件机制生成事件链列表 使用 Egg 和 Socket.IO 搭建自动化测试服务 利用 Puppeteer 进行自动化测试 测试用例的执行方案研讨 龙猫 X…]]></description><link>http://mrsingsing.com/event-chain-based-automatic-test-scheme-of-totorox/</link><guid isPermaLink="false">http://mrsingsing.com/event-chain-based-automatic-test-scheme-of-totorox/</guid><pubDate>Sun, 01 Mar 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;大纲：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于龙猫 X 事件机制生成事件链列表&lt;/li&gt;
&lt;li&gt;使用 Egg 和 Socket.IO 搭建自动化测试服务&lt;/li&gt;
&lt;li&gt;利用 Puppeteer 进行自动化测试&lt;/li&gt;
&lt;li&gt;测试用例的执行方案研讨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;龙猫 X 作为服务于产品、运营、开发的页面搭建平台，通过可视化的拖拽、配置生成业务所需的各种页面。在日常的开发中，大多数情况下都是由运营直接完成需求，或是运营产品直接提交工单后由开发进行完成，测试在评审阶段的参与率不高。这就导致测试在功能页面的测试中无法全方位地检测页面的功能效果，同时也由于龙猫 X 项目测试少有参与，测试参与的多是经由龙猫 X 生成的页面的功能测试，所以测试对于龙猫 X 页面的内在逻辑也缺乏了解。因此，为测试方提供能掌握龙猫 X 页面逻辑关系的工具对提升页面的运行质量具有重要意义。&lt;/p&gt;
&lt;p&gt;本文针对上述情况，团队开发出针对龙猫 X 的事件链自动化测试方案，由于与业务耦合度极高，可能对其他公司团队未必具有通用性，权当技术方案参考与交流。&lt;/p&gt;
&lt;p&gt;开始前，直接抛出整个业务流程的模式图，以便对该功能有个全貌的认知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/automatation-test-workflow.jpg&quot; alt=&quot;自动化测试业务流程图&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单阐述一下参与流程的几个服务，包括用户操作自动化测试的前端界面、获取页面数据的龙猫 X 服务、用于进行测试逻辑的服务以及连接测试服务的无头浏览器端。&lt;/p&gt;
&lt;p&gt;主流程就是通过获取页面数据生成事件链，测试人员配置测试用例后触发对应事件，由测试服务和无头浏览器自动完成对应链条的测试需求，最后前端页面显示测试覆盖率及成功率。&lt;/p&gt;
&lt;h2&gt;基于龙猫 X 事件机制生成事件链列表&lt;/h2&gt;
&lt;p&gt;在说明事件链的生成机制前，我们需要研究一下龙猫 X 的通讯机制。&lt;/p&gt;
&lt;p&gt;龙猫 X 的数据通讯机制由订阅发布模式机制组成，以下罗列了在实际业务中组件间通讯的流向示意图：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;A 组件（A1 事件）-&amp;gt; 发布事件（主动事件） -&amp;gt; 订阅事件（被动事件） -&amp;gt; B 组件（B1 事件）

B 组件（B2 事件）-&amp;gt; C 组件（C1 事件）

立即注册（Button 组件）-&amp;gt; 显示弹窗（FixedContainer 组件）

立即签到（Button 组件）-&amp;gt; 签到接口（Interface 组件）

签到接口（Interface 组件）-&amp;gt; 签到成功（Interface 组件）&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;组件组织方式是扁平化的，事件关系具有零散化的特点。&lt;/p&gt;
&lt;p&gt;用户触发组件 A 的 A1 事件，经过发布订阅机制触达组件 B 的 B1 事件。如果 B1 事件是类似于显示/隐藏、改变样式等操作，那么属于一个数据流向的终点。&lt;/p&gt;
&lt;p&gt;如果 B1 事件是类似于发送请求等事件，请求响应成功即需要执行另一个回调命令，例如我们把 B2 看作请求的响应成功 &lt;code class=&quot;language-text&quot;&gt;fetchSuccess&lt;/code&gt; 事件，当请求响应成功后，自动执行后续连接的组件 C 的 C1 事件。&lt;/p&gt;
&lt;p&gt;从上述说明中，我们可以构建出龙猫 X 组件间事件流模型 &lt;code class=&quot;language-text&quot;&gt;组件 A 事件 A1 -&amp;gt; 组件B事件B1&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;组件B事件B2 =&amp;gt; 组件C事件C1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由于订阅发布通讯机制的存在，发布事件（我们称为主动事件）天然地与订阅事件（我们称为被动事件）自动连接起来，但是关键的节点在于，仍以上述组件 B 的例子数名，组件 B 内存在两个定义的事件 B1 和 B2，它们通过组件内部的代码设定的回调联系起来，但是在我们的配置数据层面并未解决，所以我们需要一份清单总结所有龙猫 X 组件中存在的组件内被动和主动事件非用户触发连接的关系表，这个对于后续构成事件链是关键的一步。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将零散事件关系，以收集组件事件内联的关系表解决单个事件通讯间无法连结的问题，最终组织成事件链&lt;/li&gt;
&lt;li&gt;通过某一事件，能自动触发后续事件（某些龙猫 X 定义为主动事件并非所有由用户触发，也能是组件内部触发）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/automatation-test-events-chain.jpg&quot; alt=&quot;事件链示意图&quot;&gt;&lt;/p&gt;
&lt;p&gt;上述图片展示了实际业务中的事件链示例，该事件链以名为「立即注册」的 Button 按钮组件触发，后续经由 Input 输入框组件获取已前置输入的手机号数据，内部数据流获取数据后触发 Input 组件内的另一个取值的主动事件，然后取值会检验输入框输入数据的有效性，根据有效性分流取值成功与取值失败的被动事件。如果取值失败，则会弹出 Message 组件提示输入框输入数据无效的相关信息；如果取值成功，则会用获取到的手机号和其他相关参数请求接口验证，响应后根据后台返回结果分流为进而请求另一个请求短信验证码的接口还是需要进行鉴定用户为真实用户的图形验证码操作。这就构成一条完整的事件链，整个事件链中除了输入框额外的数据收入外，用户只需触发一次「立即注册」的按钮即可检验后续流程。&lt;/p&gt;
&lt;p&gt;在制定事件链形成方案后，那么摆在面前的仍有几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何启动执行单个事件链？&lt;/li&gt;
&lt;li&gt;如何知道一个事件链流程已经执行完毕？&lt;/li&gt;
&lt;li&gt;在什么时机对执行结果进行断言测试？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过分析现有龙猫组件的特点。事件链触发种类主要有以下几个类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器默认事件：页面容器加载完毕、相关 SDK 注册成功等&lt;/li&gt;
&lt;li&gt;用户交互触发：点击按钮、点击图片&lt;/li&gt;
&lt;li&gt;组件钩子（被动性质/间接的主动事件）：接口请求成功失败/收集值成功失败/表单项值改变时/及贷 SDK 的 Ready 事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果对浏览器的的事件循环机制有过了解的，不难联想到这都与 JavaScript 异步事件相关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时器 Timer&lt;/li&gt;
&lt;li&gt;HTML Parsing&lt;/li&gt;
&lt;li&gt;HTTP Request&lt;/li&gt;
&lt;li&gt;I/O（Mouse、Event）&lt;/li&gt;
&lt;li&gt;Promise。then&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript 宿主环境运行中的事件循环机制（定时器、UI Rendering、I/O、HTTP Request）&lt;/li&gt;
&lt;li&gt;用于存储状态的表单高阶组件的取值事件（其实是相当于取值后，在组件内部设定校验逻辑）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上述生成事件链的机制，能将页面配置的事件链自动整理生成列表，后续需要通过测试服务进行自动化测试。&lt;/p&gt;
&lt;h2&gt;利用 Puppeteer 进行自动化测试&lt;/h2&gt;
&lt;p&gt;测试用的后端项目使用 Egg 的技术搭建，鉴于前后端信息交互可能会比较频繁的原因，搭配 Socket.IO 建立起前后端的通讯。&lt;/p&gt;
&lt;p&gt;这里需要注意的是，Socket.IO 前后端选用的具体库包具有差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端：&lt;code class=&quot;language-text&quot;&gt;socket.io-client&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后端：&lt;code class=&quot;language-text&quot;&gt;egg-socket.io&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;chat
├── app
│   ├── extend
│   │   └── helper.js
│   ├── io
│   │   ├── controller
│   │   │   └── default.js
│   │   └── middleware
│   │       ├── connection.js
│   │       └── packet.js
│   └── router.js
├── config
└── package.json&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Egg 框架的好处是其生态提供了相关的插件，很好地与项目集成，开发起来体验很好。&lt;/p&gt;
&lt;p&gt;具体实现细节参考 &lt;a href=&quot;https://eggjs.org/zh-cn/tutorials/socketio.html&quot;&gt;Egg - Socket.IO 教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而另一方面，需要使用业内较为成熟的测试方法进行测试，我们经过对比研究后选择 Puppeteer 这款由 Google 出品的开源支持无头浏览器的框架。&lt;/p&gt;
&lt;p&gt;Puppeteer 基于 Chrome DevTool Protocol（简称 CDP），而 CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速通道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/automatation-test-puppeteer-pyramid.png&quot; alt=&quot;Puppeteer 实现模型&quot;&gt;&lt;/p&gt;
&lt;p&gt;Puppeteer 广泛应用于各大公司团队的实际业务场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成页面的屏幕截图和 PDF&lt;/li&gt;
&lt;li&gt;自动化提交表单、模拟键鼠输入、自动化单元测试&lt;/li&gt;
&lt;li&gt;网站性能分析：可以抓取并跟踪网站的执行时间轴，帮助分析效率问题&lt;/li&gt;
&lt;li&gt;抓取网页内容，也就是我们常说的爬虫&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务实践&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阿里：&lt;a href=&quot;https://yq.aliyun.com/articles/718188&quot;&gt;阿里 99 大促模型识别背后的样本生成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;有赞：&lt;a href=&quot;https://www.infoq.cn/article/dcSBL_9AzCwVPsaQ70dh&quot;&gt;使用 Puppeteer 搭建统一海报渲染服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;其他：&lt;a href=&quot;https://www.jianshu.com/p/42585c78eeec&quot;&gt;基于 Puppeteer 打造前端巡检监控体系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么 Node 服务是如何与 Puppeteer 进行服务的呢？&lt;/p&gt;
&lt;p&gt;Puppeteer 提供一种方法 &lt;code class=&quot;language-text&quot;&gt;page.exposeFunction&lt;/code&gt; 将能在 Node 服务进程调用的函数方法名挂载在 Puppeteer 创建的测试页面的全局变量 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt; 上。&lt;/p&gt;
&lt;p&gt;当我们在触发事件链开端事件时，通过 Node 服务进而操作无头浏览器内的页面，并在专用于发布订阅模式事件关系传递中调用该挂载全局的函数，将相关参数结果返回到 Node 服务的相关服务中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/automatation-test-case.jpg&quot; alt=&quot;无头浏览器事件响应信息响应机制&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到，每当被动性质事件触发后，事件链中的被动事件会在触发时额外发送消息发送到 Node 服务，获得响应后跑过测试用例即将最终结果返回到前端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么同时多个 Node.js 进程会遭遇性能问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动耗时长&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复用浏览器实例和页面实例&lt;/li&gt;
&lt;li&gt;Puppeteer 的优化手段 =&gt; Chromium Command Line&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能消耗高&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时重启无头浏览器实例的机制 =&gt; 定时器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无头浏览器实例与测试页面 Tab 持久化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过请求 Headless Chrome 进程端口，获取无头浏览器实例的 WS URL，通过 &lt;code class=&quot;language-text&quot;&gt;browser.connect&lt;/code&gt; 重连&lt;/li&gt;
&lt;li&gt;Radis 缓存&lt;/li&gt;
&lt;li&gt;存文件&lt;/li&gt;
&lt;li&gt;存在 Egg App Config 中（相当于全局变量）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此这般，就将整个流程都实现了闭环：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据页面配置数据生成事件链（列表）&lt;/li&gt;
&lt;li&gt;选择前置数据输入及测试用例&lt;/li&gt;
&lt;li&gt;建立前后端通讯及测试服务和无头浏览器的通讯&lt;/li&gt;
&lt;li&gt;触发用户交互事件&lt;/li&gt;
&lt;li&gt;执行无头浏览器内页面对应事件&lt;/li&gt;
&lt;li&gt;返回响应结果&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[2019年度总结与2020展望计划]]></title><description><![CDATA[2019 积极思考 拥抱变化 2020 未来趋势 持续精进 2019 积极思考 随着年龄的增长，对时间的感知是流逝得越来越快，明明感觉新年才过去没过久，就到了 2019 年的尾声，是时候为自己变化颇大的一年做个总结，同时也为 202…]]></description><link>http://mrsingsing.com/end-of-2019-summary-and-2020-outlook/</link><guid isPermaLink="false">http://mrsingsing.com/end-of-2019-summary-and-2020-outlook/</guid><pubDate>Sat, 21 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2019&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;积极思考&lt;/li&gt;
&lt;li&gt;拥抱变化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未来趋势&lt;/li&gt;
&lt;li&gt;持续精进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2019&lt;/h2&gt;
&lt;h3&gt;积极思考&lt;/h3&gt;
&lt;p&gt;随着年龄的增长，对时间的感知是流逝得越来越快，明明感觉新年才过去没过久，就到了 2019 年的尾声，是时候为自己变化颇大的一年做个总结，同时也为 2020 年做好战略规划。&lt;/p&gt;
&lt;p&gt;今年对于我个人而言体悟得最深的一个道理就是 &lt;code class=&quot;language-text&quot;&gt;选择比努力重要&lt;/code&gt;。当然，这不是否定努力的重要性，而是在重大决策分叉面前选择了对的方向，往往能事半功倍。这体现在个人职业生涯规划、个人生活理想实现等具有长期性的决策选择上。回顾过去的人生，在很多人生关键点上正是因为选择错误导致走了很多弯路。而努力事实上应该体现在每天的工作上保持热情，用行动对抗精神上肉体上的懒惰，并采取有效的方法去提升自己的知识技能。这其实是一个不断的循环，努力后才有更多更好的选择，选择后又需要持续努力去为下一次人生选择做好准备。&lt;/p&gt;
&lt;p&gt;从业前端两年以来，一直在思考工作上遇到的问题，一直在思考行业快速更迭的技术栈，对于个人而言，应该如何应对各种变化产生的焦虑。作为软件开发者，在企业中的定位是技术提供者，而盈利最终依靠的业务，互联网企业业务需要技术提供支撑，技术在企业业务中担当的更多是平台、工具的角色，最终需要为业务服务，即便是技术含量高的公司，提供例如安全、大数据、人工智能等服务的公司最终也是为甲方提供技术支撑，不同的只是决策权是在业务部门还是技术部门的区别。&lt;/p&gt;
&lt;p&gt;在前公司工作时意识到仅仅耕耘自身的三亩地是不够的，互联网企业分工精细，前端只是在为工作流程中的一环，上游有 运营、产品、UI 和 UX，下游有后端、数据、运维等，在工作中无可避免跨部门的协作，如果只懂前端的技术，沟通时就需要很大的成本，工作效率就会因此降低。因此，平时也会有意地观察不同部门不同岗位他们的工作内容、工作方式，了解他们领域相关概念知识，逐渐地沟通效率就提高了，任务完成的速度也会越来越快。&lt;/p&gt;
&lt;p&gt;当我在意识到这些的时候，会习惯性抽象出具有共性的思考方法，例如就前端技术而言，了解不同的框架，寻找共性的地方，不变的是原理，变的只是 API 和书写代码的约定规范不同而已，那么需要用到新框架新技术的时候，就不必那么的焦虑，运用以往的学习范式能很快地学习新的技术，以前端的框架来举例，React 和 Vue 都是国内业界使用最多框架，即便使用方法上和实现上有很大不同，但本质上都是将开发者编写的代码经由 JavaScript 引擎处理后生成实际的 DOM 节点并映射到 DOM 树上，API 可以通过查阅文档获知使用方法，进阶甚至高阶用法可以通过阅读别人的代码来模仿学习。&lt;/p&gt;
&lt;h3&gt;拥抱变化&lt;/h3&gt;
&lt;p&gt;今年最大的变化就是换了工作，得益于持续的思考，在一年前就开始渴望到更大的平台发展。但是我深知贸贸然地裸辞是不理智的行为，当时我是先试着更新简历，发现工作第一年并没有特别的亮点值得在简历上写，技术栈也和刚开始找工作时候并没有什么不同，相较于毕业后一开始工作只是获得了实际的项目经验而已，而这些简单的项目经验并不足以让我找到一份更理想的工作。&lt;/p&gt;
&lt;p&gt;在充分观察自己的工作简历后，下一步就是去填补缺陷。但是现在前端相关的技术如此多，要选择学什么呢？其实最简单的就是看招聘软件上企业的招聘要求，尤其是一些大厂的 JD，了解这些 JD 不仅能知道大厂使用哪些技术栈，而大厂往往在行业中能主导或引领技术的方向，同时也是知道了行业技术风向。但是也不是什么都学，学到的技术最终还是要服务于业务，应用于生产当中。所以我着手对当时维护迭代的几个项目进行改造升级，例如通过深入研究 Webpack 提升开发体验和构建优化，思考项目的工程架构包括项目目录，数据存储方式等等。在这期间研读了大量的文章，通常在学习一个知识点的时候都会寻找网络上相关文章都阅读一遍，后来发现读完后很快的会忘记，或者之前发现的一篇优质的文章找不到了很难过，所以后来都将优秀的文段，根据自己的思路和知识的体系摘抄成笔记，一来加深的印象，二来在日后的工作中也能随时查阅。&lt;/p&gt;
&lt;p&gt;比如完成或完成大部分的笔记有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tsejx/JavaScript-Guidebook&quot;&gt;JavaScript-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tsejx/Git-Guidebook&quot;&gt;Git-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tsejx/Webpack-Guidebook&quot;&gt;Webpack-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tsejx/React-Guidebook&quot;&gt;React-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tsejx/Vue-Guidebook&quot;&gt;Vue-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实还有另一些前端相关的笔记，但是已经开头还没形成整个知识体系的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tsejx/CSS-Guidebook&quot;&gt;CSS-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tsejx/node-guidebook&quot;&gt;Node-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tsejx/TypeScript-Guidebook&quot;&gt;TypeScript-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tsejx/DevOps-Guidebook&quot;&gt;DevOps-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于寻求在中小企业间跳槽的人来说，找工作的确需要些运气，不管是可以选择尝试的公司，还是遇到的面试官。好的面试官能很好地引导你的思路，针对的你的回答向更广更深的内容扩展。虽然是企业在做招聘，但其实在应聘当中也是考察这间公司是否靠谱的一个过程，面试官通常都是以后的直属上司，谈得来的上司在以后的工作交流中会顺畅很多。&lt;/p&gt;
&lt;h2&gt;2020&lt;/h2&gt;
&lt;h3&gt;未来的趋势&lt;/h3&gt;
&lt;p&gt;现在技术社区喜欢贩卖焦虑，当有新技术出现的时候，底下的评论几乎都是学不动了学不动了，不排除只是一种调侃而已，但也体现了国内软件开发者承担职业发展压力的状态。我也一直在思考，所谓的 35 岁职业就要面临裁员的问题，虽然个人在看到这些报道或讨论时也不免有所焦虑，但对未来还是持有乐观态度，毕竟高级人才无论何时都是紧缺的，社会在动态发展，大部分的从业者实际上只是在做重复性的、创新价值低的工作，这些工作在我看来会被逐渐取代。这不意味着这些工作会被取缔，而是会更加高效率地完成，通俗来说就是以后可能一个（高级）前端顶替两个三个前端，其实望行业巨头例如阿里、腾讯等看，不难发现慢慢地他们招聘的最低门槛也在不断提高，这印证了这种想法的趋势。&lt;/p&gt;
&lt;h3&gt;持续精进&lt;/h3&gt;
&lt;p&gt;马上要迎接下一个年度了，免不了制定计划为未来一年做好准备。但是我这人好像从来都不缺少计划，只是完成计划的执行效率并不能满足计划，所以相比于计划本身，可能需要更加关注效率本身。在之前的转正时和组长面谈时，他提到我要晋升可能需要更加关注的两个大方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扩展知识广度，延续过去追求知识深度&lt;/li&gt;
&lt;li&gt;提升个人影响力（业务、技术、团队、行业）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;扩展知识广度&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;建立更加完善的个人知识体系&lt;/p&gt;
&lt;ul&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 建立 Node.js 的知识体系，完成 &lt;a href=&quot;https://github.com/tsejx/node-guidebook&quot;&gt;Node-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 建立 TypeScript 的知识体系，完成 &lt;a href=&quot;https://github.com/tsejx/TypeScript-Guidebook&quot;&gt;TypeScript-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 建立前端开发及运维相关知识体系，完成 &lt;a href=&quot;https://github.com/tsejx/DevOps-Guidebook&quot;&gt;DevOps-Guidebook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提升前端硬编程功能&lt;/p&gt;
&lt;ul&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 掌握数据结构、算法，每周至少一道 LeetCode 题目&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 掌握前端设计模式，完成 JavaScript-Pattern-Guidebook&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 弥补服务端相关内容，包括操作系统原理、行业常见框架技术及实践方案，并在个人的项目中熟练运用，包括已经启动的个人资源内容管理系统前后端相关的多个项目、个人理财资讯管理平台项目等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;提升个人影响力&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;持续输出，正向反馈&lt;/p&gt;
&lt;ul&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 坚持每天做学习日志记录，坚持每周写工作与知识储备周报&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 输出至少 26 篇具有思考深度的文章（平均每月两篇）&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 积极参与 Github 讨论，至少在 issues 中提出 50 个建设性意见，提出任意项目 25 个 PR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在团队中的个人影响力&lt;/p&gt;
&lt;ul&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 定期整理业务 Wiki 将常见、常用、常遇的 issues 沉淀下来，减少相关同事接手时的困难度&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 主动分享新技术和新想法，主动解决其他同事遇到的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/li563868273/article/details/80918368&quot;&gt;技术人应该如何提升影响力&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[可视化配置系统页面批量更新工具的开发实践]]></title><description><![CDATA[首发于：可视化配置系统页面批量更新工具的开发实践 TotoroX 作为 PPmoney 集团内部集 UI…]]></description><link>http://mrsingsing.com/practice-of-page-batch-update-tool-in-visual-configuration-system/</link><guid isPermaLink="false">http://mrsingsing.com/practice-of-page-batch-update-tool-in-visual-configuration-system/</guid><pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;首发于：&lt;a href=&quot;https://juejin.im/post/5dc8fd92f265da4d287f4551&quot;&gt;可视化配置系统页面批量更新工具的开发实践&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TotoroX 作为 PPmoney 集团内部集 UI 和业务逻辑于一体的前端页面可视化配置系统，为运营部门提供快速构建前端页面的解决方案。该系统为页面开发及运营人员提供了强大的组件市场，通过拖拽、表单配置等方式实现专题页面的业务需求。目前已支撑集团 850+营销活动页面。&lt;/p&gt;
&lt;h2&gt;业务痛点&lt;/h2&gt;
&lt;p&gt;在产品设计阶段，产品经理会根据对用户的调研，借助用户画像理解用户的需求，想想用户使用的场景，以及他们可能会遇到的困难。随着产品上线后，运营团队通过转化漏斗分析用户交互行为以及最终的转化的实际效果。所以这个阶段，随着真实用户群体的积累，在设计阶段虚构的用户画像需要重新调研、设想。&lt;/p&gt;
&lt;p&gt;而在技术的角度，我们也希望通过用户行为数据，为产品运营提供更好的支撑，例如为不同的用户提供不同 UI 的前端页面，通过对比的方法观察数据变化，以此作为对用户行为的准确判断。&lt;/p&gt;
&lt;p&gt;以下面的营销活动页为例，我们会在既有的页面配置中生成新的页面，并根据设计要求进行局部的调整，除了 UI 部分，内部逻辑包括埋点数据、事件链条关系等也会进行相关的修正。在此需求背景之下，如果需要人工手动对每个配置页面进行修改，这将会耗费大量的人力资源。而且，上文提到会涉及逻辑的修改，配置人员不易发现变更的地方，无法对修改后的页面进行校验。综上所述，我们需要一款对比前后变化的工具，能够可视化地对不同的配置数据进行对比，并通过图形绘制的形式清晰知道配置数据树中哪些节点没有修改，哪些节点修改了，修改前后的值又是什么，就好像我们进行代码协助时通过 &lt;code class=&quot;language-text&quot;&gt;git diff&lt;/code&gt; 能够知道文件中哪行代码发生了冲突，通过人工判断对冲突进行修改合并，并最终达到我们需要的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-abtest.jpg&quot; alt=&quot;AB Test&quot;&gt;&lt;/p&gt;
&lt;p&gt;TotoroX 基于用户配置的数据组装生成页面，配置数据均由组件市场的物料支撑，单个组件的配置数据结构基本相同，包括但不限于：唯一标识、组件名称、组件属性、组件样式、组件事件链以及动画相关配置等。组件间在配置数据的集合中是扁平化的，通过各组件配置数据中的标识集合相互关联起来，这样的数据结构设计避免了因为嵌套层级过深而产生的问题。基于这些条件，为多路差异化对比以及合并提供了可能。&lt;/p&gt;
&lt;h2&gt;差异化配置数据结构的设计&lt;/h2&gt;
&lt;p&gt;在进行配置数据的对比合并前，需要设计出能够准确描述数据变化前后的数据结构。&lt;/p&gt;
&lt;p&gt;在 TotoroX 中，配置数据的结构模式与 JSON 的结构模式一致，因此数据结构的设计应以 JSON 的数据结构为基础。&lt;/p&gt;
&lt;p&gt;而在 JSON 中值存在以下几种数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;li&gt;布尔值&lt;/li&gt;
&lt;li&gt;数值&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我们不用考虑诸如 Date、Function、Symbol、Set 等数据类型的值。&lt;/p&gt;
&lt;p&gt;同时，在设定的配置数据中不能存在空值 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;，如果要表示不对某配置项作配置，实际上会采用默认的配置属性，所以在实际配置数据中，是不会存在空值存在，可以忽略这种情况。&lt;/p&gt;
&lt;p&gt;综合上述，从大致上能分为两大类数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本数据类型：字符串、布尔值、数值&lt;/li&gt;
&lt;li&gt;引用数据类型：数组、对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么我们是怎样去描述 JSON 对比前后变更状态呢？&lt;/p&gt;
&lt;p&gt;JSON 是目前应用广泛的数据交换格式，那么交换双方肯定需要对数据进行约定和校验，而 JSON Schema 就是扮演定义 JSON 数据约束的标准。因此，我们尝试引入 JSON Schema 的概念，并结合实际功用进行改造。&lt;/p&gt;
&lt;p&gt;传统的 JSON Schema 表现为这样：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;$schema&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;http://json-schema.org/draft-07/schema#&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;$id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;http://example.com/product.schema.json&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Product&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;A product from Acme&apos;s catalog&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;object&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;properties&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;productId&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;The unique identifier for a product&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;integer&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;productName&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Name of the product&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;string&quot;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;price&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;The price of the product&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;number&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;exclusiveMinimum&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;tags&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Tags for the product&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;array&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;items&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;string&quot;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;minItems&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;uniqueItems&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;dimensions&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;object&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;properties&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token property&quot;&gt;&quot;length&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;number&quot;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token property&quot;&gt;&quot;width&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;number&quot;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token property&quot;&gt;&quot;height&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token property&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;number&quot;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token property&quot;&gt;&quot;required&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;length&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;width&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;height&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;required&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;productId&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;productName&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;price&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从形式上来讲，JSON Schema 还是 JSON 的格式，但不同的是，JSON Schema 会在原来的 JSON 基础上在每个层级的数据外包装了一层用以描述对应层级值的相关信息，包括对应层级的值、描述、数据类型以及其它额外配置的信息。&lt;/p&gt;
&lt;p&gt;在结构上，我们沿用了 JSON Schema 的一套标准，在源数据基础上通过遍历递归的方法对数据进行描述。而在描述的信息上，我们针对实际的应用场景进行了定制。&lt;/p&gt;
&lt;p&gt;描述信息中必不可少的就是对数据变化信息的描述，我们参考了 Git 管理代码变更的策略，在两两对比下，我们梳理出可能产生的四种值比较情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;相等（Equal）&lt;/strong&gt;：当两个基本数据类型的值严格相等时，则为相等状态；而对于引用数据类型，需要提供额外的手段进行匹配&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新增（Add）&lt;/strong&gt;：当对象间对比时，目标对象存在新增的键时，描述该键值为新增状态；同理，当数组中无对应的匹配项时，则为新增状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;删除（Delete）&lt;/strong&gt;：与新增状态类似，当对象间对比时，目标对象存在删除的键时，描述该键值为删除状态，而数组中对应的匹配项不存在时，则为删除状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冲突（Conflict）&lt;/strong&gt;：当两个基本数据类型的值不严格相等时，则为冲突状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个例子，如下为两个个仅有一个按钮组件的配置页数据集合：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-data-structure-comparation-.jpg&quot; alt=&quot;修改前后的配置数据&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过 diff 后预设能产生的数据结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-result-data-structure.jpg&quot; alt=&quot;对比后产生的数据结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们对描述变化的数据结构进行了约定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象类型和数组类型的值使用 &lt;code class=&quot;language-text&quot;&gt;_properties&lt;/code&gt; 字段描述，对应值被源数据对应的数据类型包裹&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本数据类型的值根据具体值的状态 &lt;code class=&quot;language-text&quot;&gt;_status&lt;/code&gt; 决定展示的字段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相等（Equal）：使用 &lt;code class=&quot;language-text&quot;&gt;_origin&lt;/code&gt; 表示值&lt;/li&gt;
&lt;li&gt;新增（Add）：使用 &lt;code class=&quot;language-text&quot;&gt;_target&lt;/code&gt; 表示新增的值&lt;/li&gt;
&lt;li&gt;删除（Delete）：使用 &lt;code class=&quot;language-text&quot;&gt;_origin&lt;/code&gt; 表示删除的值&lt;/li&gt;
&lt;li&gt;冲突（Conflict）：使用 &lt;code class=&quot;language-text&quot;&gt;_orign&lt;/code&gt; 表示更改前的值，&lt;code class=&quot;language-text&quot;&gt;_target&lt;/code&gt; 表示更改后的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你也许会发现即便是对象类型和数组类型，也会有 &lt;code class=&quot;language-text&quot;&gt;_status&lt;/code&gt; 字段描述更改状态。这是因为我们在交互界面上采取了&lt;strong&gt;自底向上&lt;/strong&gt;的状态变更显示策略。例如，当一个组件配置数据大部分保持不变的情况下，样式配置字段 &lt;code class=&quot;language-text&quot;&gt;style&lt;/code&gt; 中的 &lt;code class=&quot;language-text&quot;&gt;height&lt;/code&gt; 配置项改变了值，那么除了描述该字段的 Schema 结构中状态字段 &lt;code class=&quot;language-text&quot;&gt;_status&lt;/code&gt; 会显示为冲突（Conflict）外，在递归返回的过程中，亦会将层级更高的对象或数组状态标记为冲突（Conflict）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要特别说明的是，如果下层结构仅有一种变化状态时，上层结构会显示该变化状态，而下层结构存在不只一种变化状态时，则上层会统一表示为冲突状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-status-display-tatics.jpg&quot; alt=&quot;状态自底向上传递显示策略&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样处理的目的，是为了树结构在可视化视图组装渲染后能够更清晰地让配置人员知道各节点的状态。树状的图形能够让开发人员快速知道哪些组件配置项发生了变更，并能沿着路径找到变化的根源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-path-to-root.jpg&quot; alt=&quot;可视化冲突解决界面&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Diff 功能实现&lt;/h2&gt;
&lt;p&gt;约定好对比后的数据结构后，那么就要通过方法封装对变化前后的页面配置数据进行比较。&lt;/p&gt;
&lt;p&gt;在实现 diff 方法前，就设想实现的方法应该能保证在不同的配置数据结构下也能使用。也就是说，实现过程需要脱离业务相关的代码，尽可能保证方法通用性。&lt;/p&gt;
&lt;p&gt;而在实现过程中，我们遇到的其中一个问题就是当对比双方的数组类型且其数组成员为对象类型时，我们需要为此类情况提供用于匹配的方法。&lt;/p&gt;
&lt;p&gt;我们以 TotoroX 的配置为例来解释为什么需要为数组结构的比较提供匹配方法。例如 TotoroX 的配置数据中 &lt;code class=&quot;language-text&quot;&gt;eventList&lt;/code&gt; 字段表示组件相关的事件列表，每个事件（对象）之间的 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; 字段是唯一的，因此我们在对比 &lt;code class=&quot;language-text&quot;&gt;eventList&lt;/code&gt; 数组时，需要明确对象数组中各成员的 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; 键值为严格相等，才能对双方进行后续的 diff。而实际上，并非所有对象数组都通过 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; 字段进行匹配，将类似的代码参杂到通用类型方法中显然是不恰当的。因此，我们需要提高类库的可拓展性，将用于对象数组匹配的方法抽离，并通过配置的形式植入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-button-data.jpeg&quot; alt=&quot;Button组件配置&quot;&gt;&lt;/p&gt;
&lt;h3&gt;数组辅助方法&lt;/h3&gt;
&lt;p&gt;对象数组间的匹配筛选在实现中应用的场景是较多的，因此我们封装了一系列的辅助方法减少重复的代码，包括：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组差集函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过数组成员间逐一对比，筛选出两数组中所有成员的差集集合并返回（仅限于数组成员为基本类型值）&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getDifference&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;has&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;功能同上，当对象数组成员为对象类型时使用，需要提供用于匹配的比较器函数，返回结果只保留以参数 &lt;code class=&quot;language-text&quot;&gt;a&lt;/code&gt; 传入的数组的成员项&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getDifferenceWith&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;comparator&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;findIndex&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;comparator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;数组交集函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过数组成员间逐一对比，筛选出两数组中所有成员的交集集合并返回（仅限于数组成员为基本类型值）&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getIntersection&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;has&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;功能同上，当对象数组成员为对象类型时使用，需要提供用于匹配的比较器函数，返回结果只保留以参数 &lt;code class=&quot;language-text&quot;&gt;a&lt;/code&gt; 传入的数组的的成员项&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getIntersectionWith&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;comparator&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;findIndex&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;comparator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;数组并集函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getUnionWith&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;comparator&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; Array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;findIndex&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;comparator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;数组去重函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getDedupeBy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arr&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;comparator&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; arr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; v&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;acc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;some&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;comparator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;v&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      acc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;v&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; acc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以留意到，上述辅助函数除了用于匹配的两个数组类型的参数外，还需要提供一个 &lt;code class=&quot;language-text&quot;&gt;comparator&lt;/code&gt; 的参数。&lt;code class=&quot;language-text&quot;&gt;comparator&lt;/code&gt; 意为比较器，类型为函数类型，用于封装方法内部 &lt;code class=&quot;language-text&quot;&gt;filter&lt;/code&gt; 函数对应的回调函数，从而筛选出用以匹配数组的对象成员。如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;comparator&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示为 &lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt; 对象的 &lt;code class=&quot;language-text&quot;&gt;id&lt;/code&gt; 字段与 &lt;code class=&quot;language-text&quot;&gt;y&lt;/code&gt; 对象的 &lt;code class=&quot;language-text&quot;&gt;id&lt;/code&gt; 字段完全相等时，表示 &lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt; 对象和 &lt;code class=&quot;language-text&quot;&gt;y&lt;/code&gt; 对象为匹配的双方。&lt;/p&gt;
&lt;p&gt;通过这样的形式，我们能够将配置中数组形式存在的配置项的匹配字段以 &lt;code class=&quot;language-text&quot;&gt;comparator&lt;/code&gt; 的形式配置植入，而不必在实现的代码中植入业务相关的代码。当然，仅仅如此并不够的，因为还无法解决到底配置结构中到底哪个层级是数组类型的值，下面会详细解析如何解决这个问题。&lt;/p&gt;
&lt;h3&gt;差异化流程实现&lt;/h3&gt;
&lt;p&gt;根据 JSON 的不同类型的处理方式的不同，我们实现了三个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;diffObject&lt;/code&gt;：用于对象类型值之间的对比方法，通过 &lt;code class=&quot;language-text&quot;&gt;Object.keys&lt;/code&gt; 获取各自对象的键名集合，配合数组差集函数和数组交集函数，可以筛选出新对象中新增的字段集合、旧对象中删除的字段集合以及新对象和旧对象共有的字段集合&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;diffArray&lt;/code&gt;：用于数组类型值之间的对比方法，通过 &lt;code class=&quot;language-text&quot;&gt;comparator&lt;/code&gt; 比较函数入参，同样利用差集函数和交集函数，分别筛选出新数组中新增的数组成员、旧数组中删除的数组成员以及各自数组中共有的数组成员&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;diffValue&lt;/code&gt;：用于基本数据类型值的对比方法，采用严格相等的对比方式，若相等则为相等（Equal）状态，否则为冲突状态（Conflict）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用类型的值比较（也就是 &lt;code class=&quot;language-text&quot;&gt;diffObject&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;diffArray&lt;/code&gt;）在匹配到键值或数组成员时，会利用调和函数作为匹配跳板，根据传入数据源类型不同继续对下层结构的值递归执行上述三种不同数据类型的方法。&lt;/p&gt;
&lt;p&gt;而旧对象/旧数组中删除的值或新对象/新数组中新增的值，则不会再进行深层次的递归，会直接投放到另一个处理方法 &lt;code class=&quot;language-text&quot;&gt;getRecursion&lt;/code&gt; 中递归修改下层结构中的变化状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-workflow.jpg&quot; alt=&quot;diff结构流程图&quot;&gt;&lt;/p&gt;
&lt;p&gt;对象类型值之间的比较，我们会使用 &lt;code class=&quot;language-text&quot;&gt;Object.keys()&lt;/code&gt; 方法分别获取两个对比对象的键名，并通过数组辅助方法拆分为三组：共同拥有的键名的集合、仅有 &lt;code class=&quot;language-text&quot;&gt;origin&lt;/code&gt; 对象（理解为变化前的配置对象）拥有的键名的集合和 &lt;code class=&quot;language-text&quot;&gt;target&lt;/code&gt; 对象（理解为变化后的配置对象）拥有的键名集合。&lt;/p&gt;
&lt;p&gt;由此可得，共同拥有的键名集合需要通过比较得出变化状态。而 &lt;code class=&quot;language-text&quot;&gt;origin&lt;/code&gt; 对象拥有的键名，则表示 &lt;code class=&quot;language-text&quot;&gt;target&lt;/code&gt; 对象没有，也就是 &lt;code class=&quot;language-text&quot;&gt;origin&lt;/code&gt; 对象集合中的键值被删除了，会被标记为删除状态。相似地，仅 &lt;code class=&quot;language-text&quot;&gt;target&lt;/code&gt; 对象拥有的键名表示 &lt;code class=&quot;language-text&quot;&gt;origin&lt;/code&gt; 没有该键名，则 &lt;code class=&quot;language-text&quot;&gt;target&lt;/code&gt; 的键值为新增配置项，会被标记为新增状态。&lt;/p&gt;
&lt;p&gt;刚才提到对象数组类型之间需要通过比较器函数 &lt;code class=&quot;language-text&quot;&gt;comparator&lt;/code&gt; 用于匹配，但是需要提供一种让运行机制知道什么样的数组对比需要用怎样的 &lt;code class=&quot;language-text&quot;&gt;comparator&lt;/code&gt;。在运行 diff 前，我们通过以递归路径为键名，以 &lt;code class=&quot;language-text&quot;&gt;comparator&lt;/code&gt; 为键值组成的配置对象传入 &lt;code class=&quot;language-text&quot;&gt;diff&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;在向下递归进行配置项比较时，遇到对象类型的值，会将键名传入调和函数。在函数内部，会被推入一个已声明的面包屑栈（也称为递归路径，以数组形式表示），当返回值时，又会退栈。当检查到下层结构为数组类型时，会通过 &lt;code class=&quot;language-text&quot;&gt;Array.prototype.join()&lt;/code&gt; 方法将面包屑栈中的值合成键名路径，匹配外部传入的比较器配置后，将下层数组结构匹配所需的 &lt;code class=&quot;language-text&quot;&gt;comparator&lt;/code&gt; 传入 &lt;code class=&quot;language-text&quot;&gt;diffArray&lt;/code&gt; 中。这样就解决了对象数组匹配的问题，同时也将相关的业务代码抽离至外部，提升了方法的通用性和可配置性。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; comparator &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 如果原始数据为数组类型（也就是传入数据最外层为数组类型），必须有 init 字段作为 comparator 函数&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;eventList&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&apos;eventList.value&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&apos;eventList.subEvents&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&apos;eventList.subEvents.actions&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;animation&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;antType &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;antType&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⚠️&lt;strong&gt;注意&lt;/strong&gt;：如果原始数据为数组类型，则必须提供 &lt;code class=&quot;language-text&quot;&gt;init&lt;/code&gt; 作为根（顶层）结构的比较器函数。&lt;/p&gt;
&lt;p&gt;上述就是 diff 功能实现过程中遇到的主要问题的解决方案，但是仅对两路的配置数据进行 diff 是不够的，这主要是从我们本身 TotoroX 的业务考虑。如前文所述 &lt;code class=&quot;language-text&quot;&gt;origin&lt;/code&gt; 可以为用于创建页面的模版，&lt;code class=&quot;language-text&quot;&gt;target&lt;/code&gt; 为基于模版创建的页面，但后续需求变更时会对模版数据进行修改，而在我们的系统中并不会同步到创建的页面，那么模版修改后需要将修改的内容同步到之前创建的页面，就需要提供一个用于合并新模版与旧页面的方法，下面我们就聊聊 merge 功能的实现。&lt;/p&gt;
&lt;h2&gt;Merge 功能实现&lt;/h2&gt;
&lt;p&gt;在对 merge 功能实现过程进行讲解前，我们需要对 git 的合并策略进行一定程度的了解。&lt;/p&gt;
&lt;p&gt;git 采用三路合并策略：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;B - C - D master(*)
 \
  E - F dev&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以我们日常的开发协作流程为例，当前分支也就是主分支为 &lt;code class=&quot;language-text&quot;&gt;master&lt;/code&gt;，当尝试把 &lt;code class=&quot;language-text&quot;&gt;dev&lt;/code&gt; 开发分支合并到 &lt;code class=&quot;language-text&quot;&gt;master&lt;/code&gt; 时，两个分支共同拥有的提交就是 commitB，我们将该提交 commit 称为 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;master&lt;/code&gt; 分支最新的提交 commitD 称为 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt;，而 &lt;code class=&quot;language-text&quot;&gt;dev&lt;/code&gt; 分支最新的提交 commitF 称为 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么 git 是怎样合并 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 的呢？&lt;/p&gt;
&lt;p&gt;在合并时，会参考他们的共同祖先 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt;，并根据下面策略进行合并。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;祖先（base）&lt;/th&gt;
&lt;th&gt;HEAD（ours）&lt;/th&gt;
&lt;th&gt;分支（theirs）&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;如果一方修改了一行，那么这一行选择修改版的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;如果某一行双方拥有相同的变更，则选择修改过的行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;conflict&lt;/td&gt;
&lt;td&gt;如果某一行双方都修改了，且修改得不一样，则报告冲突，需要用户解决&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;根据上表规则，合并过程类似这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-merge-strategy.png&quot; alt=&quot;合并过程&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，第四行，双方都修改了，且各自修改的内容不一样，所以 git 不知道怎么解决，所以就把问题抛给用户了。&lt;/p&gt;
&lt;h3&gt;根节点层级筛选合并&lt;/h3&gt;
&lt;p&gt;我们在实现 merge 功能时，正是采用了与此种合并策略一致的方式。在 merge 的合并流程中，原始数据即为&lt;strong&gt;祖先&lt;/strong&gt;（base），而实际需要合并的两份数据分别为 &lt;strong&gt;Head&lt;/strong&gt;（ours）和&lt;strong&gt;分支&lt;/strong&gt;（theirs）。我们将 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 作为中间者，以此判断两份配置数据哪些部分是属于原始数据的，哪些部分又是新数据。&lt;/p&gt;
&lt;p&gt;首先，我们分别将新数据与共同组件 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 进行 diff 操作，获得分别的 JSON Schema 结构的结果，后续再对结果进行 mergeBranch 的操作。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;base&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ours&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; theirs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; diffComparator&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mergeComparator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; originDiff &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;base&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ours&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; diffComparator&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; targetDiff &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;base&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; theris&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; diffComparator&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; newDataSchema &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mergeBranch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;originDiff&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; targetDiff&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mergeComparator&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; newDataSchema&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而由于 merge 是根据两两 diff 后的 Schema 结构的 JSON，我们先从&lt;strong&gt;根节点&lt;/strong&gt;的 &lt;code class=&quot;language-text&quot;&gt;_status&lt;/code&gt; 字段匹配进行区分，共有五种情况：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;源配置数据根节点状态&lt;/th&gt;
&lt;th&gt;变更配置数据根节点状态&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Equal&lt;/td&gt;
&lt;td&gt;Equal&lt;/td&gt;
&lt;td&gt;表示 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 完全相等，&lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 完全相等，即表示三路完全相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Equal&lt;/td&gt;
&lt;td&gt;Updated&lt;/td&gt;
&lt;td&gt;表示 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 完全相等，&lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 存在变更，即单路变更，最终给你会采用变更路数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Updated&lt;/td&gt;
&lt;td&gt;Equal&lt;/td&gt;
&lt;td&gt;表示 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 存在变更，&lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 完全相等，即单路变更，最终给你会采用变更路数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Updated&lt;/td&gt;
&lt;td&gt;Updated&lt;/td&gt;
&lt;td&gt;表示 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 存在变更，&lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 也存在变更，但是变更对应的值不相等，即三路冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Updated&lt;/td&gt;
&lt;td&gt;Updated&lt;/td&gt;
&lt;td&gt;表示 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 存在变更，&lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 也存在变更，但是变更对应的值相等，实际上 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 变更值与 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 值冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-merge-venn-diagram.jpg&quot; alt=&quot;变更状态韦恩图&quot;&gt;&lt;/p&gt;
&lt;p&gt;对上述五种情况进行分析归纳后，在代码实现层面上可以大致分为三个方向处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;三路相等（A-A-A）=&gt; &lt;code class=&quot;language-text&quot;&gt;mergeUnmodified&lt;/code&gt;（相当于上文韦恩图天蓝色部分中状态为 &lt;code class=&quot;language-text&quot;&gt;equal&lt;/code&gt; 的部分）&lt;/li&gt;
&lt;li&gt;单路变更，采用变更路数据（A-A-B、A-B-A）=&gt; &lt;code class=&quot;language-text&quot;&gt;mergeUpdated&lt;/code&gt;（相当于上文韦恩图紫色和橙色部分，表示的是 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 存在但是存在变更的状态，可以是完全或局部的删除和冲突，也可以是局部配置项的新增，但是不可能是完全的新增）&lt;/li&gt;
&lt;li&gt;两路变更，根据变更情况选择或保留冲突状态并提供手动处理方式，变更又分为新增、删除和修改（A-B-B、A-B-C）=&gt; &lt;code class=&quot;language-text&quot;&gt;mergeConflict&lt;/code&gt;（相当于上文韦恩图绿色、红色和蓝灰色）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三路相等的情况是最好处理的，在对根节点进行遍历时匹配两者的 &lt;code class=&quot;language-text&quot;&gt;_status&lt;/code&gt; 变化状态为相等状态（&lt;code class=&quot;language-text&quot;&gt;equal&lt;/code&gt;）时即表明三路相等。&lt;/p&gt;
&lt;p&gt;单路变更的情况，在对根节点进行遍历时匹配两者的 &lt;code class=&quot;language-text&quot;&gt;_status&lt;/code&gt; 为相等（&lt;code class=&quot;language-text&quot;&gt;equal&lt;/code&gt;）而另一方为不相等，即为需要采用变更路数据。&lt;/p&gt;
&lt;p&gt;而对于两路变更的情况，我们不能单纯地以根节点的状态作为区分，这是因为我们采用了上文提及过的&lt;strong&gt;自底向上的状态变更显示策略&lt;/strong&gt;，所以根节点呈现为变更状态，不代表整个结构内部的属性均为变更状态，也可能因为某个配置项的变更，导致结构树上层的状态改变。所以对于这种情况，我们又能细分为两种情况进行处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 &lt;code class=&quot;language-text&quot;&gt;comparator&lt;/code&gt; 比较函数能两两匹配的节点树，实际上为 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 三路均存在该根节点的，则需要对双方子孙层级的节点进行递归遍历并逐一对比（相当于上文韦恩图中蓝色 &lt;code class=&quot;language-text&quot;&gt;conflict&lt;/code&gt; 的部分）&lt;/li&gt;
&lt;li&gt;在对比双方的配置数据中，根节点状态 &lt;code class=&quot;language-text&quot;&gt;_status&lt;/code&gt; 为新增状态（&lt;code class=&quot;language-text&quot;&gt;add&lt;/code&gt;）且子孙层级的配置属性值也为新增状态时，则可判断该配置树为完全新增（相当于上文韦恩图中绿色 &lt;code class=&quot;language-text&quot;&gt;add&lt;/code&gt; 的部分），按照约定的合并策略，需要保留整个配置树&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;子孙层级筛选合并&lt;/h3&gt;
&lt;p&gt;下面我们把重点聚焦于两路变更的情况下子孙层级筛选合并的实现。&lt;/p&gt;
&lt;p&gt;从根节点的变更状态的角度分析（已排除完全新增的配置节点树），可以大致分为五种情况：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;base_ours 根节点状态&lt;/th&gt;
&lt;th&gt;base_theirs 根节点状态&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Add&lt;/td&gt;
&lt;td&gt;Add&lt;/td&gt;
&lt;td&gt;表示 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 没有某项配置项，而 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theris&lt;/code&gt; 新增了某项配置项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Conflict&lt;/td&gt;
&lt;td&gt;Conflict&lt;/td&gt;
&lt;td&gt;表示 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 存在某项配置项，&lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 也存在该项配置项但是值与 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 不同，&lt;code class=&quot;language-text&quot;&gt;theris&lt;/code&gt; 也存在该项配置项但是值与 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 也不同（未必与 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 相同/不同）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Conflict&lt;/td&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;td&gt;表示 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 存在某项配置项，&lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 也存在该项配置项但是值与 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 不同，而 &lt;code class=&quot;language-text&quot;&gt;theris&lt;/code&gt; 则不存在该项配置项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;td&gt;Conflict&lt;/td&gt;
&lt;td&gt;表示 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 存在某项配置项，&lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 不存在该项配置项，而 &lt;code class=&quot;language-text&quot;&gt;theris&lt;/code&gt; 存在该项配置项且值与 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 不同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;td&gt;表示 base 存在某项配置项，&lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theris&lt;/code&gt; 均不存在该配置项&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们以一个简单的代码示例说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-merge-code-demo.jpg&quot; alt=&quot;三路合并配置代码示例&quot;&gt;&lt;/p&gt;
&lt;p&gt;结合上文提及五种两两比对存在变更状态时的情况，并结合代码示例得出以下结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;color&lt;/code&gt; 对应第一种情况，&lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 没有该配置项，而 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 则有&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;width&lt;/code&gt; 对应第二种情况，&lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 有该配置项，而 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 同样有该配置项，但是 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 的值存在差异&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;height&lt;/code&gt; 同样对应第二种情况，与 &lt;code class=&quot;language-text&quot;&gt;width&lt;/code&gt; 配置项不同的是，&lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 的值严格相等&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;translateX&lt;/code&gt; 对应第三种情况，&lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 有该配置，且值冲突，而 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 则删除了该配置项&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;translateX&lt;/code&gt; 对应第四种情况，&lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 有该配置，且值冲突，而 &lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 则删除了该配置项&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;line-height&lt;/code&gt; 对应第五种情况，仅 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 存在该配置项，&lt;code class=&quot;language-text&quot;&gt;ours&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;theirs&lt;/code&gt; 均删除了该配置项&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里提及的新增或删除字段只为覆盖更完整的功能，实际的可视化配置业务中，因为组件的配置项基本固定且均提供了默认值，所以出现新增或删除字段的情况较少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后基于 &lt;code class=&quot;language-text&quot;&gt;base&lt;/code&gt; 进行 diff 后得出如下两份 JSON Schema 结构差异化数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-between-base-and-ours.jpg&quot; alt=&quot;diff-between-base-and-ours&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-between-base-and-theirs.jpg&quot; alt=&quot;diff-between-base-and-theirs&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于三路合并的策略，当三路值均不同时会保留差异让用户手动解决，当变更两路值相同或新增时则保留相同值，最后合并后得出新的 JSON Schema 配置数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/diff-tool-merge-base-ours-and-theirs.jpeg&quot; alt=&quot;Merge base and ours and theirs&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Revert 功能实现&lt;/h2&gt;
&lt;p&gt;最终通过自动合并和手动解决冲突，完整的配置数据应该所有节点都表示为相等状态。通过对返还的 JSON Schema 结构的数据递归还原，自动新建页面即完成整个批量更新页面的功能。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/longintchar/article/details/83049840&quot;&gt;三路合并 Git 学习笔记 17&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Vue 响应式系统实现探究]]></title><description><![CDATA[对 Vue 的响应式原理的实现分析似乎已经是前端界烂大街的话题，尽管如此，在对 Vue 源码研究了一周之后还是想尝试用自己的语言把整个实现原理记录下来。 这份研究不会对源码作逐行解读，只会对响应式系统的流程中 Vue…]]></description><link>http://mrsingsing.com/analysis-of-vue-responsive-systrm/</link><guid isPermaLink="false">http://mrsingsing.com/analysis-of-vue-responsive-systrm/</guid><pubDate>Thu, 04 Jul 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;对 Vue 的响应式原理的实现分析似乎已经是前端界烂大街的话题，尽管如此，在对 Vue 源码研究了一周之后还是想尝试用自己的语言把整个实现原理记录下来。&lt;/p&gt;
&lt;p&gt;这份研究&lt;strong&gt;不会对源码作逐行解读&lt;/strong&gt;，只会对响应式系统的流程中 Vue 对不同情况的处理方式以及数据的流向叙述清楚。&lt;/p&gt;
&lt;p&gt;开局借用 &lt;a href=&quot;https://github.com/ustbhuangyi&quot;&gt;ustbhuangyi&lt;/a&gt; 的一张图，对整个响应式系统有个宏观的概念。&lt;/p&gt;
&lt;p&gt;Vue 的响应式原理的核心就是观察这些数据，包括 data、props、computed 和 watch 的变化，当这些数据发生变化以后，能通知到对应的观察者（Watcher）以实现相关的逻辑，从而驱动视图的更新。整个响应式原理最核心的实现就是 Dep 类（语义为依赖 Dependency），这个类实际上是连接&lt;strong&gt;数据对象&lt;/strong&gt;与&lt;strong&gt;观察者&lt;/strong&gt;的桥梁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/vue-reactive-workflow.png&quot; alt=&quot;Vue Reactive&quot;&gt;&lt;/p&gt;
&lt;h2&gt;双向绑定&lt;/h2&gt;
&lt;p&gt;在 Vue 初始化阶段，会对传入构造函数的配置对象根据不同的选项作相关的处理。&lt;/p&gt;
&lt;p&gt;对于 data 和 props 而言，Vue 会通过 observe 和 defineReactive 等一系列的操作把 data 和 props 的每个属性变成响应式属性。&lt;/p&gt;
&lt;p&gt;在初始化 data 过程中，data 数据对象经由 observe 以参数形式传入 Observer 类的构造函数。在实例化过程中，Observer 会根据 data 的数据类型执行相关的操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 data 为&lt;strong&gt;数组类型&lt;/strong&gt;，Observer 会改写该数组原型中的变异方法（Mutation Method），包括 push、pop、shift、unshift、splice、sort 和 revers 共七个方法，这么做的目的是解决使用这些方法的原生实现会无法监测数据的变化的问题。随后，会遍历数组成员并逐个执行 observe 函数，这样就实现了通过递归的方式监测多维数组中的每个成员的数据变化。&lt;/li&gt;
&lt;li&gt;若 data 或递归数组成员为&lt;strong&gt;对象类型&lt;/strong&gt;，则会遍历并调用 defineReactive 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在初始化 props 时，经过 vm 实例键名的重名校验后，同样也是遍历调用 &lt;a href=&quot;https://github.com/vuejs/vue/blob/3b8925bc7973bb71b33374281db10a945ca9854e/src/core/observer/index.js#L132-L194&quot;&gt;defineReactive&lt;/a&gt; 函数。&lt;/p&gt;
&lt;p&gt;defineReactive 函数是对数据进行双向绑定（或称为响应式化）的核心。&lt;/p&gt;
&lt;p&gt;defineReactive 函数内部先实例化一个 &lt;a href=&quot;https://github.com/vuejs/vue/blob/3b8925bc79/src/core/observer/dep.js#L9-L50&quot;&gt;Dep&lt;/a&gt; 类，该类的建立是搭建起数据与 Watcher 的桥梁，同时也作为收集和存储 Watcher 的容器。随后，通过 Object.defineProperty 方法改写监测的数据字段的 get 函数和 set 函数。当我们访问监测的数据字段的时候，会触发 get 函数，get 函数内部和 set 函数内部都引用了在上层作用域中对 Dep 类实例化的常量 dep 实例对象。这里巧妙地运用了闭包的原理，以确保每个数据字段在访问和修改时都引用着属于自己的 dep 常量。get 函数会执行 dep 的 depend 方法用于&lt;span style=&quot;color:red;font-weight:bold&quot;&gt;收集依赖&lt;/span&gt;，这些依赖是当前正在计算的 Watcher，并最终经由 watcher 的 addDep 和 dep 的 addSub 添加到 dep 实例中的 subs 数组中（subs 意为 Subscriber 订阅者，该数组可以理解为依赖收集的存储容器）。而当修改数据（执行 set 函数）的时候，会触发 dep 的 notify 方法遍历 subs 数组中的依赖（也就是 watcher 实例）并调用它们原型上的 update 方法和 run 方法，最终通知这些订阅者执行&lt;span style=&quot;color:red;font-weight:bold&quot;&gt;派发更新&lt;/span&gt;的逻辑。这两个函数背后的执行路径在 dep 实例和 watcher 实例之间穿梭，这样实现的目的从源码分析来看，是为了区分不同的 Watcher（有 renderWatcher、computedWatcher 和 userWatcher，后面会提及）以及作相应的性能优化（譬如避免重复收集依赖或基于组件层级作缓存处理等）。&lt;/p&gt;
&lt;p&gt;总结 get 函数和 set 函数的触发时机，以及其职能功用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get 函数在&lt;strong&gt;访问&lt;/strong&gt;数据字段时触发，其主要职能是&lt;strong&gt;获取监测数据字段的值&lt;/strong&gt;并触发 Watcher 的&lt;strong&gt;依赖收集&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;set 函数在对数据字段&lt;strong&gt;修改&lt;/strong&gt;时触发，主要职责是&lt;strong&gt;对新的赋值进行响应式化&lt;/strong&gt;以及向 Watcher &lt;strong&gt;派发更新&lt;/strong&gt;，从而触发视图的重渲染。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;谈到这里肯定会有个疑问， get 函数所收集的依赖具体是什么？依赖是如何被收集的？set 函数是如何通知所有的 Watcher 更新的？派发更新的过程究竟做了什么？这些疑问都在下节揭晓。&lt;/p&gt;
&lt;h2&gt;渲染函数&lt;/h2&gt;
&lt;p&gt;在谈及依赖的追踪和触发前，我们有必要先了解 &lt;strong&gt;「依赖」&lt;/strong&gt; 这个那么虚的名词用 JavaScript 语言怎么描述。&lt;/p&gt;
&lt;p&gt;谈及双向数据绑定，这里所指的双向指的就是 Data 到 View 以及 View 到 Data 的结合。体现在我们的代码中，就是 Vue 的配置选项即为 Data 的储存容器，而 template 即为概念上的 View。我们知道浏览器在读取 JavaScript 脚本文件后必然经历 DOM 操作方可将相关数据渲染到 DOM 树中，比如使用字符串模版 innerHTML 或通过 appendChild、insertBefore 等 DOM 节点操作插入。&lt;/p&gt;
&lt;p&gt;在 Vue 中，模版 template 会经由 Compiler 被编译成渲染函数（Render Function），以下以直观的感受体验模版和渲染函数的表现形式。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;{{name}}&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 编译生成的渲染函数是一个匿名函数&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;anonymous&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;_c&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;div&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; attrs&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;_v&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;\n      &quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;s_&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;\n    &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经编译生成后的渲染函数会被挂载至对应 vm 组件实例的 &lt;code class=&quot;language-text&quot;&gt;$options.render&lt;/code&gt; 属性下。&lt;/p&gt;
&lt;p&gt;这里也解开了绑定的数据字段是如何和在哪里触发 getter 和 setter 的了。&lt;/p&gt;
&lt;p&gt;下面我们谈谈渲染函数与依赖追踪关系。&lt;/p&gt;
&lt;h2&gt;追踪依赖及响应变化&lt;/h2&gt;
&lt;p&gt;在 Vue 创建过程中，渲染视图的入口为 &lt;code class=&quot;language-text&quot;&gt;_init&lt;/code&gt; 函数中执行 vm 实例对象的 &lt;code class=&quot;language-text&quot;&gt;$mount&lt;/code&gt; 函数。对于每个组件而言，它都会执行组件的 &lt;code class=&quot;language-text&quot;&gt;$mount&lt;/code&gt; 方法，而不同编译版本的 &lt;code class=&quot;language-text&quot;&gt;$mount&lt;/code&gt; 执行的落脚点都是 mountComponent 函数。&lt;/p&gt;
&lt;p&gt;mountComponent 函数内部定义了一个 &lt;a href=&quot;https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L169-L192&quot;&gt;updateComponent&lt;/a&gt; 函数，而 updateComponent 函数的内部以 &lt;code class=&quot;language-text&quot;&gt;vm._render()&lt;/code&gt; 函数的返回值作为第一个参数调用 &lt;code class=&quot;language-text&quot;&gt;vm._update()&lt;/code&gt; 函数。此处我们只需简单地认为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;vm._render&lt;/code&gt; 函数的作用就是根据渲染函数（&lt;code class=&quot;language-text&quot;&gt;vm.$options.render&lt;/code&gt;）返回生成的虚拟节点&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;vm._update&lt;/code&gt; 函数的作用就是把 &lt;code class=&quot;language-text&quot;&gt;vm._render&lt;/code&gt; 函数生成的虚拟节点渲染成真正的 DOM 节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，对于 updateComponent 而言，我们可以把它理解为把虚拟 DOM 转化为真实 DOM 的过程。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L141-L213&quot;&gt;mountComponet&lt;/a&gt; 函数内部除了定义从虚拟 DOM 到真实 DOM 的执行函数外，还把 updateComponent 作为第一参数传入实例化的 Watcher 中。&lt;/p&gt;
&lt;p&gt;此时的 &lt;a href=&quot;https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L197-L203&quot;&gt;Watcher 实例对象&lt;/a&gt;被称为 render watcher（亦即&lt;span style=&quot;color:red;font-weight:bold&quot;&gt;渲染函数的观察者&lt;/span&gt;）。而实例化过程中 Watcher 会对 updateComponent 函数求值，而 updateComponent 函数的执行会间接触发渲染函数（&lt;code class=&quot;language-text&quot;&gt;vm.$options.render&lt;/code&gt;）的执行，而渲染函数的执行则会触发数据字段（包括 data、props 或 computed 等配置选项对象的子孙属性）的 get 拦截器函数，进而将该 render watcher 收集到依赖容器内，也就 dep 实例对象中的 subs 数组中，从而实现&lt;strong&gt;依赖收集&lt;/strong&gt;。这个 dep 实例对象属于数据字段自身所持有，这样当我们尝试修改相应数据字段的值的时候，程序会触发数据字段的 set 拦截器函数里的 dep.notify，从而触发 render watcher 的 update，然后执行其 run 方法，执行过程最终会调用 updateComponent 方法，该方法会重新进行视图渲染。这样触发 set 拦截函数并通过一系列操作后更新视图的过程称为&lt;strong&gt;派发更新&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;追踪依赖示意流程图：&lt;/p&gt;
&lt;p&gt;由于 mountComponent 作为数据更新视图的函数，那么肯定是频繁调用的，换言之函数内部会不断重复实例化 Watcher，但实际上对于数据表达式的依赖追踪不必重复执行该流程。在 Watcher 实例内部通过唯一标识区分 watcher 实例，并以标识集合作为区分依据，避免了&lt;strong&gt;一次求值过程中收集重复依赖&lt;/strong&gt;以及&lt;strong&gt;多次求值收集重复依赖&lt;/strong&gt;两类问题。&lt;/p&gt;
&lt;h2&gt;计算属性&lt;/h2&gt;
&lt;p&gt;计算属性 computed 在 &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L169-L208&quot;&gt;initComputed&lt;/a&gt; 函数中构建。&lt;/p&gt;
&lt;p&gt;对于 computed 计算属性而言，实际上会在内部创建一个 computed watcher，每个 computed watcher 会持有一个 Dep 实例，当我们访问 computed 属性的时候，会调用 computed watcher 的 &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js#L210-L213&quot;&gt;evaluate&lt;/a&gt; 方法，这时候会触发其持有的 depend 方法用于收集依赖，同时也会收集到正在计算的 watcher，然后把它计算的 watcher 作为 Dep 的 Subscriber 订阅者收集起来，收集起来的作用就是当计算属性所依赖的值发生变化以后，会触发 computed watcher 重新计算，如果重新计算过程中计算结果变了也会调用 dep 的 notify 方法，然后通知订阅 computed 的订阅者触发相关的更新。这类 watcher 有个特点：当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性，这类 watcher 的 expression 是计算属性的中的属性名。&lt;/p&gt;
&lt;h2&gt;侦听属性&lt;/h2&gt;
&lt;p&gt;侦听属性 watch 在 &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L303-L317&quot;&gt;Vue.prototype.$watch&lt;/a&gt; 函数中构建。&lt;/p&gt;
&lt;p&gt;对于配置的 watch 数据对象而言，会实现基于 Watcher 的封装并创建 user watcher，可以理解为用户的 watcher，也就是由开发者自定义的回调函数，它可以观察 data 的变化，也可以观察 computed 的变化。当这些数据发生变化以后，会通知这个该 watch 数据对象的 Dep 实例然后调用这个 Dep 实例去遍历所有 user watchers，然后调用它们的 update 方法，然后求值发生新旧值变化就会触发 run 执行用户定义的回调函数（user callback）。&lt;/p&gt;
&lt;h2&gt;收获&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对 Vue 处理配置选项的数据字段与视图数据绑定的工作流程以及响应式系统的工作流程有完整的认识，加深了解相关配置或 API 的 What 和 Why，定位框架相关问题的时候更快速&lt;/li&gt;
&lt;li&gt;学会了很多编码层面的优化方式，根据流程避开非最佳的写法，让框架以最短路径完成双向绑定的工作，尽管以现时 JavaScript 引擎的性能而言，这些优化显得微不足道，但追求极致的代码书写应该是每个工程师应该具备的素养&lt;/li&gt;
&lt;li&gt;在了解甚至读懂源码实现原理的前提下，若遇到技术选型或缺陷治理等情况，与他人协商的沟通成本能大幅下降，最重要的是暗中观察业界大佬在讨论问题时起码不会再一脸懵逼。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Todo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Vue 初始化流程：Vue API 挂载流程以及实现原理，读懂这部分源码应该对业务实践帮助很大&lt;/li&gt;
&lt;li&gt;模版编译，结合编译相关 Babel 以及 JSX 编译实现，探索前端编译实现方式&lt;/li&gt;
&lt;li&gt;研究 Virtual DOM 的算法与实现，并与 React 实现的 Virtual DOM 作比较&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/&quot;&gt;Vue 官方中文网&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/reactivity.html&quot;&gt;深入响应式原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/render-function.html&quot;&gt;渲染函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://hcysun.me/vue-design/&quot;&gt;Vue 技术内幕&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://hcysun.me/vue-design/art/7vue-reactive.html&quot;&gt;揭开数据响应系统的面纱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hcysun.me/vue-design/art/8vue-reactive-dep-watch.html&quot;&gt;渲染函数的观察者与进阶的数据响应系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ustbhuangyi.github.io/vue-analysis/reactive/&quot;&gt;Vue 技术揭秘 - 深入响应式原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21706165?utm_source=wechat_session&amp;#x26;utm_medium=social&amp;#x26;utm_oi=58000878338048&quot;&gt;Vue 双向数据绑定原理分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[前端相关业务性能优化技术手段总结]]></title><description><![CDATA[…]]></description><link>http://mrsingsing.com/means-for-performance-optimization/</link><guid isPermaLink="false">http://mrsingsing.com/means-for-performance-optimization/</guid><pubDate>Sun, 19 May 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;技术社区中其实已经有较多的关于前端性能优化的相关文章，看了多篇之后总是觉得内容还有很多遗漏或写得不够完美，尽管还没接手过流量特别大的网站应用项目，但是本人认为日常项目中也需要尽可能地进行性能优化的工作，因为前端工程师的工作很大程度上可以描述为“用尽量少的代价为用户提供效率尽可能高、功能尽可能多、体验尽可能好的网页应用”，而性能优化很大程度上就是实现“尽可能少的代价”、“效率尽可能高”以及“体验尽可能好”。&lt;/p&gt;
&lt;p&gt;因此，此文会根据网络请求到网页呈现的完整流程，针对性地提出相关阶段供开发决策者考虑采取的优化方案，因此本文更像是性能优化方案的决策树，而非标准方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络链路层面&lt;/li&gt;
&lt;li&gt;服务端层面&lt;/li&gt;
&lt;li&gt;客户端渲染层面&lt;/li&gt;
&lt;li&gt;编码层面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;网络请求到网页呈现的大致流程&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;发送网络请求 =&amp;gt; 网络链路 =&amp;gt; 返回资源(服务端) =&amp;gt; 渲染资源(客户端)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;关键渲染路径&lt;/h1&gt;
&lt;p&gt;在提出各层次的优化方案之前，有必要了解一下性能优化方案实际上解决了哪些性能问题以及解决这些问题的核心归结点。&lt;/p&gt;
&lt;p&gt;以下部分关于优化关键渲染路径的建议摘录自 Google 开发者文档：
&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path&quot;&gt;📖 Optimizing the Critical Rendering Path&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键资源的数量&lt;/li&gt;
&lt;li&gt;关键路径长度&lt;/li&gt;
&lt;li&gt;关键字节的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。&lt;/p&gt;
&lt;p&gt;同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。&lt;/p&gt;
&lt;p&gt;最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化关键渲染路径的常规步骤如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对关键路径进行分析和特性描述：资源数、字节数、长度&lt;/li&gt;
&lt;li&gt;最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等&lt;/li&gt;
&lt;li&gt;优化关键字节数以缩短下载时间（往返次数）&lt;/li&gt;
&lt;li&gt;优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;网络链路层面&lt;/h1&gt;
&lt;p&gt;网络链路作为网络资源和数据的传输通道，充分利用网络技术手段能有效地减少网页资源响应的速度、提升网页资源传输速度以及避免重复传输导致的资源浪费等问题。&lt;/p&gt;
&lt;h2&gt;传输策略&lt;/h2&gt;
&lt;h3&gt;DNS 查询&lt;/h3&gt;
&lt;p&gt;DNS 域名解析协议简单来就说负责将域名 URL 转化为服务器主机 IP。了解更多 &lt;a href=&quot;https://tsejx.github.io/JavaScript-Guidebook/computer-networks/dns.html&quot;&gt;DNS 域名解析协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DNS 查询能从两方面进行优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减少 DNS 查询次数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DNS 预解析&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过在文档中使用值为 &lt;code class=&quot;language-text&quot;&gt;http-equiv&lt;/code&gt; 的 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 标签打开 DNS 预解析：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;meta&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;http-equiv&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;x-dns-prefetch-control&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;on&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;code class=&quot;language-text&quot;&gt;rel&lt;/code&gt; 属性值为 &lt;code class=&quot;language-text&quot;&gt;dns-prefetch&lt;/code&gt; 的 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;link&amp;gt;&lt;/code&gt; 标签对特定域名进行预读取&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&apos;dns-prefetch&quot; href=&quot;//host_name_to_prefetch.com&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching&quot;&gt;MDN：X-DNS-Prefetch-Control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.chromium.org/developers/design-documents/dns-prefetching&quot;&gt;DNS Prefetching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bitsup.blogspot.com/2008/11/dns-prefetching-for-firefox.html&quot;&gt;DNS Prefetching for Firefox&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;TCP 连接&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;持久化连接&lt;/strong&gt;：避免重复进行 TCP 的三次握手，HTTP/1.1 默认开启，HTTP/1.0 可以使用。&lt;/p&gt;
&lt;p&gt;Keep-Alive 不会永久保持连接，开发者可通过服务器配置限定时间。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;http&quot;&gt;&lt;pre class=&quot;language-http&quot;&gt;&lt;code class=&quot;language-http&quot;&gt;&lt;span class=&quot;token header-name keyword&quot;&gt;Connection:&lt;/span&gt; keep-alive&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;HTTP 请求&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;减少 HTTP 请求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过前端构建工具合并脚本和样式表&lt;/li&gt;
&lt;li&gt;CSS Sprites 精灵图&lt;/li&gt;
&lt;li&gt;图片使用 Base64 编码嵌入网页，减少图片外部载入的请求数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源分布式部署至不同域名&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：主流浏览器对相同域名的并发 HTTP 请求数限制在 4~8 个，当资源过多时，可以采用增加域名的方法增加 HTTP 请求的并发量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原理&lt;/strong&gt;：利用多个不同的域名可以保证这些域名能够同时加载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不同响应域名时间不一致&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免重定向&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URL 末尾应该添加 &lt;code class=&quot;language-text&quot;&gt;/&lt;/code&gt; 但未添加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消除不必要的请求字节&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cookie&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;压缩 Cookie 大小&lt;/li&gt;
&lt;li&gt;去除不必要的 Cookie&lt;/li&gt;
&lt;li&gt;注意设置 Cookie 的 domain 级别，如没必要，不要影响子域名&lt;/li&gt;
&lt;li&gt;设置合适的过期时间&lt;/li&gt;
&lt;li&gt;静态资源使用无 Cookie 域名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://tsejx.github.io/JavaScript-Guidebook/computer-networks/http/http2.html&quot;&gt;HTTP/2&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二进制分帧&lt;/li&gt;
&lt;li&gt;多路复用&lt;/li&gt;
&lt;li&gt;服务器推送&lt;/li&gt;
&lt;li&gt;头部压缩&lt;/li&gt;
&lt;li&gt;了解更多 [HTTP/2]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTTP/3&quot;&gt;HTTP/3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/&quot;&gt;前端性能优化 - 资源预加载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/creeperyang/blog/issues/23&quot;&gt;HTTP/2 简介和基于 HTTP/2 的 Web 优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;缓存策略&lt;/h2&gt;
&lt;p&gt;制定有效的缓存策略，很大程度上能实现资源的重复利用及传输路径的优化，减少客户端对服务端的网络请求压力，减轻宽度流量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html&quot;&gt;HTTP 缓存&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;%5Bhttps://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%BC%BA%E7%BC%93%E5%AD%98%5D(https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%BC%BA%E7%BC%93%E5%AD%98)&quot;&gt;强缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Expires 绝对时间 &lt;code class=&quot;language-text&quot;&gt;Expires: Thu, 21 Jan 2017 23:59:59 GMT&lt;/code&gt; 服务器和客户端时间可能不一致&lt;/li&gt;
&lt;li&gt;Cache-Control 相对时间 &lt;code class=&quot;language-text&quot;&gt;Cache-Control: max-age=3600&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;%5Bhttps://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%5D(https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98)&quot;&gt;协商缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Last-Modified / If-Modified-Since 绝对时间 &lt;code class=&quot;language-text&quot;&gt;Expires: Wed, 26 Jan 2017 00:35:11 GMT&lt;/code&gt; 资源上次修改的时间&lt;/li&gt;
&lt;li&gt;Etag / If-None-Match 随机生成的乱码值&lt;/li&gt;
&lt;li&gt;优先使用强缓存&lt;/li&gt;
&lt;li&gt;当资源文件发生变化时，通过更新页面中引用的资源路径，让浏览器放弃缓存，加载新资源&lt;/li&gt;
&lt;li&gt;通过 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//baike.baidu.com/view/10961371.htm&quot;&gt;数据摘要算法&lt;/a&gt; 精准到单个文件粒度的缓存控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://tsejx.github.io/JavaScript-Guidebook/computer-networks/cdn.html&quot;&gt;CDN 缓存&lt;/a&gt;： 将静态资源和动态网页分集群部署&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML 部署在自身的服务器上&lt;/li&gt;
&lt;li&gt;打包后的图片 / JavaScript 脚本文件 / CSS 样式文件等资源部署到 CDN 节点上，文件带上 Hash 值&lt;/li&gt;
&lt;li&gt;由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制&lt;/li&gt;
&lt;li&gt;CDN 没有 Cookie，使用 CDN 可以减少 Cookie&lt;/li&gt;
&lt;li&gt;CDN 会自动合并脚本文件等，减少请求数量&lt;/li&gt;
&lt;li&gt;但是，CDN 同时也增加了域名，增大了同时请求数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器缓存：&lt;/strong&gt;将不变的数据、页面缓存到&lt;strong&gt;内存&lt;/strong&gt;或&lt;strong&gt;远程存储&lt;/strong&gt;（如 Redis 等）上&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;浏览器缓存&lt;/strong&gt;: 通过设置请求的过期时间，将各种不常变的数据进行缓存，合理运用浏览器缓存，缩短数据的获取时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/cookie.html&quot;&gt;Cookie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/web-storage.html&quot;&gt;WebStorage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;LocalStorage&lt;/li&gt;
&lt;li&gt;SessionStorage&lt;/li&gt;
&lt;li&gt;IndexDB&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tsejx.github.io/JavaScript-Guidebook/html5-scripting-programming/offline-and-storage/service-worker.html&quot;&gt;ServiceWorker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;AppCache：采用 mainfest 文件进行缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/20790576&quot;&gt;大公司里怎样开发和部署前端代码？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fimququ.com%2Fpost%2Fenhance-security-for-ls-code.html&quot;&gt;使用 SRI 增强 LocalStorage 代码安全&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;服务端层面&lt;/h1&gt;
&lt;p&gt;由于本文只涉及前端性能优化，但为求流程完整，简单罗列与服务端相关的优化方案的常见手段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多域名资源加载&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;数据缓存&lt;/li&gt;
&lt;li&gt;反向代理&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;客户端层面&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;资源渲染数量/大小&lt;/li&gt;
&lt;li&gt;资源渲染路径&lt;/li&gt;
&lt;li&gt;用户体验&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;资源渲染数量/大小&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;压缩静态资源，清除无用代码&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tree Shaking 无用代码移除&lt;/li&gt;
&lt;li&gt;UglifyJs 混淆 / 压缩代码&lt;/li&gt;
&lt;li&gt;Code Spliting 代码分割（资源按需加载或并行加载）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开启 Gzip 压缩&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求头 &lt;code class=&quot;language-text&quot;&gt;Accept-Encoding: gzip, deflate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;响应头 &lt;code class=&quot;language-text&quot;&gt;Content-Encoding: gzip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Gzip 能够压缩任何文本类型的响应，包括 HTMl、XML 和 JSON&lt;/li&gt;
&lt;li&gt;已经压缩过的内容如图片、和 PDF 不要使用 Gzip，这些资源内容本身体积就小，再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且有增加文件体积的可能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多份编译文件按条件引入&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件&lt;/li&gt;
&lt;li&gt;可以利用 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;script type=&amp;quot;module&amp;quot;&amp;gt; / &amp;lt;script type=&amp;quot;module&amp;quot;&amp;gt;&lt;/code&gt;进行条件引入用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态 Polyfill&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只针对不支持的浏览器运行环境引入 Polyfill&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;图片优化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据业务场景，与 UI 探讨选择 &lt;strong&gt;合适质量，合适尺寸&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根据需求和平台，选择 &lt;strong&gt;合适格式&lt;/strong&gt;，例如非透明时可用 jpg；非苹果端，使用 webp&lt;/li&gt;
&lt;li&gt;小图片合成 &lt;strong&gt;雪碧图 CSS Sprite&lt;/strong&gt;，低于 5K 的图片可以转换成 B&lt;strong&gt;ase64&lt;/strong&gt; 内嵌&lt;/li&gt;
&lt;li&gt;合适场景下，使用 I&lt;strong&gt;confont&lt;/strong&gt; 或者 &lt;strong&gt;SVG&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;压缩 favicon.ico 并缓存&lt;/li&gt;
&lt;li&gt;使用 Blob 异步加载&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FRevillWeb%2Fimg-2&quot;&gt;img-2&lt;/a&gt; 代替 img 标签&lt;/li&gt;
&lt;li&gt;嵌入资源：Base64 嵌入资源（针对小的静态图片资源）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字体优化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器为了避免 FOUT（Flash Of Unstyled Text），会尽量等待字体加载完成后，再显示应用了该字体的内容。带来了 FOIT（Flash Of Invisible Text 问题），导致空白&lt;/li&gt;
&lt;li&gt;设置多字体，降级方法：使用默认字体&lt;/li&gt;
&lt;li&gt;异步加载字体文件：通过异步加载 CSS，即可避免字体阻塞渲染，还是会空白&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多媒体优化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;音视频&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;资源渲染路径&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优化加载顺序&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS 样式文件放在文档 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 标签中引入&lt;/li&gt;
&lt;li&gt;把样式表放在 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉&lt;/li&gt;
&lt;li&gt;JavaScript 脚本文件放在 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 标签底部引入&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原因&lt;/strong&gt;：加载脚本文件会对后续资源渲染造成阻塞&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方案&lt;/strong&gt;：制定合理的脚本文件加载策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态脚本加载（异步加载、延迟加载、按需加载）&lt;/li&gt;
&lt;li&gt;添加 &lt;code class=&quot;language-text&quot;&gt;defer&lt;/code&gt; 属性的脚本文件是在 HTML 解析完之后才会执行。如果是多个，按照加载的顺序依次执行&lt;/li&gt;
&lt;li&gt;添加 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt; 属性的脚本文件是在加载之后立即执行，如果 HTML 还没解析完，会阻塞 HTML 继续解析。如果是多个，执行顺序和加载顺序无关&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;影响首屏的，优先级很高的脚本文件也可以 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 首子节点引入，甚至利用 &lt;code class=&quot;language-text&quot;&gt;style&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;script&lt;/code&gt; 内联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源加载方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非关键性的文件尽可能的&lt;strong&gt;异步加载和延迟加载&lt;/strong&gt;，避免阻塞首页渲染&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源提示指令&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Preload&lt;/li&gt;
&lt;li&gt;Prefetch&lt;/li&gt;
&lt;li&gt;Preconnect&lt;/li&gt;
&lt;li&gt;Subresource&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步加载（预加载）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应&lt;/li&gt;
&lt;li&gt;预判用户的行为，提前加载所需要的资源，则可以快速地响应用户的操作，从而打造更好的用户体验。另一方面，通过提前发起网络请求，也可以减少由于网络过慢导致的用户等待时间。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Preload 规范 W3CPreload&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rel 明确告知浏览器启用 preload 功能&lt;/li&gt;
&lt;li&gt;as 明确需要预加载资源的类型，包括 JavaScript、Images、CSS、Media 等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;延迟加载（懒加载、按需加载）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面初始加载时将非绝对必须的资源延迟加载，从而提高页面的加载和响应速度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非首屏使用的数据、样式、脚本、图片等&lt;/li&gt;
&lt;li&gt;用户交互时才会显示的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实现方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟代理技术：真正加载的对象事先提供一个代理或者说占位符。最常见的场景是在图片的懒加载中，先用一种 loading 的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。&lt;/li&gt;
&lt;li&gt;惰性初始化技术：将代码初始化的时机推迟（特别是那些初始化消耗较大的资源）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选择时机：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滚动条监听：大型图片流场景，通过对用户滚动结束区域进行计算，从而只加载目标区域的资源，这样可以实现节流的目的&lt;/li&gt;
&lt;li&gt;事件回调：常用于需要用户交互的地方，如点击加载更多之类的，这些资源往往通过在用户交互的瞬间（如点击一个触发按钮），发起 AJAX 请求来获取资源。比较简单，在此不再赘述。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遵循渐进增强理念理念开发网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript&lt;/li&gt;
&lt;li&gt;将首屏以外的 HTML 放在不渲染的元素中，如隐藏的 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;，或者 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 属性为非执行脚本的 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源渲染&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免重排，减少重绘，避免白屏，或者交互过程中的卡顿&lt;/li&gt;
&lt;li&gt;通过 &lt;a href=&quot;https://csstriggers.com/&quot;&gt;CSS Trigger&lt;/a&gt; 查询哪些样式属性会触发重排与重绘&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少重排的方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;页面初始化&lt;/li&gt;
&lt;li&gt;减少对 DOM 元素内容改变（如：文本改变、图片被另一个同尺寸元素替代）&lt;/li&gt;
&lt;li&gt;减少对 DOM 元素尺寸改变（因为边距、填充、边框宽度、宽度、高度等属性改变）&lt;/li&gt;
&lt;li&gt;减少对 DOM 元素位置改变&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少对可见 DOM 元素的操作（如：增加、移动和删除）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多次 DOM 操作合并为一次处理&lt;/li&gt;
&lt;li&gt;大量操作时，可将 DOM 脱离文档流或者隐藏，待操作完成后再重新恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;减少旋转屏幕的操作&lt;/li&gt;
&lt;li&gt;减少改变浏览器窗口尺寸的操作&lt;/li&gt;
&lt;li&gt;减少设置元素 style 属性&lt;/li&gt;
&lt;li&gt;减少设置元素 class 属性&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过延迟访问布局信息避免重排版&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如 &lt;code class=&quot;language-text&quot;&gt;offsetWidth&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;offsetHeight&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;getComputedStyle&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;原因：浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;减少在 HTML 中缩放图片&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免对大部分页面进行重排版&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用绝对坐标定位页面动画的元素，使它位于页面布局流之外&lt;/li&gt;
&lt;li&gt;启动元素动画，当它扩大时，它临时覆盖部分页面&lt;/li&gt;
&lt;li&gt;当动画结束时，重新定位，从而只一次下移文档其他元素的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启 GPU 加速&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;transform&lt;/li&gt;
&lt;li&gt;opacity&lt;/li&gt;
&lt;li&gt;filter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/59b73ef75188253db70acdb5#heading-5&quot;&gt;前端性能优化之加载技术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5b5984b851882561da216311&quot;&gt;资源提示——什么是 Preload，Prefetch 和 Preconnect？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FGoogleChrome%2Fpreload-webpack-plugin&quot;&gt;preload-webpack-plugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2016%2F02%2Fpreload-what-is-it-good-for%2F&quot;&gt;Preload 技术细节&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;用户体验&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;谨慎控制好 Web 字体，一个大字体包足够让你功亏一篑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制字体包的加载时机&lt;/li&gt;
&lt;li&gt;如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分清轻重缓急&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重要的元素优先渲染&lt;/li&gt;
&lt;li&gt;视窗内的元素优先渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端渲染（SSR）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少首屏需要的数据量，剔除冗余数据和请求&lt;/li&gt;
&lt;li&gt;控制好缓存，对数据/页面进行合理的缓存&lt;/li&gt;
&lt;li&gt;页面的请求使用流的形式进行传递&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化用户感知&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用一些动画 &lt;strong&gt;过渡效果&lt;/strong&gt;，能有效减少用户对卡顿的感知&lt;/li&gt;
&lt;li&gt;尽可能利用 &lt;strong&gt;骨架屏（Skeleton）/ Loading&lt;/strong&gt; 等减少用户对白屏的感知&lt;/li&gt;
&lt;li&gt;动画帧数尽量保证在 &lt;strong&gt;30 帧&lt;/strong&gt; 以上，低帧数、卡顿的动画宁愿不要&lt;/li&gt;
&lt;li&gt;JavaScript 执行时间避免超过 100ms ，超过的话就需要做：&lt;/li&gt;
&lt;li&gt;寻找可缓存的点&lt;/li&gt;
&lt;li&gt;任务的分割异步或 web worker 执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;编码层面&lt;/h1&gt;
&lt;p&gt;编码优化，指的就是在代码编写时的，通过一些 &lt;strong&gt;最佳实践&lt;/strong&gt;，提升代码的执行性能。通常这并不会带来非常大的收益，但这属于&lt;strong&gt;程序员的自我修养&lt;/strong&gt;，而且这也是面试中经常被问到的一个方面，考察自我管理与细节的处理。&lt;/p&gt;
&lt;h2&gt;JavaScript 优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据读取&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过作用域链 / 原型链读取变量或方法时，需要更多的耗时，且越长越慢&lt;/li&gt;
&lt;li&gt;对象嵌套越深，读取值也越慢&lt;/li&gt;
&lt;li&gt;最佳实践：&lt;/li&gt;
&lt;li&gt;尽量在局部作用域中进行 &lt;strong&gt;变量缓存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;避免嵌套过深的数据结构，&lt;strong&gt;数据扁平化&lt;/strong&gt; 有利于数据的读取和维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;循环&lt;/strong&gt;：循环通常是编码性能的关键点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码的性能问题会在循环中被指数倍放大&lt;/li&gt;
&lt;li&gt;最佳实践:&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能 减少循环次数；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少遍历的数据量&lt;/li&gt;
&lt;li&gt;完成目的后马上结束循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存&lt;/li&gt;
&lt;li&gt;JavaScript 中使用 &lt;strong&gt;倒序循环&lt;/strong&gt; 会略微提升性能&lt;/li&gt;
&lt;li&gt;尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;条件流程性能&lt;/strong&gt;：Map / Object &gt; switch &gt; if-else&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模块化&lt;/strong&gt;：尝试使用 &lt;code class=&quot;language-text&quot;&gt;import()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;DOM 优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;减少 DOM 的层级，可以减少渲染引擎工作过程中的计算量&lt;/li&gt;
&lt;li&gt;减少访问 DOM 的次数，如需多次，将 DOM 缓存于变量中&lt;/li&gt;
&lt;li&gt;使用事件委托，避免大量的事件绑定&lt;/li&gt;
&lt;li&gt;使用 &lt;code class=&quot;language-text&quot;&gt;requestAnimationFrame&lt;/code&gt; 来实现视觉变化：一般来说我们会使用 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt; 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CSS 优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;层级扁平&lt;/strong&gt;，避免过于多层级的选择器嵌套&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定的选择器&lt;/strong&gt;：好过一层一层查找：&lt;code class=&quot;language-text&quot;&gt;.xxx-child-text{}&lt;/code&gt; 优于 &lt;code class=&quot;language-text&quot;&gt;.xxx .child .text{}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;减少使用通配符与属性选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择器越复杂，匹配用的时间越多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少不必要的多余属性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;动画属性&lt;/strong&gt; 实现动画，动画时脱离文档流，开启硬件加速，优先使用 CSS 动画&lt;/li&gt;
&lt;li&gt;使用 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;link&amp;gt;&lt;/code&gt; 替代原生 @import&lt;/li&gt;
&lt;li&gt;避免使用表达式，例如 &lt;code class=&quot;language-text&quot;&gt;font-color: expression((new Date()).getHours()%3?&amp;quot;#FFF&amp;quot;:&amp;quot;#AAA&amp;quot;)&lt;/code&gt; 这个表达式会持续地在页面上计算样式，影响页面性能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;HTML 优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;写对文档类型声明 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt; 这能确保浏览器按照最佳的相关规范进行渲染&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少 DOM 数量&lt;/strong&gt;，避免不必要的节点或嵌套；&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免空的 &lt;code class=&quot;language-text&quot;&gt;src&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;href&lt;/code&gt;：当 &lt;code class=&quot;language-text&quot;&gt;src&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;href&lt;/code&gt; 为空时，浏览器会默认填充链接，并将页面的内容加载进来作为它们的值，具体规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IE 向&lt;strong&gt;页面所在的目录&lt;/strong&gt;发送请求&lt;/li&gt;
&lt;li&gt;Safari、Chrome、Firefox 向页面本身 URL 发送请求&lt;/li&gt;
&lt;li&gt;Opera 不执行任何操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图片提前 &lt;strong&gt;指定宽高&lt;/strong&gt; 或者 &lt;strong&gt;脱离文档流&lt;/strong&gt;，能有效减少因图片加载导致的页面回流&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语义化标签&lt;/strong&gt; 有利于 SEO 与浏览器的解析时间&lt;/li&gt;
&lt;li&gt;减少使用 table 进行布局，避免使用 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;br/&amp;gt;&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;hr/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;性能优化方案清单&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;🧾 &lt;a href=&quot;https://juejin.im/post/5a966bd16fb9a0635172a50a&quot;&gt;2018 前端性能优化清单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🧾 &lt;a href=&quot;https://github.com/berwin/Blog/issues/23&quot;&gt;嗨，送你一张 Web 性能优化地图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🧾 &lt;a href=&quot;https://segmentfault.com/a/1190000018263418?utm_medium=hao.caibaojian.com&amp;#x26;utm_source=hao.caibaojian.com&amp;#x26;share_user=1030000000178452&quot;&gt;Web 性能优化总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🧾 &lt;a href=&quot;https://juejin.im/post/5b025d856fb9a07aa0484e54&quot;&gt;大前端性能总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🧾 &lt;a href=&quot;https://juejin.im/post/5b6133a351882519d346853f&quot;&gt;CSS 性能优化的 8 个技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🧾 &lt;a href=&quot;https://juejin.im/post/5b7e1f81f265da436a075db4&quot;&gt;精读 《高效 JavaScript》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🧾 &lt;a href=&quot;https://juejin.im/post/5c011e0c5188252ea66afdfa&quot;&gt;Web 性能优化清单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🗃 &lt;a href=&quot;https://github.com/barretlee/performance-column/milestone/1&quot;&gt;性能相关基础知识点研究&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🗃 &lt;a href=&quot;https://github.com/liangsenzhi/awesome-wpo-chinese&quot;&gt;前端性能优化资源列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🗃 &lt;a href=&quot;https://github.com/davidsonfellipe/awesome-wpo&quot;&gt;awesome-wpo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🗃 &lt;a href=&quot;https://github.com/drublic/checklist&quot;&gt;A Frontend Checklist for Websites&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优化方向&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;🎡 &lt;a href=&quot;https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/&quot;&gt;浏览器的工作原理：新式网络浏览器幕后揭秘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🎡 &lt;a href=&quot;http://velocity.oreilly.com.cn/2013/ppts/16_ms_optimization--web_front-end_performance_optimization.pdf&quot;&gt;16 毫秒的优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;🎡 &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution&quot;&gt;Optimize JavaScript Execution 优化 JavaScript 执行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[AntDesign 组件化开发探索之表单业务设计实践总结]]></title><description><![CDATA[…]]></description><link>http://mrsingsing.com/form-business-design-pratice-in-antd/</link><guid isPermaLink="false">http://mrsingsing.com/form-business-design-pratice-in-antd/</guid><pubDate>Fri, 05 Apr 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;需求分析&lt;/h2&gt;
&lt;p&gt;最近接到一块关于促销活动功能的需求，除了常规的数个日志类型和筛选统计类型展示的列表之外，还需要完成关于促销活动的创建与编辑页面的组件化设计。&lt;/p&gt;
&lt;p&gt;活动的创建页面与编辑页面是一个分步表单，分别为活动的基本信息、领取条件以及使用条件三个部分。&lt;/p&gt;
&lt;p&gt;按照往常的开发习惯，会把这单个页面的分步表单的三个部分都写在一个组件内，但是这样处理明显是不合理的，因为按照这几个部分的表单需求来看，至少也需要上千行的代码实现，无论从代码可读性或者后期维护的便利性来说，都是不可取的。所以如何合理地设计整个表单页对整个功能的实现以及后期需求迭代的便捷性至关重要。&lt;/p&gt;
&lt;p&gt;通过细分可能涉及到的逻辑难点做了以下分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶层组件主要负责各个步骤表单的渲染分发器，以及整个分步表单提交前相关数据处理，分发器通过设定标识变量控制用户可视部分表单渲染，数据处理则需要根据接口需求的数据结构进行转换&lt;/li&gt;
&lt;li&gt;可视表单在进入下一个步骤之前需要对当前步骤表单信息进行信息校验&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据 antd 表单组件的设计原则封装复合表单项（单选+多选+时间选择输入框）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复合表单组件支持复用，并提供一键自动填充功能&lt;/li&gt;
&lt;li&gt;动态增减输入框控件并支持控件间的严格规则校验&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;兼容新建页面和编辑页面，主要区别在于编辑页面需要获取并设置表单默认值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;分步表单实践分析&lt;/h2&gt;
&lt;h3&gt;分步表单组织结构&lt;/h3&gt;
&lt;p&gt;整个分步表单页面从 UI 上划分大体上分为三个部分：步骤进度条、对应的表单项以及切换页面的按钮组。&lt;/p&gt;
&lt;p&gt;根据 &lt;code class=&quot;language-text&quot;&gt;antd&lt;/code&gt; 组件库的表单设计原则，如果需要 Form 组件自带的收集校验功能，需要使用 &lt;code class=&quot;language-text&quot;&gt;Form.create()&lt;/code&gt; 对自定义的组件进行包装，而且每个需要收集的值还需要 &lt;code class=&quot;language-text&quot;&gt;getFieldDecorator&lt;/code&gt; 进行注册。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Form.create()&lt;/code&gt; 用于创建一个具有注册、收集、校验功能的实例。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Basic&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Component&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Form&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Form.Item&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token function&quot;&gt;getFieldDecorator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;expiration&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            initialValue&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; fields&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expiration &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; fields&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expiration &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            validateFirst&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            rules&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
              &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; required&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; message&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;必填&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;SuffixInput&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;天&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;placeholder&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;请输入整数&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Form.Item&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Form&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
  }
}

Form.create()(Basic)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个页面的数据储存方式决定了整个分步表单的组织结构，也决定了编写业务逻辑时对数据流的处理方法。因此我对两种功能方案进行了对比。&lt;/p&gt;
&lt;h3&gt;数据存储方案&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;顶层组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔层传送：&lt;/strong&gt; 如果在顶层组件包装，那么就需要把 Form 内部创建的实例以及一些修饰器 &lt;code class=&quot;language-text&quot;&gt;getFieldDecorator&lt;/code&gt;、校验表单值 &lt;code class=&quot;language-text&quot;&gt;validateFields&lt;/code&gt; 等方法通过 Props 再传递给各个步骤组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步卸载：&lt;/strong&gt; 在对当前步骤表单填充完成并切换步骤后后，上个步骤的组件会从页面卸载，最终表单提交时候会无法获取之前已经填充的表单的值。因为这些步骤的组件卸载后存储表单值的实例也会同时卸载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各个步骤组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需同步数据：&lt;/strong&gt; 如果在顶层组件下的各个步骤组件进行包装，那么就需要在切换下个步骤前对表单值进行验证，验证失败会进行拦截，而验证成功则会将数据映射到顶层组件的 State 中，该分步骤组件以及 Form 创建的表单数据存储实例均会一并卸载。若页面再切换到其他步骤的页面时，需要从 Props 获取该步骤页面的表单值，再通过 &lt;code class=&quot;language-text&quot;&gt;initialValue&lt;/code&gt; 映射到 Form 组件内部生成的实例中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能明确：&lt;/strong&gt; 这样设计的好处是将各个分步的表单分为单独的表单看待，功能分工更加明确，无论从功能实现还是后期维护上只需要对该组件内的业务逻辑进行修改即可，不用兼容顶层组件的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;兼容页面：&lt;/strong&gt; 更重要的是，顶层组件对各个步骤的表单域值进行分发，再通过 &lt;code class=&quot;language-text&quot;&gt;initialValue&lt;/code&gt; 设置表单默认值的方式在编辑页面的应用上会更加合理。因此最终采用对各个步骤组件进行封装的方法。&lt;/p&gt;
&lt;h3&gt;同步数据的时机&lt;/h3&gt;
&lt;p&gt;尽管已经决定在各个步骤组件中进行 Form 组件包装，但是另一方面需要考虑当用户填充功能表单时数据是在切换页面时统一校验再存储在上级组件，还是实时存储呢。&lt;/p&gt;
&lt;p&gt;如果是采用实时存储的方案的话，可以使用 AntDesign 提供的官方案例 &lt;a href=&quot;https://ant.design/components/form-cn/#components-form-demo-global-state&quot;&gt;表单数据存储于上层组件&lt;/a&gt; ，但是这时候会面临一个问题是，每次变更输入框内的值时都会触发上层组件的 Re-Render ，当分步组件中表单项比较多的时候，或者表单项嵌套的是一个复杂的需要频繁变更值的控件就很可能出现页面卡顿等的性能问题。&lt;/p&gt;
&lt;p&gt;如下图所示，即是实时更新表单域值的数据同步方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 Form 组件内部监听函数 onFieldsChange 获取实时变化的表单值，并通过上层组件的 &lt;code class=&quot;language-text&quot;&gt;handleFormChange&lt;/code&gt; 存储在 State 中&lt;/li&gt;
&lt;li&gt;上层组件 State 发生变化，表单值通过 Props 传递给子组件，在传递给子组件之前会经过修饰子组件的 Form 组件，组件内部提供 &lt;code class=&quot;language-text&quot;&gt;mapPropsToFields&lt;/code&gt; 方法，这个方法的作用是把父组件的属性映射到表单项上，但是需要对返回值中的表单域数据用 &lt;code class=&quot;language-text&quot;&gt;Form.createFormField&lt;/code&gt; 标记&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/ant-form-real-time-synchronization.png&quot; alt=&quot;real-time-synchronization&quot;&gt;&lt;/p&gt;
&lt;p&gt;切换页面时进行数据验证并同步到上层组件的数据同步方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当用户对表单进行填充时，表单值的变化会实时反映到 Form 组件内部构建的 FieldsStore 实例中，驱动 Child 组件 Re-Render&lt;/li&gt;
&lt;li&gt;当用户填充完毕并提交当前步骤的表单时，触发上层组件 handleFormChange 进行数据同步&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个流程相比实时存储的方案会更加简洁，减少因数据同步导致上层组件 Re-Render。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/ant-form-verifying-synchronization.png&quot; alt=&quot;verifying-synchronization&quot;&gt;&lt;/p&gt;
&lt;h3&gt;异步请求处理方案&lt;/h3&gt;
&lt;p&gt;表单编辑页在加载页面时，通过 Model 进行异步向服务器请求数据，而当服务器响应返回浏览器这段时间，页面的组件已经完成初始化阶段并挂载到浏览器 DOM 树中。&lt;/p&gt;
&lt;p&gt;如果按照新建页面根据顶层组件的状态向底层组件传递表单域值，并于各个表单项初始化时使用 &lt;code class=&quot;language-text&quot;&gt;initialValue&lt;/code&gt; 设置表单的初始值，该值会由于组件初始化与异步请求响应之间存在时间差而失效，因此需要提供一种方案等待异步请求响应后再对底层组件进行初始化渲染。&lt;/p&gt;
&lt;p&gt;既然底层组件需要对表单域值进行初始化，那么我们可以手动设置阻塞等待数据响应后才对底层组件渲染。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简易示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getDerviedStateFromProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;nextProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; prevState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isEmptyObject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;dataDetail&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isEmptyArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;dataList&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;prevState&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;isInitial
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// ...Logic Disposal&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      basic&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; receipt&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; usage&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; isInitial&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过生命周期函数 &lt;code class=&quot;language-text&quot;&gt;getDerivedStateFromProps&lt;/code&gt; 根据 Model 传入的 Store 再转存到顶层组件的状态中，这里设置了状态 &lt;code class=&quot;language-text&quot;&gt;isInitial&lt;/code&gt; 用于判断是否为异步请求响应后的初次触发，目的是避免 Props 变化或者顶层组件的父组件重渲染导致该生命周期函数触发。&lt;/p&gt;
&lt;p&gt;除了在 &lt;code class=&quot;language-text&quot;&gt;getDerivedStateFromProps&lt;/code&gt; 对 State 赋值的操作进行拦截外，还需要在组件渲染控制器设定加载动效，以度过等待异步请求的时间，能有效缓解用户的焦虑。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token function&quot;&gt;getCurrentStepComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; canRendering &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;basic&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; receipt&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; usage&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;every&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isEmptyObject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;canRendering&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;token script language-javascript&quot;&gt;&lt;span class=&quot;token script-punctuation punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;styles&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;spin&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Spin&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;token script language-javascript&quot;&gt;&lt;span class=&quot;token script-punctuation punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; margin&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// Return SubComponent to render&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;复合表单项设计分析&lt;/h2&gt;
&lt;h3&gt;动态增减复合组件&lt;/h3&gt;
&lt;p&gt;在领取条件的分步表单中需要设计一个复合组件用于设定促销优惠券使用的时间段。&lt;/p&gt;
&lt;p&gt;主要包含以下功能以及相关规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基础组件组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单项选择组件：用于控制其余基础组件隐藏与显示&lt;/li&gt;
&lt;li&gt;多项选择组件：选择周一至周日的多选输入框&lt;/li&gt;
&lt;li&gt;时间选择组件：每项为时分为元素的时间段选择输入框&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间选择组件支持动态增减，至少存在一个，至多存在五个&lt;/li&gt;
&lt;li&gt;支持表单校验，时间范围选择必须合法，且多个时间范围间不能存在重叠情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据 AntDesign 的文档提供的相关实现方法，这里有两种实现方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是自定义表单控件，将多种类型的基础组件糅合在一起，多个字段综合为一个对象，存储在一个上层字段中（上层字段与其他表单项平级）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; data &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Foo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  interval&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;ALL&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    week&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;1&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;2&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;3&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    interval&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; startTime&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;08:00&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; endTime&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;10:00&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; startTime&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;12:00&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; endTime&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;14: 00&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;一种是根据动态增减表单项，将多个类型的基础组件生成多个字段，与其他表单项平级。&lt;a href=&quot;https://ant.design/components/form-cn/#components-form-demo-dynamic-form-item&quot;&gt;官方示例实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从需求出发，无论出原型设计上还是前端组件设计上，都应该保持功能一致，也就是说这个组件应该封装成单独的组件，组件内部有控制开关，根据单项选择展示不同的次级表单项，而且动态增减的只是时间段输入框，而与单项选择和日期选择无关，因此将多个基础组件封装起来并通过 Ant Design 提供的自定义表单控件的组合模式能够更合理地实现此功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/ant-form-time-interval-exhibition.gif&quot; alt=&quot;time-interval-exhibition&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Form 组件使用总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用 Radio / Checked 这些选择组件是不推荐使用 feedback #issue&lt;/li&gt;
&lt;li&gt;input 在按 Tab 切换文本输入框时不获取焦点的方法：将 input 的 tabindex 设置为 -1&lt;/li&gt;
&lt;li&gt;input 不被选中的方法：设置 readonly 只读属性&lt;/li&gt;
&lt;li&gt;input 取消浏览器提供的自动填充 &lt;code class=&quot;language-text&quot;&gt;autoComplete=off&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由 getFieldDecorator 包裹的表单组件默认值为 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 而非 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; 或者 &lt;code class=&quot;language-text&quot;&gt;&amp;#39;&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如设置默认值可以这样设置&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token function&quot;&gt;getFieldDecorator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  initialValue&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; fields&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; fields&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  rules&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Input&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;多个校验规则在校验时反馈只单独显示一条规则，当该规则通过时再校验下条规则，可以设置 &lt;code class=&quot;language-text&quot;&gt;validateFirst: true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果触发事件需要在上层处理，而数据在当前组件存储，那么可以在当前组件做一层拦截，在当前组件事件触发 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; 传入的事件。&lt;/li&gt;
&lt;li&gt;数组操作少用 &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt; 直接在原数组中操作的方法，多使用 &lt;code class=&quot;language-text&quot;&gt;concat&lt;/code&gt; 、 &lt;code class=&quot;language-text&quot;&gt;filter&lt;/code&gt; 等返回新数组的方法（Immutable 的概念）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;总结思考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;应该减少需求功能实现的耗时，更应该关注用户的体验、组件设计的合理性和可扩展性、功能的可用性、功能的优化以及测试的覆盖性&lt;/li&gt;
&lt;li&gt;因为该项目的主要需求都是基于 antd 基础组件库进行业务组件的封装，因此适当地研究 antd 底层源代码可以更好地理解组件运行原理，而且能学习到很多 React 组件优秀的设计模式和代码书写方式&lt;/li&gt;
&lt;li&gt;类似的业务模块功能可能会经历多次迭代，功能可增可减，因此开发需求前对功能业务需要有适当地理解，这有助于前端开发对组件模块的设计，而设计的合理性不仅在出现问题时快速定位错误，而且能有效地减少后期维护的成本&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;h3&gt;相关开源项目&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ant-design/ant-design&quot;&gt;antd: ^3.12.0&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ant-design/ant-design/blob/master/components/form/index.en-US.md&quot;&gt;FormComponent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/react-component/form&quot;&gt;rc-form&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yiminghe/async-validator&quot;&gt;async-validator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/moment/moment&quot;&gt;moment: ^2.22.1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ant-design/ant-design/blob/master/components/form/docs/tutorial.md&quot;&gt;表单实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5c47ffff51882533e05ef4f9&quot;&gt;10 分钟精通 Ant Design Form 表单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27740483?utm_medium=hao.caibaojian.com&amp;#x26;utm_source=hao.caibaojian.com&quot;&gt;antd 表单性能的改进实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://redux-saga-in-chinese.js.org/docs/api/&quot;&gt;Redux-sage API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[基于 roadhog^2.x 的后台项目构建性能优化]]></title><description><![CDATA[技术选型 目前我司后台系统采用基于 Webpack 为底层封装的打包工具 roadhog。开发者通过工具暴露的有限的可配置参数，可以简单明了地针对项目需要进行自定义配置。该款工具的目的很明确，就是为了简化 webpack…]]></description><link>http://mrsingsing.com/building-performance-optimization-based-on-roadhog/</link><guid isPermaLink="false">http://mrsingsing.com/building-performance-optimization-based-on-roadhog/</guid><pubDate>Sun, 20 Jan 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;技术选型&lt;/h2&gt;
&lt;p&gt;目前我司后台系统采用基于 &lt;a href=&quot;https://github.com/webpack/webpack&quot;&gt;Webpack&lt;/a&gt; 为底层封装的打包工具 &lt;a href=&quot;https://github.com/sorrycc/roadhog&quot;&gt;roadhog&lt;/a&gt;。开发者通过工具暴露的有限的可配置参数，可以简单明了地针对项目需要进行自定义配置。该款工具的目的很明确，就是为了简化 webpack 的配置。这对于入门级别的工程师是非常友好的，因为降低了学习 webpack 的成本，免去捣鼓 webpack 复杂的配置，方便开发者快速进入开发流程。&lt;/p&gt;
&lt;p&gt;从目前项目版本的 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 向上层依赖溯源可以得出这样的依赖关系：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;roadhog^2.4.2 =&gt; af-webpack^0.23.0-beta.1 =&gt; webpack^3.56&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;roadhog 基于 &lt;a href=&quot;https://github.com/umijs/umi/tree/master/packages/af-webpack&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;umi/af-webpack&lt;/code&gt;&lt;/a&gt; 作为底层。从社区反馈的信息得知，现时（2019.1）作者的工作重点都在 &lt;a href=&quot;https://github.com/umijs/umi&quot;&gt;umi&lt;/a&gt;，而 roadhog 无打算迭代升级的打算。即便将 roadhog 升级至最新版本，所依赖的底层 webpack 的版本也只是 3.5.6，webpack4+ 的优化配置均无法使用。由于工具文档提供信息有限，因此要将优化进行到极致从源码依赖着手推动项目构建优化是免不了的工作。&lt;/p&gt;
&lt;h2&gt;构建现况分析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;版本 release/2.29.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;分析材料&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;a href=&quot;https://github.com/webpack-contrib/webpack-bundle-analyzer&quot;&gt;webpack-bundle-analyzer&lt;/a&gt; 对打包模块进行可视化分析&lt;/li&gt;
&lt;li&gt;对打包出来后的资源文件进行分析&lt;/li&gt;
&lt;li&gt;项目组织结构分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;构建情况分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建内存占用过高：130% 需要给 node 配置更多内存防止内存溢出导致失败&lt;/li&gt;
&lt;li&gt;构建进度观察：卡在 10%、86%、&lt;strong&gt;91%&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;构建使用时间：407s 366s 386s 380s 372s =&gt; 平均 382s&lt;/li&gt;
&lt;li&gt;静态资源数量：分割成共 92 个资源文件（包括入口文件，但除去默认拷贝输出的文件）&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态资源大小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start：总 150MB，平均，最大 5.05MB&lt;/li&gt;
&lt;li&gt;Parsed：总 88MB，平均，最大 2.48MB&lt;/li&gt;
&lt;li&gt;Gzipped：总 25MB，平均，最大 686.48KB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;静态资源大小&lt;/th&gt;
&lt;th&gt;数量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&gt;2MB&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&gt;1MB&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&gt;500KB&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;项目构建优化方案&lt;/h2&gt;
&lt;p&gt;按照 &lt;a href=&quot;https://github.com/pigcan/blog/issues/1&quot;&gt;Webpack 构建性能优化探索&lt;/a&gt; 提供的思路，可以从四个维度着手项目构建的优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从环境着手，提升下载依赖速度&lt;/li&gt;
&lt;li&gt;从项目自身着手，代码组织是否合理，依赖使用是否合理，反面提升效率&lt;/li&gt;
&lt;li&gt;从 Webpack 自身优化手段着手，优化配置，提升 Webpack 效率&lt;/li&gt;
&lt;li&gt;从 Webpack 可能存在的不足着手，优化不足，进一步提升效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;去除废弃依赖&lt;/h3&gt;
&lt;p&gt;观察 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;，发现一些项目中废弃的依赖并没有及时处理，因此把无用的和重复安装的依赖去除。&lt;/p&gt;
&lt;h3&gt;提取第三方公共模块&lt;/h3&gt;
&lt;p&gt;此前项目中页面代码根据路由按需加载，每个页面 route 和 model 引用的第三方模块，例如 &lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;dva&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;query-string&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;antd&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;moment&lt;/code&gt; 等，都会在各自的页面中重复打包一份，这就导致根据页面分割的资源文件尺寸较大，冗余代码较多。&lt;/p&gt;
&lt;p&gt;除此之外，值得注意的是，项目中使用的 &lt;a href=&quot;https://github.com/ant-design/ant-design&quot;&gt;AntDesign&lt;/a&gt; 组件，尽管通过 &lt;a href=&quot;https://github.com/ant-design/babel-plugin-import&quot;&gt;babel-plugin-import&lt;/a&gt; 实现了组件模块的按需加载，页面引用并不会将完整的 AntDesign 引入。但是由于开始时候大部分页面都不会从零开始写，而是会选择移植相似页面的逻辑再加以修改，因此会导致相当一部分页面会将没有使用到的组件进行打包，同样会造成冗余。&lt;/p&gt;
&lt;p&gt;因此，整个项目的性能优化必然从资源依赖的第三方库着手，提前编译提取。&lt;/p&gt;
&lt;p&gt;分析 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 可以得知整个项目依赖主要有几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ant-design/ant-design&quot;&gt;antd&lt;/a&gt; 基础 UI 组件库 📌&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dvajs/dva&quot;&gt;dva&lt;/a&gt; 数据管理框架&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/moment/moment&quot;&gt;moment&lt;/a&gt; 时间操作工具库 📌&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ali-sdk/ali-oss&quot;&gt;ali-oss&lt;/a&gt; 阿里云 OSS 插件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;react&lt;/a&gt; 界面框架&lt;/li&gt;
&lt;li&gt;react-dom&lt;/li&gt;
&lt;li&gt;react-router-dom&lt;/li&gt;
&lt;li&gt;universal-cookie&lt;/li&gt;
&lt;li&gt;…等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;roadhog 暴露了 commons 参数对应 Webpack 中 plugins 的多个 &lt;code class=&quot;language-text&quot;&gt;webpack.CommonsChunkPlugin&lt;/code&gt; 实例。下面有两种可选择的方案供实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被至少固定个数（默认两个） entry/page 依赖即提取公共，这样 common 公共模块会比较大，项目整体尺寸最小，但页面首屏渲染需要加载的资源尺寸会比较大&lt;/li&gt;
&lt;li&gt;被所有 entry/page 依赖才提取为公共，这样 common 公共模块比较小，项目整体尺寸较大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终决定将所有依赖的第三方模块提前打包，在用户访问页面时需要将基础工具和基础组件的打包文件先加载，后续用户界面资源文件加载就会相对另一种方案会更加快速。&lt;/p&gt;
&lt;p&gt;相关扩展：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012828879&quot;&gt;详解 CommonsChunkPlugin 的配置和用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5c2205e15188257507558c5a&quot;&gt;webpack.optimize.CommonsChunkPlugin 详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/95752b101582&quot;&gt;webpack、manifest、runtime、缓存与 CommonsChunkPlugin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第三方模块不同兼容库重复打包&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/roadhog-performance-build-analyze.jpg&quot; alt=&quot;优化前打包结果&quot;&gt;&lt;/p&gt;
&lt;p&gt;vendor 提取第三方模块后，发现几个比较大的页面资源文件里仍然存在 antd.lib 组件库的代码，而且这些 &lt;code class=&quot;language-text&quot;&gt;ant.lib&lt;/code&gt; 都是完整一个模块被打包进了这些页面当中，但其实 AntDesign 已经被我完整单独地打包成另外一个文件了，这个打包的文件是由 &lt;code class=&quot;language-text&quot;&gt;ant.es&lt;/code&gt; 打包出来的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;antd.es&lt;/li&gt;
&lt;li&gt;antd.lib&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过对打包后的文件以及业务代码的检查，发现是引用 Antd 组件库发生了问题，由于使用了 webpack-plugin-import 插件，将 Antd 中名为 es 的组件库按需加载并通过 babel 转化独立打包成 vendor，因此当使用 &lt;code class=&quot;language-text&quot;&gt;import {message} from &amp;quot;antd/lib/index&amp;quot;&lt;/code&gt; 这种写法的时候，当前页面会将 Antd lib 目录下的组件全部打包，造成页面打包文件臃肿。&lt;/p&gt;
&lt;p&gt;书写规范
使用了 extraBabelPlugins 就会按需加载&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// wrong&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; message &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;antd/lib/index&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// good&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; message &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;antd&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;忽略 moment 语言包的打包&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/roadhog-performance-moment-locale.jpg&quot; alt=&quot;忽略 moment 语言包&quot;&gt;&lt;/p&gt;
&lt;p&gt;打包后 moment 包的体积比较大，其中 locale 语言包部分占据了比较大的体积，由于我们的项目没有国际化需求，因此可以通过配置 roadhog 提供的 &lt;code class=&quot;language-text&quot;&gt;ignoreMomentLocale: true&lt;/code&gt; 减少打包出来的 vendor 尺寸。&lt;/p&gt;
&lt;p&gt;但是，如果项目中使用到 AntDesign 组件，并且使用到时间选择组件 &lt;code class=&quot;language-text&quot;&gt;date-picker&lt;/code&gt;（默认是英文文案），那么这里需要做一些处理以使项目中组件能够显示中文。&lt;/p&gt;
&lt;p&gt;我是在项目最上层，单独引入 moment 的中文语言包。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; moment &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;moment&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;moment/locale/zh-cn&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

moment&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;locale&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;zh-cn&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样项目中使用到 moment 工具库的 &lt;code class=&quot;language-text&quot;&gt;date-picker&lt;/code&gt; 都会显示中文文案。&lt;/p&gt;
&lt;h3&gt;压缩耗时&lt;/h3&gt;
&lt;p&gt;项目构建过程会卡在 91%，通过查阅相关资料和了解社区反馈后，明确原因为该阶段 Webpack 正在对代码进行混淆压缩操作，但同时由于 Webpack 的压缩插件 UglifyJS 无法对 ES6+ 的代码进行压缩，需要使用 &lt;a href=&quot;https://github.com/babel/minify&quot;&gt;babel-minify&lt;/a&gt; 获取更好的 treeshaking 效果（虽然 Webpack4 已经支持 ES6+ 代码压缩，但是目前 Roadhog 采用的是 Webpack3+）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackmd.io/YHK_yuRtT0ePPVLY0_kUzw&quot;&gt;构建速度慢的解决方法@sorrycc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;体现特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建速度慢&lt;/li&gt;
&lt;li&gt;内存消耗高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;减少依赖文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化 common 提取策略，让整体尺寸尽可能少&lt;/li&gt;
&lt;li&gt;externals 掉一些大的库，降低整体尺寸&lt;/li&gt;
&lt;li&gt;利用 webpack 的 TreeShaking + es module，排除掉一些没有用到的模块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;减少需要压缩的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;外部扩展&lt;/h3&gt;
&lt;p&gt;externals 是非常有效的一个方案，可以一下子减少大量需要编译、压缩的模块。将一些不常更新版本比较稳定的模块文件直接注入 HMTL 文件，当读取到该脚本时将自动加载，这不仅能加快构建速度，而且能够利用 CDN 进行资源缓存。&lt;/p&gt;
&lt;p&gt;但是会带来的问题是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法利用 Webpack 的 Tree-Shaking&lt;/li&gt;
&lt;li&gt;多个库之间如果存在公共模块（比如 lodash），就无法复用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 externals 需要在 HTML 里引用额外的 JS 文件，这里也有几个潜在的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你的 CDN 不支持 Combo，并且不是 http/2，那么速度会很慢&lt;/li&gt;
&lt;li&gt;你需要手动维护一份 CDN 文件列表，并且跟进他们的更新，也是件麻烦的事情&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里主要将三个尺寸较大且比较少项目页面引用的模块 externals 掉。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;externals&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;ali-oss&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;window.OSS&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;react&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;window.react&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;react-dom&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;window.ReactDOM&apos;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;项目样式文件减少&lt;/h3&gt;
&lt;p&gt;ExtractTextPlugin 提取 CSS (antd + 业务)&lt;/p&gt;
&lt;p&gt;能用公共就用公共（因为大部分的页面的样式几乎一样），不然每个页面开一个 less 引用公共，会重复打包，造成冗余。&lt;/p&gt;
&lt;h3&gt;Gzip 传输压缩&lt;/h3&gt;
&lt;p&gt;gzip 需要在服务器配置开启&lt;/p&gt;
&lt;p&gt;这里提供一种 Nginx 的配置。&lt;a href=&quot;https://blog.csdn.net/qq_36030288/article/details/54576503&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zs-note/p/9556390.html&quot;&gt;前端性能优化：gzip 压缩文件传输数据&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;优化效果分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://img.mrsingsing.com/roadhog-performance-optimizition-result.jpg&quot; alt=&quot;优化效果分析&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发体验：70s =&gt; 20s 启动项目时间提升 71%&lt;/li&gt;
&lt;li&gt;构建速度：382s =&gt; 40s 项目构建速度提升 89%&lt;/li&gt;
&lt;li&gt;资源文件：88Mb（未开启 Gzip） =&gt; 25Mb（开启 Gzip） =&gt; 1Mb（优化后开启 Gzip） 资源文件尺寸大幅度降低&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;后续需要解决的问题&lt;/h2&gt;
&lt;h3&gt;单独打包的 AntDesign 尺寸过大&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可视化分析尺寸较大的文件包括 rc-editor-core / draft.js 等&lt;/li&gt;
&lt;li&gt;通过依赖找到根源是 rc-editor-mention =&gt; rc-editor-core =&gt; draft-js 来自 Mention 组件，但是项目中并没有使用到&lt;/li&gt;
&lt;li&gt;得出结果提取打包将整个组件库都打包进来了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;社区中有反应希望提取公共模块打包时将其中某些部分忽略不打包，而维护者似乎告知需要使用 &lt;code class=&quot;language-text&quot;&gt;babel-plugin-import&lt;/code&gt; 按需引用，并没提供提取公共模块的解决方案。 &lt;a href=&quot;https://github.com/ant-design/ant-design/issues/10180&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/sorrycc/roadhog/issues/370&quot;&gt;支持 vendor 的配置 Issue #370&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/sorrycc/roadhog/issues/577&quot;&gt;roadhog2 如何成功提取 vendor · Issue #577&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/sorrycc/roadhog/issues/722&quot;&gt;编译很慢 #722&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/liangxinwei/blog/blob/master/webpack/2.md&quot;&gt;roadhog 1.3x 打包慢的解决办法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mamicode.com/info-detail-2413081.html&quot;&gt;Roadhog 构建优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itcodemonkey.com/article/12011.html&quot;&gt;JS/CSS 体积减少了 67%，我们是如何做到的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/creeperyang/blog/issues/37&quot;&gt;Webpack 日常使用与优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>