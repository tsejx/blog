{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"7b66274c41242c16c7c8801a7e5db64e796a5e57","modified":1629255132879},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1629255060834},{"_id":"themes/next/.DS_Store","hash":"1281139b003f6c7767a6f8fb1eb898dabfa6d9f6","modified":1629255060832},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1629255060835},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1629255060835},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1629255060836},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1629255060837},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1629255060838},{"_id":"themes/next/README.md","hash":"c1d6d1c6b75736b892e179865833ea58da5ca9d2","modified":1629255060839},{"_id":"themes/next/bower.json","hash":"a8c832da6aad5245052aed7ff26c246f85d68c6c","modified":1629255060841},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1629255060842},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1629255060868},{"_id":"themes/next/package.json","hash":"11a0b27f92da8abf1efbea6e7a0af4271d7bff9e","modified":1629255061039},{"_id":"themes/next/_config.yml","hash":"e6807ccf6cff340dd85e239f553997039e8c09a8","modified":1629270860650},{"_id":"source/_posts/analysis-of-vue-responsive-systrm.md","hash":"cb23ab8e095796269034c6d19b15369b66e3e820","modified":1629268692383},{"_id":"source/_posts/architect-design-based-on-rbac.md","hash":"d007e74208d8a24bf4abc88a17fb5e0ffe61bf8e","modified":1629257343052},{"_id":"source/_posts/about-content-delivery-network.md","hash":"783a8434d3d7896b7efd12e93f97f7fb180a5cb7","modified":1629268694302},{"_id":"source/_posts/building-performance-optimization-based-on-roadhog.md","hash":"1dceb40210bef6c51e744e3aae51568742cfdd89","modified":1629257623192},{"_id":"source/_posts/business-experience-summary-of-lading-page.md","hash":"7bd5a9a570134704c0be3183fa6431b6d64854b0","modified":1629257282003},{"_id":"source/_posts/event-chain-based-automatic-test-scheme-of-totorox.md","hash":"af39b85f2d60ea1cf5c77b04aafd33369ddd6b9b","modified":1629257385340},{"_id":"source/_posts/form-business-design-pratice-in-antd.md","hash":"f846073dd6dfe563ba5c5920113ddc6febe358c0","modified":1629257594534},{"_id":"source/_posts/means-for-performance-optimization.md","hash":"b2c6a444978a476a44650fe82f30be31b8a49104","modified":1629257486484},{"_id":"source/_posts/docker-deploy-pratice.md","hash":"d5c8b4e29dfd122edde3bc41a96bb4aa2a4d8310","modified":1629257359941},{"_id":"source/_posts/practice-of-page-batch-update-tool-in-visual-configuration-system.md","hash":"d39b7d05737db6362065645a8df480788b409ee8","modified":1629257443566},{"_id":"source/_posts/authentication.md","hash":"f10ae93d6cd5bb275982ba0499bb02f0225eb8f9","modified":1629257242377},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1629255132885},{"_id":"source/_posts/summary-of-common-development-and-debugging-methods-of-mobile-front-end.md","hash":"aa3df9644b131fb3a3f4d635872d8895cdf403bf","modified":1629257320175},{"_id":"source/tags/index.md","hash":"c038a75a44098c0e3aa4b8b03607265a8a42094d","modified":1629255132886},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1629255060847},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1629255060846},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1629255060848},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1629255060845},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1629255060850},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1629255060853},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1629255060851},{"_id":"themes/next/docs/MATH.md","hash":"0ae4258950de01a457ea8123a8d13ec6db496e53","modified":1629255060852},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1629255060869},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1629255060872},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1629255060872},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1629255060888},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1629255060886},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1629255060892},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1629255060880},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1629255060896},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1629255060893},{"_id":"themes/next/languages/ja.yml","hash":"5f8e54c666393d1ca2e257f6b1e3b4116f6657d8","modified":1629255060891},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1629255060903},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1629255060906},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1629255060905},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1629255060909},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1629255060907},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1629255060908},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1629255060910},{"_id":"themes/next/layout/_layout.swig","hash":"1b59036ccb2ad571503b94587f458fad46775642","modified":1629255060917},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1629255061034},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1629255061035},{"_id":"themes/next/layout/archive.swig","hash":"00348e37bff100ce1f538c4de2880c344403fa54","modified":1629256500053},{"_id":"themes/next/layout/page.swig","hash":"79040bae5ec14291441b33eea341a24a7c0e9f93","modified":1629255061036},{"_id":"themes/next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1629255061037},{"_id":"themes/next/layout/schedule.swig","hash":"3e9cba5313bf3b98a38ccb6ef78b56ffa11d66ee","modified":1629255061038},{"_id":"themes/next/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1629255061040},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1629255061041},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1629255061038},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1629255061042},{"_id":"themes/next/source/.DS_Store","hash":"71fbfc7b99778a7affb4e31551c3bf7dbb20d65a","modified":1629255061054},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1629255061225},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1629255061225},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1629255061226},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1629255060844},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1629255061169},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1629255060859},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1629255060858},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1629255060863},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1629255060862},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"44e4fb7ce2eca20dfa98cdd1700b50d6def4086f","modified":1629255060861},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1629255060864},{"_id":"themes/next/docs/zh-CN/README.md","hash":"46b264623af21211a0a9c4ba0cf1318a80eeb9fb","modified":1629255060866},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"e03607b608db4aa7d46f6726827c51ac16623339","modified":1629255060865},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1629255060867},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1629255060854},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1629255060855},{"_id":"themes/next/docs/ru/README.md","hash":"edfe0cfb8b2c9f0effd3beb868af9bfd0fabb3a6","modified":1629255060856},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1629255060857},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1629255060911},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1629255060913},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1629255060913},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1629255060921},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1629255060922},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1629255060923},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1629255060925},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"7cbe5e496de8755634528acdde18d453b6851a78","modified":1629258948984},{"_id":"themes/next/layout/_partials/comments.swig","hash":"eafff2d623af8991844f34819a60e37ac11ef245","modified":1629255060930},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1629255060927},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1629255060929},{"_id":"themes/next/layout/_partials/footer.swig","hash":"cf8fe76993b513b97f379832222b6ec7e41a1c15","modified":1629255060935},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1629255060943},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1629255060944},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1629255060956},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1629255060955},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1629255060955},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1629255060968},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1629255060990},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1629255061001},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1629255061000},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1629255061013},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1629255061020},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1629255061020},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1629255061021},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1629255061023},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1629255061022},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1629255061044},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1629255061045},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1629255061047},{"_id":"themes/next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1629255061046},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1d59b968af4b8d147f8bc9bc295d596e41be8348","modified":1629255061047},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"545102e3aa3ce494f7046abf71cefb7aaf671559","modified":1629255061050},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1629255061051},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1629255061052},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1629255061053},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1629255061168},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1629255061171},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1629255061170},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1629255061172},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1629255061173},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1629255061176},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1629255061174},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1629255061177},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1629255061178},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1629255061180},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1629255061180},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1629255061179},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1629255061186},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1629255061184},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1629255061186},{"_id":"themes/next/source/images/favicon.ico","hash":"12c44eb7d5b9ba501ba51554c337a9c85b528871","modified":1629255061185},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1629255061187},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1629255061188},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1629255061188},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1629255061189},{"_id":"themes/next/layout/_macro/post.swig","hash":"27922af64ecb9db9a28bcf1c98fb68b26bf0b67a","modified":1629255060924},{"_id":"themes/next/source/images/avatar.jpeg","hash":"c2cb171a5aec9d9d9d0853bdc191a32793c9bfa3","modified":1629255061173},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1629255060959},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1629255060960},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1629255061136},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1629255061136},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1629255061138},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1629255061162},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1629255061164},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1629255060919},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1629255060920},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1629255060936},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1629255060938},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1629255060939},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1629255060940},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1629255060941},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1629255060942},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1629255060946},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1629255060943},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1629255060947},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1629255060949},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1629255060950},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1629255060952},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1629255060951},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1629255060953},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1629255060957},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1629255060959},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1629255060963},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1629255060972},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1629255060973},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"67f0cb55e6702c492e99a9f697827629da036a0c","modified":1629255060975},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1629255060976},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"94b26dfbcd1cf2eb87dd9752d58213338926af27","modified":1629255060980},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1629255060974},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1629255060979},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1629255060983},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1629255060984},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"43f70cdc999c66b9c7889a13150ec63e99b1fdd0","modified":1629255060986},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1629255060987},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1629255060988},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1629255060989},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1629255060995},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1629255060991},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"8878241797f8494a70968756c57cacdfc77b61c7","modified":1629255060992},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1629255060996},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"88b5a808b6b254c6122444e9dc180d5cc459cb19","modified":1629255060997},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1629255060999},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1629255061016},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1629255061017},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1629255061019},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1629255061027},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1629255061029},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1629255061028},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1629255061030},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1629255061134},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1629255061135},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"51c2907e5c50c2614419b670fbdec183ae7f7f5d","modified":1629255061138},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1629255061161},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1629255061160},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1629255061137},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1629255061162},{"_id":"themes/next/source/css/_variables/base.styl","hash":"0b43ddd92e395342703550f629699c5e591fd68b","modified":1629255061163},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1629255061203},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1629255061202},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1629255061204},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1629255061204},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1629255061205},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1629255061191},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1629255061191},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1629255061192},{"_id":"themes/next/source/js/src/motion.js","hash":"52fd093cb96b68229b38436c9b8ebcefc7e12cb2","modified":1629255061194},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1629255061193},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1629255061193},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1629255061196},{"_id":"themes/next/source/js/src/post-details.js","hash":"9e9b078d7ec2505c15157c9fc588e042e34465fe","modified":1629261129900},{"_id":"themes/next/source/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1629255061200},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1629255061197},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1629255061224},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1629255061223},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1629255061224},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1629255061025},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1629255061026},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1629255061056},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1629255061061},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1629255061063},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1629255061062},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1629255061066},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1629255061086},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1629255061111},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"18309b68ff33163a6f76a39437e618bb6ed411f8","modified":1629255061128},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1629255061130},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1629255061127},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1629255061129},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"0810e7c43d6c8adc8434a8fa66eabe0436ab8178","modified":1629255061132},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1629255061130},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1629255061131},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1629255061141},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fca5320e2644edcd663888863899d1b80352439b","modified":1629255061140},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1629255061141},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1629255061142},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1629255061143},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1629255061144},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1629255061143},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1629255061145},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1629255061150},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1629255061151},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1629255061152},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1629255061151},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1629255061153},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1629255061157},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1629255061156},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1629255061155},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1629255061157},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1629255061158},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1629255061159},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1629255061159},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1629255061208},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1629255061207},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1629255061209},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"ab6f13fae0513a9b39f8d8c4c3a4e3928014f046","modified":1629255061195},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1629255061220},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1629255061219},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1629255061216},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1629255061213},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1629255061070},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1629255061068},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1629255061072},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1629255061071},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1629255061073},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1629255061072},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1629255061074},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"17b95828f9db7f131ec0361a8c0e89b0b5c9bff5","modified":1629255061077},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1629255061076},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1629255061079},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1629255061078},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1629255061080},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1629255061081},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1629255061084},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1629255061083},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1629255061085},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1629255061089},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1629255061090},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1629255061091},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1629255061092},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1629255061094},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1629255061093},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1629255061095},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1629255061095},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1629255061096},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1629255061097},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1629255061098},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1629255061099},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"c0ac49fadd33ca4a9a0a04d5ff2ac6560d0ecd9e","modified":1629255061100},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1629255061101},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1629255061101},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"ed9608d2740a33664eb703f806c218a4fc520087","modified":1629255061102},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1629255061104},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"bbe0d111f6451fc04e52719fd538bd0753ec17f9","modified":1629255061104},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1629255061105},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1629255061106},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1629255061107},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1629255061107},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1629255061108},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1629255061109},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1629255061109},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1629255061110},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1629255061112},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"cf2185a0ea170fd8450f592e859a6c941141e5ee","modified":1629255061113},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1629255061114},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1629255061116},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1629255061117},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1629255061118},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1629255061118},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1629255061119},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1629255061120},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1629255061121},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1629255061122},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1629255061123},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1629255061124},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1629255061123},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1629255061125},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1629255061125},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1629255061126},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1629255061146},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1629255061148},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1629255061154},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1629255061212},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1629255061222},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1629255061211},{"_id":"public/tags/index.html","hash":"43954945b9464230141935865c933d13ef2d8ee6","modified":1629281702071},{"_id":"public/archives/page/2/index.html","hash":"4161f0fc21352e57c05ed6d5cd442d9827dc310c","modified":1629281702071},{"_id":"public/archives/2019/index.html","hash":"1f185883409d4ebce5bc9fc63cf1f9b206ce1379","modified":1629281702071},{"_id":"public/archives/2019/01/index.html","hash":"56c082aa3d90bdd8f8dabb2a3af3ed509659c468","modified":1629281702071},{"_id":"public/archives/2019/04/index.html","hash":"656f531a705765a293595d15330727e1680cbff5","modified":1629281702071},{"_id":"public/archives/2019/05/index.html","hash":"49bad7997cb0bfa396e4e244535f3da2f945783d","modified":1629281702071},{"_id":"public/archives/2019/07/index.html","hash":"e9ba69ad901126df6d017fb746004ed91b4dd4f5","modified":1629281702071},{"_id":"public/archives/2019/11/index.html","hash":"4b01c3383a30795058a7e465817b1041ba4b12b0","modified":1629281702071},{"_id":"public/archives/2020/index.html","hash":"4969705f1f3df69bd34fbe647be4fac934cff1d6","modified":1629281702071},{"_id":"public/archives/2020/03/index.html","hash":"8c6d92deb819da705ea817e59a2bb5955b13c4d5","modified":1629281702071},{"_id":"public/archives/2020/04/index.html","hash":"f7277bae00efa4bcc3f16bc54d32bf5635fc4ac6","modified":1629281702071},{"_id":"public/archives/2020/05/index.html","hash":"de59606c1050ba1339c3df4d1008be213a09bc71","modified":1629281702071},{"_id":"public/archives/2020/06/index.html","hash":"4fe4d730dba8cae5e0ac1c95817dbc069acedc79","modified":1629281702071},{"_id":"public/archives/2020/08/index.html","hash":"9958bf7a48da1cf7f629fd26224c77816e759f9b","modified":1629281702071},{"_id":"public/about-content-delivery-network/index.html","hash":"7d6a7482bd8baa7b7d11cdd79815d1933c577d8c","modified":1629281702071},{"_id":"public/authentication/index.html","hash":"84c7b267d745960c5b0e0b4c784e46f196d2384f","modified":1629281702071},{"_id":"public/business-experience-summary-of-lading-page/index.html","hash":"f989a758e36de0dd8b60cbb520c4185c56f80326","modified":1629281702072},{"_id":"public/summary-of-common-development-and-debugging-methods-of-mobile-front-end/index.html","hash":"f950452551cdc648b9230d2087708597bc990ffa","modified":1629281702072},{"_id":"public/architect-design-based-on-rbac/index.html","hash":"7ccac683008e6b9f33a80550c3b450f9b707709a","modified":1629281702072},{"_id":"public/docker-deploy-pratice/index.html","hash":"54c4caa5a7e45d6d804bc051cccdb59e0fe96688","modified":1629281702072},{"_id":"public/event-chain-based-automatic-test-scheme-of-totorox/index.html","hash":"e5fdbf8e0f14009eff758153c038fcbb18348487","modified":1629281702072},{"_id":"public/practice-of-page-batch-update-tool-in-visual-configuration-system/index.html","hash":"9ff6afc6ce3366a8fc5353514910566a79fc2d9e","modified":1629281702072},{"_id":"public/analysis-of-vue-responsive-systrm/index.html","hash":"7cb49df0286be157df9ad011129c49d391917f08","modified":1629281702072},{"_id":"public/means-for-performance-optimization/index.html","hash":"d069b76934afe86cd56486a0e65f3e34f0cbf887","modified":1629281702072},{"_id":"public/form-business-design-pratice-in-antd/index.html","hash":"649b77246b380c032f38d0881ef9475e92b71977","modified":1629281702072},{"_id":"public/building-performance-optimization-based-on-roadhog/index.html","hash":"c585f870e4696e61628db84886bead67456f69de","modified":1629281702072},{"_id":"public/archives/index.html","hash":"c5c4e316c9072af36604929c1eecdde9a5482d34","modified":1629281702072},{"_id":"public/index.html","hash":"6b91a47c345c88f22228727d29d1f38dba057771","modified":1629281702072},{"_id":"public/page/2/index.html","hash":"276b8c13e3f5394dc4563af542ec2a11376d43fe","modified":1629281702072},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1629281702076},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1629281702076},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1629281702076},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1629281702076},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1629281702076},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1629281702076},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1629281702076},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1629281702076},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1629281702076},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1629281702076},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1629281702076},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1629281702076},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1629281702076},{"_id":"public/images/favicon.ico","hash":"12c44eb7d5b9ba501ba51554c337a9c85b528871","modified":1629281702076},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1629281702076},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1629281702076},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1629281702076},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1629281702077},{"_id":"public/images/avatar.jpeg","hash":"c2cb171a5aec9d9d9d0853bdc191a32793c9bfa3","modified":1629281702077},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1629281702077},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1629281702077},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1629281702661},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1629281702662},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1629281702663},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1629281702666},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1629281702666},{"_id":"public/js/src/motion.js","hash":"52fd093cb96b68229b38436c9b8ebcefc7e12cb2","modified":1629281702666},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1629281702666},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1629281702667},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1629281702667},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1629281702667},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1629281702667},{"_id":"public/js/src/post-details.js","hash":"9e9b078d7ec2505c15157c9fc588e042e34465fe","modified":1629281702667},{"_id":"public/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1629281702667},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1629281702667},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1629281702667},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1629281702667},{"_id":"public/js/src/schemes/pisces.js","hash":"ab6f13fae0513a9b39f8d8c4c3a4e3928014f046","modified":1629281702667},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1629281702667},{"_id":"public/css/main.css","hash":"7f9e8142fe1bfb6d25148509978fc9dd96e57b9f","modified":1629281702667},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1629281702667},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1629281702668},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1629281702668},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1629281702668},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1629281702668},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1629281702669},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1629281702669}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2018-07-24T07:01:57.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-07-24 15:01:57\ntype: \"tags\"\ncomments: false\n---\n","updated":"2021-08-18T02:52:12.886Z","path":"tags/index.html","layout":"page","_id":"ckshc99yp0001v31p9g9yutrc","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Vue 响应式系统实现探究","date":"2019-07-04T00:00:00.000Z","_content":"\n对 Vue 的响应式原理的实现分析似乎已经是前端界烂大街的话题，尽管如此，在对 Vue 源码研究了一周之后还是想尝试用自己的语言把整个实现原理记录下来。\n\n这份研究**不会对源码作逐行解读**，只会对响应式系统的流程中 Vue 对不同情况的处理方式以及数据的流向叙述清楚。\n\n开局借用 [ustbhuangyi](https://github.com/ustbhuangyi) 的一张图，对整个响应式系统有个宏观的概念。\n\nVue 的响应式原理的核心就是观察这些数据，包括 data、props、computed 和 watch 的变化，当这些数据发生变化以后，能通知到对应的观察者（Watcher）以实现相关的逻辑，从而驱动视图的更新。整个响应式原理最核心的实现就是 Dep 类（语义为依赖 Dependency），这个类实际上是连接**数据对象**与**观察者**的桥梁。\n\n![Vue Reactive](http://img.mrsingsing.com/vue-reactive-workflow.png)\n\n<!-- more -->\n\n## 双向绑定\n\n在 Vue 初始化阶段，会对传入构造函数的配置对象根据不同的选项作相关的处理。\n\n对于 data 和 props 而言，Vue 会通过 observe 和 defineReactive 等一系列的操作把 data 和 props 的每个属性变成响应式属性。\n\n在初始化 data 过程中，data 数据对象经由 observe 以参数形式传入 Observer 类的构造函数。在实例化过程中，Observer 会根据 data 的数据类型执行相关的操作。\n\n- 若 data 为**数组类型**，Observer 会改写该数组原型中的变异方法（Mutation Method），包括 push、pop、shift、unshift、splice、sort 和 revers 共七个方法，这么做的目的是解决使用这些方法的原生实现会无法监测数据的变化的问题。随后，会遍历数组成员并逐个执行 observe 函数，这样就实现了通过递归的方式监测多维数组中的每个成员的数据变化。\n- 若 data 或递归数组成员为**对象类型**，则会遍历并调用 defineReactive 函数。\n\n而在初始化 props 时，经过 vm 实例键名的重名校验后，同样也是遍历调用 [defineReactive](https://github.com/vuejs/vue/blob/3b8925bc7973bb71b33374281db10a945ca9854e/src/core/observer/index.js#L132-L194) 函数。\n\ndefineReactive 函数是对数据进行双向绑定（或称为响应式化）的核心。\n\ndefineReactive 函数内部先实例化一个 [Dep](https://github.com/vuejs/vue/blob/3b8925bc79/src/core/observer/dep.js#L9-L50) 类，该类的建立是搭建起数据与 Watcher 的桥梁，同时也作为收集和存储 Watcher 的容器。随后，通过 Object.defineProperty 方法改写监测的数据字段的 get 函数和 set 函数。当我们访问监测的数据字段的时候，会触发 get 函数，get 函数内部和 set 函数内部都引用了在上层作用域中对 Dep 类实例化的常量 dep 实例对象。这里巧妙地运用了闭包的原理，以确保每个数据字段在访问和修改时都引用着属于自己的 dep 常量。get 函数会执行 dep 的 depend 方法用于<span style=\"color:red;font-weight:bold\">收集依赖</span>，这些依赖是当前正在计算的 Watcher，并最终经由 watcher 的 addDep 和 dep 的 addSub 添加到 dep 实例中的 subs 数组中（subs 意为 Subscriber 订阅者，该数组可以理解为依赖收集的存储容器）。而当修改数据（执行 set 函数）的时候，会触发 dep 的 notify 方法遍历 subs 数组中的依赖（也就是 watcher 实例）并调用它们原型上的 update 方法和 run 方法，最终通知这些订阅者执行<span style=\"color:red;font-weight:bold\">派发更新</span>的逻辑。这两个函数背后的执行路径在 dep 实例和 watcher 实例之间穿梭，这样实现的目的从源码分析来看，是为了区分不同的 Watcher（有 renderWatcher、computedWatcher 和 userWatcher，后面会提及）以及作相应的性能优化（譬如避免重复收集依赖或基于组件层级作缓存处理等）。\n\n总结 get 函数和 set 函数的触发时机，以及其职能功用：\n\n- get 函数在**访问**数据字段时触发，其主要职能是**获取监测数据字段的值**并触发 Watcher 的**依赖收集**。\n- set 函数在对数据字段**修改**时触发，主要职责是**对新的赋值进行响应式化**以及向 Watcher **派发更新**，从而触发视图的重渲染。\n\n谈到这里肯定会有个疑问， get 函数所收集的依赖具体是什么？依赖是如何被收集的？set 函数是如何通知所有的 Watcher 更新的？派发更新的过程究竟做了什么？这些疑问都在下节揭晓。\n\n## 渲染函数\n\n在谈及依赖的追踪和触发前，我们有必要先了解 **「依赖」** 这个那么虚的名词用 JavaScript 语言怎么描述。\n\n谈及双向数据绑定，这里所指的双向指的就是 Data 到 View 以及 View 到 Data 的结合。体现在我们的代码中，就是 Vue 的配置选项即为 Data 的储存容器，而 template 即为概念上的 View。我们知道浏览器在读取 JavaScript 脚本文件后必然经历 DOM 操作方可将相关数据渲染到 DOM 树中，比如使用字符串模版 innerHTML 或通过 appendChild、insertBefore 等 DOM 节点操作插入。\n\n在 Vue 中，模版 template 会经由 Compiler 被编译成渲染函数（Render Function），以下以直观的感受体验模版和渲染函数的表现形式。\n\n```html\n<div id=\"foo\">\n  <p>{{name}}</p>\n</div>\n```\n\n```js\n// 编译生成的渲染函数是一个匿名函数\nfunction anonymous() {\n  with(this) {\n    return _c('div',\n      { attrs: {\"id\": \"foo\" }},\n      { _v(\"\\n      \"+s_(name)+\"\\n    \")}\n    )\n  }\n}\n```\n\n经编译生成后的渲染函数会被挂载至对应 vm 组件实例的 `$options.render` 属性下。\n\n这里也解开了绑定的数据字段是如何和在哪里触发 getter 和 setter 的了。\n\n下面我们谈谈渲染函数与依赖追踪关系。\n\n## 追踪依赖及响应变化\n\n在 Vue 创建过程中，渲染视图的入口为 `_init` 函数中执行 vm 实例对象的 `$mount` 函数。对于每个组件而言，它都会执行组件的 `$mount` 方法，而不同编译版本的 `$mount` 执行的落脚点都是 mountComponent 函数。\n\nmountComponent 函数内部定义了一个 [updateComponent](https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L169-L192) 函数，而 updateComponent 函数的内部以 `vm._render()` 函数的返回值作为第一个参数调用 `vm._update()` 函数。此处我们只需简单地认为：\n\n- `vm._render` 函数的作用就是根据渲染函数（`vm.$options.render`）返回生成的虚拟节点\n- `vm._update` 函数的作用就是把 `vm._render` 函数生成的虚拟节点渲染成真正的 DOM 节点\n\n因此，对于 updateComponent 而言，我们可以把它理解为把虚拟 DOM 转化为真实 DOM 的过程。\n\n在 [mountComponet](https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L141-L213) 函数内部除了定义从虚拟 DOM 到真实 DOM 的执行函数外，还把 updateComponent 作为第一参数传入实例化的 Watcher 中。\n\n此时的 [Watcher 实例对象](https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L197-L203)被称为 render watcher（亦即<span style=\"color:red;font-weight:bold\">渲染函数的观察者</span>）。而实例化过程中 Watcher 会对 updateComponent 函数求值，而 updateComponent 函数的执行会间接触发渲染函数（`vm.$options.render`）的执行，而渲染函数的执行则会触发数据字段（包括 data、props 或 computed 等配置选项对象的子孙属性）的 get 拦截器函数，进而将该 render watcher 收集到依赖容器内，也就 dep 实例对象中的 subs 数组中，从而实现**依赖收集**。这个 dep 实例对象属于数据字段自身所持有，这样当我们尝试修改相应数据字段的值的时候，程序会触发数据字段的 set 拦截器函数里的 dep.notify，从而触发 render watcher 的 update，然后执行其 run 方法，执行过程最终会调用 updateComponent 方法，该方法会重新进行视图渲染。这样触发 set 拦截函数并通过一系列操作后更新视图的过程称为**派发更新**。\n\n追踪依赖示意流程图：\n\n由于 mountComponent 作为数据更新视图的函数，那么肯定是频繁调用的，换言之函数内部会不断重复实例化 Watcher，但实际上对于数据表达式的依赖追踪不必重复执行该流程。在 Watcher 实例内部通过唯一标识区分 watcher 实例，并以标识集合作为区分依据，避免了**一次求值过程中收集重复依赖**以及**多次求值收集重复依赖**两类问题。\n\n## 计算属性\n\n计算属性 computed 在 [initComputed](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L169-L208) 函数中构建。\n\n对于 computed 计算属性而言，实际上会在内部创建一个 computed watcher，每个 computed watcher 会持有一个 Dep 实例，当我们访问 computed 属性的时候，会调用 computed watcher 的 [evaluate](https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js#L210-L213) 方法，这时候会触发其持有的 depend 方法用于收集依赖，同时也会收集到正在计算的 watcher，然后把它计算的 watcher 作为 Dep 的 Subscriber 订阅者收集起来，收集起来的作用就是当计算属性所依赖的值发生变化以后，会触发 computed watcher 重新计算，如果重新计算过程中计算结果变了也会调用 dep 的 notify 方法，然后通知订阅 computed 的订阅者触发相关的更新。这类 watcher 有个特点：当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性，这类 watcher 的 expression 是计算属性的中的属性名。\n\n## 侦听属性\n\n侦听属性 watch 在 [Vue.prototype.\\$watch](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L303-L317) 函数中构建。\n\n对于配置的 watch 数据对象而言，会实现基于 Watcher 的封装并创建 user watcher，可以理解为用户的 watcher，也就是由开发者自定义的回调函数，它可以观察 data 的变化，也可以观察 computed 的变化。当这些数据发生变化以后，会通知这个该 watch 数据对象的 Dep 实例然后调用这个 Dep 实例去遍历所有 user watchers，然后调用它们的 update 方法，然后求值发生新旧值变化就会触发 run 执行用户定义的回调函数（user callback）。\n\n## 收获\n\n- 对 Vue 处理配置选项的数据字段与视图数据绑定的工作流程以及响应式系统的工作流程有完整的认识，加深了解相关配置或 API 的 What 和 Why，定位框架相关问题的时候更快速\n- 学会了很多编码层面的优化方式，根据流程避开非最佳的写法，让框架以最短路径完成双向绑定的工作，尽管以现时 JavaScript 引擎的性能而言，这些优化显得微不足道，但追求极致的代码书写应该是每个工程师应该具备的素养\n- 在了解甚至读懂源码实现原理的前提下，若遇到技术选型或缺陷治理等情况，与他人协商的沟通成本能大幅下降，最重要的是暗中观察业界大佬在讨论问题时起码不会再一脸懵逼。\n\n## Todo\n\n- Vue 初始化流程：Vue API 挂载流程以及实现原理，读懂这部分源码应该对业务实践帮助很大\n- 模版编译，结合编译相关 Babel 以及 JSX 编译实现，探索前端编译实现方式\n- 研究 Virtual DOM 的算法与实现，并与 React 实现的 Virtual DOM 作比较\n\n## 参考资料\n\n- [Vue 官方中文网](https://cn.vuejs.org/)\n  - [深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html)\n  - [渲染函数](https://cn.vuejs.org/v2/guide/render-function.html)\n- [Vue 技术内幕](http://hcysun.me/vue-design/)\n  - [揭开数据响应系统的面纱](http://hcysun.me/vue-design/art/7vue-reactive.html)\n  - [渲染函数的观察者与进阶的数据响应系统](http://hcysun.me/vue-design/art/8vue-reactive-dep-watch.html)\n- [Vue 技术揭秘 - 深入响应式原理](https://ustbhuangyi.github.io/vue-analysis/reactive/)\n- [Vue 双向数据绑定原理分析](https://zhuanlan.zhihu.com/p/21706165?utm_source=wechat_session&utm_medium=social&utm_oi=58000878338048)\n","source":"_posts/analysis-of-vue-responsive-systrm.md","raw":"---\ntitle: Vue 响应式系统实现探究\ndate: '2019-07-04'\n---\n\n对 Vue 的响应式原理的实现分析似乎已经是前端界烂大街的话题，尽管如此，在对 Vue 源码研究了一周之后还是想尝试用自己的语言把整个实现原理记录下来。\n\n这份研究**不会对源码作逐行解读**，只会对响应式系统的流程中 Vue 对不同情况的处理方式以及数据的流向叙述清楚。\n\n开局借用 [ustbhuangyi](https://github.com/ustbhuangyi) 的一张图，对整个响应式系统有个宏观的概念。\n\nVue 的响应式原理的核心就是观察这些数据，包括 data、props、computed 和 watch 的变化，当这些数据发生变化以后，能通知到对应的观察者（Watcher）以实现相关的逻辑，从而驱动视图的更新。整个响应式原理最核心的实现就是 Dep 类（语义为依赖 Dependency），这个类实际上是连接**数据对象**与**观察者**的桥梁。\n\n![Vue Reactive](http://img.mrsingsing.com/vue-reactive-workflow.png)\n\n<!-- more -->\n\n## 双向绑定\n\n在 Vue 初始化阶段，会对传入构造函数的配置对象根据不同的选项作相关的处理。\n\n对于 data 和 props 而言，Vue 会通过 observe 和 defineReactive 等一系列的操作把 data 和 props 的每个属性变成响应式属性。\n\n在初始化 data 过程中，data 数据对象经由 observe 以参数形式传入 Observer 类的构造函数。在实例化过程中，Observer 会根据 data 的数据类型执行相关的操作。\n\n- 若 data 为**数组类型**，Observer 会改写该数组原型中的变异方法（Mutation Method），包括 push、pop、shift、unshift、splice、sort 和 revers 共七个方法，这么做的目的是解决使用这些方法的原生实现会无法监测数据的变化的问题。随后，会遍历数组成员并逐个执行 observe 函数，这样就实现了通过递归的方式监测多维数组中的每个成员的数据变化。\n- 若 data 或递归数组成员为**对象类型**，则会遍历并调用 defineReactive 函数。\n\n而在初始化 props 时，经过 vm 实例键名的重名校验后，同样也是遍历调用 [defineReactive](https://github.com/vuejs/vue/blob/3b8925bc7973bb71b33374281db10a945ca9854e/src/core/observer/index.js#L132-L194) 函数。\n\ndefineReactive 函数是对数据进行双向绑定（或称为响应式化）的核心。\n\ndefineReactive 函数内部先实例化一个 [Dep](https://github.com/vuejs/vue/blob/3b8925bc79/src/core/observer/dep.js#L9-L50) 类，该类的建立是搭建起数据与 Watcher 的桥梁，同时也作为收集和存储 Watcher 的容器。随后，通过 Object.defineProperty 方法改写监测的数据字段的 get 函数和 set 函数。当我们访问监测的数据字段的时候，会触发 get 函数，get 函数内部和 set 函数内部都引用了在上层作用域中对 Dep 类实例化的常量 dep 实例对象。这里巧妙地运用了闭包的原理，以确保每个数据字段在访问和修改时都引用着属于自己的 dep 常量。get 函数会执行 dep 的 depend 方法用于<span style=\"color:red;font-weight:bold\">收集依赖</span>，这些依赖是当前正在计算的 Watcher，并最终经由 watcher 的 addDep 和 dep 的 addSub 添加到 dep 实例中的 subs 数组中（subs 意为 Subscriber 订阅者，该数组可以理解为依赖收集的存储容器）。而当修改数据（执行 set 函数）的时候，会触发 dep 的 notify 方法遍历 subs 数组中的依赖（也就是 watcher 实例）并调用它们原型上的 update 方法和 run 方法，最终通知这些订阅者执行<span style=\"color:red;font-weight:bold\">派发更新</span>的逻辑。这两个函数背后的执行路径在 dep 实例和 watcher 实例之间穿梭，这样实现的目的从源码分析来看，是为了区分不同的 Watcher（有 renderWatcher、computedWatcher 和 userWatcher，后面会提及）以及作相应的性能优化（譬如避免重复收集依赖或基于组件层级作缓存处理等）。\n\n总结 get 函数和 set 函数的触发时机，以及其职能功用：\n\n- get 函数在**访问**数据字段时触发，其主要职能是**获取监测数据字段的值**并触发 Watcher 的**依赖收集**。\n- set 函数在对数据字段**修改**时触发，主要职责是**对新的赋值进行响应式化**以及向 Watcher **派发更新**，从而触发视图的重渲染。\n\n谈到这里肯定会有个疑问， get 函数所收集的依赖具体是什么？依赖是如何被收集的？set 函数是如何通知所有的 Watcher 更新的？派发更新的过程究竟做了什么？这些疑问都在下节揭晓。\n\n## 渲染函数\n\n在谈及依赖的追踪和触发前，我们有必要先了解 **「依赖」** 这个那么虚的名词用 JavaScript 语言怎么描述。\n\n谈及双向数据绑定，这里所指的双向指的就是 Data 到 View 以及 View 到 Data 的结合。体现在我们的代码中，就是 Vue 的配置选项即为 Data 的储存容器，而 template 即为概念上的 View。我们知道浏览器在读取 JavaScript 脚本文件后必然经历 DOM 操作方可将相关数据渲染到 DOM 树中，比如使用字符串模版 innerHTML 或通过 appendChild、insertBefore 等 DOM 节点操作插入。\n\n在 Vue 中，模版 template 会经由 Compiler 被编译成渲染函数（Render Function），以下以直观的感受体验模版和渲染函数的表现形式。\n\n```html\n<div id=\"foo\">\n  <p>{{name}}</p>\n</div>\n```\n\n```js\n// 编译生成的渲染函数是一个匿名函数\nfunction anonymous() {\n  with(this) {\n    return _c('div',\n      { attrs: {\"id\": \"foo\" }},\n      { _v(\"\\n      \"+s_(name)+\"\\n    \")}\n    )\n  }\n}\n```\n\n经编译生成后的渲染函数会被挂载至对应 vm 组件实例的 `$options.render` 属性下。\n\n这里也解开了绑定的数据字段是如何和在哪里触发 getter 和 setter 的了。\n\n下面我们谈谈渲染函数与依赖追踪关系。\n\n## 追踪依赖及响应变化\n\n在 Vue 创建过程中，渲染视图的入口为 `_init` 函数中执行 vm 实例对象的 `$mount` 函数。对于每个组件而言，它都会执行组件的 `$mount` 方法，而不同编译版本的 `$mount` 执行的落脚点都是 mountComponent 函数。\n\nmountComponent 函数内部定义了一个 [updateComponent](https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L169-L192) 函数，而 updateComponent 函数的内部以 `vm._render()` 函数的返回值作为第一个参数调用 `vm._update()` 函数。此处我们只需简单地认为：\n\n- `vm._render` 函数的作用就是根据渲染函数（`vm.$options.render`）返回生成的虚拟节点\n- `vm._update` 函数的作用就是把 `vm._render` 函数生成的虚拟节点渲染成真正的 DOM 节点\n\n因此，对于 updateComponent 而言，我们可以把它理解为把虚拟 DOM 转化为真实 DOM 的过程。\n\n在 [mountComponet](https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L141-L213) 函数内部除了定义从虚拟 DOM 到真实 DOM 的执行函数外，还把 updateComponent 作为第一参数传入实例化的 Watcher 中。\n\n此时的 [Watcher 实例对象](https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L197-L203)被称为 render watcher（亦即<span style=\"color:red;font-weight:bold\">渲染函数的观察者</span>）。而实例化过程中 Watcher 会对 updateComponent 函数求值，而 updateComponent 函数的执行会间接触发渲染函数（`vm.$options.render`）的执行，而渲染函数的执行则会触发数据字段（包括 data、props 或 computed 等配置选项对象的子孙属性）的 get 拦截器函数，进而将该 render watcher 收集到依赖容器内，也就 dep 实例对象中的 subs 数组中，从而实现**依赖收集**。这个 dep 实例对象属于数据字段自身所持有，这样当我们尝试修改相应数据字段的值的时候，程序会触发数据字段的 set 拦截器函数里的 dep.notify，从而触发 render watcher 的 update，然后执行其 run 方法，执行过程最终会调用 updateComponent 方法，该方法会重新进行视图渲染。这样触发 set 拦截函数并通过一系列操作后更新视图的过程称为**派发更新**。\n\n追踪依赖示意流程图：\n\n由于 mountComponent 作为数据更新视图的函数，那么肯定是频繁调用的，换言之函数内部会不断重复实例化 Watcher，但实际上对于数据表达式的依赖追踪不必重复执行该流程。在 Watcher 实例内部通过唯一标识区分 watcher 实例，并以标识集合作为区分依据，避免了**一次求值过程中收集重复依赖**以及**多次求值收集重复依赖**两类问题。\n\n## 计算属性\n\n计算属性 computed 在 [initComputed](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L169-L208) 函数中构建。\n\n对于 computed 计算属性而言，实际上会在内部创建一个 computed watcher，每个 computed watcher 会持有一个 Dep 实例，当我们访问 computed 属性的时候，会调用 computed watcher 的 [evaluate](https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js#L210-L213) 方法，这时候会触发其持有的 depend 方法用于收集依赖，同时也会收集到正在计算的 watcher，然后把它计算的 watcher 作为 Dep 的 Subscriber 订阅者收集起来，收集起来的作用就是当计算属性所依赖的值发生变化以后，会触发 computed watcher 重新计算，如果重新计算过程中计算结果变了也会调用 dep 的 notify 方法，然后通知订阅 computed 的订阅者触发相关的更新。这类 watcher 有个特点：当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性，这类 watcher 的 expression 是计算属性的中的属性名。\n\n## 侦听属性\n\n侦听属性 watch 在 [Vue.prototype.\\$watch](https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L303-L317) 函数中构建。\n\n对于配置的 watch 数据对象而言，会实现基于 Watcher 的封装并创建 user watcher，可以理解为用户的 watcher，也就是由开发者自定义的回调函数，它可以观察 data 的变化，也可以观察 computed 的变化。当这些数据发生变化以后，会通知这个该 watch 数据对象的 Dep 实例然后调用这个 Dep 实例去遍历所有 user watchers，然后调用它们的 update 方法，然后求值发生新旧值变化就会触发 run 执行用户定义的回调函数（user callback）。\n\n## 收获\n\n- 对 Vue 处理配置选项的数据字段与视图数据绑定的工作流程以及响应式系统的工作流程有完整的认识，加深了解相关配置或 API 的 What 和 Why，定位框架相关问题的时候更快速\n- 学会了很多编码层面的优化方式，根据流程避开非最佳的写法，让框架以最短路径完成双向绑定的工作，尽管以现时 JavaScript 引擎的性能而言，这些优化显得微不足道，但追求极致的代码书写应该是每个工程师应该具备的素养\n- 在了解甚至读懂源码实现原理的前提下，若遇到技术选型或缺陷治理等情况，与他人协商的沟通成本能大幅下降，最重要的是暗中观察业界大佬在讨论问题时起码不会再一脸懵逼。\n\n## Todo\n\n- Vue 初始化流程：Vue API 挂载流程以及实现原理，读懂这部分源码应该对业务实践帮助很大\n- 模版编译，结合编译相关 Babel 以及 JSX 编译实现，探索前端编译实现方式\n- 研究 Virtual DOM 的算法与实现，并与 React 实现的 Virtual DOM 作比较\n\n## 参考资料\n\n- [Vue 官方中文网](https://cn.vuejs.org/)\n  - [深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html)\n  - [渲染函数](https://cn.vuejs.org/v2/guide/render-function.html)\n- [Vue 技术内幕](http://hcysun.me/vue-design/)\n  - [揭开数据响应系统的面纱](http://hcysun.me/vue-design/art/7vue-reactive.html)\n  - [渲染函数的观察者与进阶的数据响应系统](http://hcysun.me/vue-design/art/8vue-reactive-dep-watch.html)\n- [Vue 技术揭秘 - 深入响应式原理](https://ustbhuangyi.github.io/vue-analysis/reactive/)\n- [Vue 双向数据绑定原理分析](https://zhuanlan.zhihu.com/p/21706165?utm_source=wechat_session&utm_medium=social&utm_oi=58000878338048)\n","slug":"analysis-of-vue-responsive-systrm","published":1,"updated":"2021-08-18T06:38:12.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99ym0000v31pm45hr2iy","content":"<p>对 Vue 的响应式原理的实现分析似乎已经是前端界烂大街的话题，尽管如此，在对 Vue 源码研究了一周之后还是想尝试用自己的语言把整个实现原理记录下来。</p>\n<p>这份研究<strong>不会对源码作逐行解读</strong>，只会对响应式系统的流程中 Vue 对不同情况的处理方式以及数据的流向叙述清楚。</p>\n<p>开局借用 <a href=\"https://github.com/ustbhuangyi\" target=\"_blank\" rel=\"noopener\">ustbhuangyi</a> 的一张图，对整个响应式系统有个宏观的概念。</p>\n<p>Vue 的响应式原理的核心就是观察这些数据，包括 data、props、computed 和 watch 的变化，当这些数据发生变化以后，能通知到对应的观察者（Watcher）以实现相关的逻辑，从而驱动视图的更新。整个响应式原理最核心的实现就是 Dep 类（语义为依赖 Dependency），这个类实际上是连接<strong>数据对象</strong>与<strong>观察者</strong>的桥梁。</p>\n<p><img src=\"http://img.mrsingsing.com/vue-reactive-workflow.png\" alt=\"Vue Reactive\"></p>\n<a id=\"more\"></a>\n<h2 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h2><p>在 Vue 初始化阶段，会对传入构造函数的配置对象根据不同的选项作相关的处理。</p>\n<p>对于 data 和 props 而言，Vue 会通过 observe 和 defineReactive 等一系列的操作把 data 和 props 的每个属性变成响应式属性。</p>\n<p>在初始化 data 过程中，data 数据对象经由 observe 以参数形式传入 Observer 类的构造函数。在实例化过程中，Observer 会根据 data 的数据类型执行相关的操作。</p>\n<ul>\n<li>若 data 为<strong>数组类型</strong>，Observer 会改写该数组原型中的变异方法（Mutation Method），包括 push、pop、shift、unshift、splice、sort 和 revers 共七个方法，这么做的目的是解决使用这些方法的原生实现会无法监测数据的变化的问题。随后，会遍历数组成员并逐个执行 observe 函数，这样就实现了通过递归的方式监测多维数组中的每个成员的数据变化。</li>\n<li>若 data 或递归数组成员为<strong>对象类型</strong>，则会遍历并调用 defineReactive 函数。</li>\n</ul>\n<p>而在初始化 props 时，经过 vm 实例键名的重名校验后，同样也是遍历调用 <a href=\"https://github.com/vuejs/vue/blob/3b8925bc7973bb71b33374281db10a945ca9854e/src/core/observer/index.js#L132-L194\" target=\"_blank\" rel=\"noopener\">defineReactive</a> 函数。</p>\n<p>defineReactive 函数是对数据进行双向绑定（或称为响应式化）的核心。</p>\n<p>defineReactive 函数内部先实例化一个 <a href=\"https://github.com/vuejs/vue/blob/3b8925bc79/src/core/observer/dep.js#L9-L50\" target=\"_blank\" rel=\"noopener\">Dep</a> 类，该类的建立是搭建起数据与 Watcher 的桥梁，同时也作为收集和存储 Watcher 的容器。随后，通过 Object.defineProperty 方法改写监测的数据字段的 get 函数和 set 函数。当我们访问监测的数据字段的时候，会触发 get 函数，get 函数内部和 set 函数内部都引用了在上层作用域中对 Dep 类实例化的常量 dep 实例对象。这里巧妙地运用了闭包的原理，以确保每个数据字段在访问和修改时都引用着属于自己的 dep 常量。get 函数会执行 dep 的 depend 方法用于<span style=\"color:red;font-weight:bold\">收集依赖</span>，这些依赖是当前正在计算的 Watcher，并最终经由 watcher 的 addDep 和 dep 的 addSub 添加到 dep 实例中的 subs 数组中（subs 意为 Subscriber 订阅者，该数组可以理解为依赖收集的存储容器）。而当修改数据（执行 set 函数）的时候，会触发 dep 的 notify 方法遍历 subs 数组中的依赖（也就是 watcher 实例）并调用它们原型上的 update 方法和 run 方法，最终通知这些订阅者执行<span style=\"color:red;font-weight:bold\">派发更新</span>的逻辑。这两个函数背后的执行路径在 dep 实例和 watcher 实例之间穿梭，这样实现的目的从源码分析来看，是为了区分不同的 Watcher（有 renderWatcher、computedWatcher 和 userWatcher，后面会提及）以及作相应的性能优化（譬如避免重复收集依赖或基于组件层级作缓存处理等）。</p>\n<p>总结 get 函数和 set 函数的触发时机，以及其职能功用：</p>\n<ul>\n<li>get 函数在<strong>访问</strong>数据字段时触发，其主要职能是<strong>获取监测数据字段的值</strong>并触发 Watcher 的<strong>依赖收集</strong>。</li>\n<li>set 函数在对数据字段<strong>修改</strong>时触发，主要职责是<strong>对新的赋值进行响应式化</strong>以及向 Watcher <strong>派发更新</strong>，从而触发视图的重渲染。</li>\n</ul>\n<p>谈到这里肯定会有个疑问， get 函数所收集的依赖具体是什么？依赖是如何被收集的？set 函数是如何通知所有的 Watcher 更新的？派发更新的过程究竟做了什么？这些疑问都在下节揭晓。</p>\n<h2 id=\"渲染函数\"><a href=\"#渲染函数\" class=\"headerlink\" title=\"渲染函数\"></a>渲染函数</h2><p>在谈及依赖的追踪和触发前，我们有必要先了解 <strong>「依赖」</strong> 这个那么虚的名词用 JavaScript 语言怎么描述。</p>\n<p>谈及双向数据绑定，这里所指的双向指的就是 Data 到 View 以及 View 到 Data 的结合。体现在我们的代码中，就是 Vue 的配置选项即为 Data 的储存容器，而 template 即为概念上的 View。我们知道浏览器在读取 JavaScript 脚本文件后必然经历 DOM 操作方可将相关数据渲染到 DOM 树中，比如使用字符串模版 innerHTML 或通过 appendChild、insertBefore 等 DOM 节点操作插入。</p>\n<p>在 Vue 中，模版 template 会经由 Compiler 被编译成渲染函数（Render Function），以下以直观的感受体验模版和渲染函数的表现形式。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"foo\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译生成的渲染函数是一个匿名函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">anonymous</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">with</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _c(<span class=\"string\">'div'</span>,</span><br><span class=\"line\">      &#123; <span class=\"attr\">attrs</span>: &#123;<span class=\"string\">\"id\"</span>: <span class=\"string\">\"foo\"</span> &#125;&#125;,</span><br><span class=\"line\">      &#123; _v(<span class=\"string\">\"\\n      \"</span>+s_(name)+<span class=\"string\">\"\\n    \"</span>)&#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经编译生成后的渲染函数会被挂载至对应 vm 组件实例的 <code>$options.render</code> 属性下。</p>\n<p>这里也解开了绑定的数据字段是如何和在哪里触发 getter 和 setter 的了。</p>\n<p>下面我们谈谈渲染函数与依赖追踪关系。</p>\n<h2 id=\"追踪依赖及响应变化\"><a href=\"#追踪依赖及响应变化\" class=\"headerlink\" title=\"追踪依赖及响应变化\"></a>追踪依赖及响应变化</h2><p>在 Vue 创建过程中，渲染视图的入口为 <code>_init</code> 函数中执行 vm 实例对象的 <code>$mount</code> 函数。对于每个组件而言，它都会执行组件的 <code>$mount</code> 方法，而不同编译版本的 <code>$mount</code> 执行的落脚点都是 mountComponent 函数。</p>\n<p>mountComponent 函数内部定义了一个 <a href=\"https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L169-L192\" target=\"_blank\" rel=\"noopener\">updateComponent</a> 函数，而 updateComponent 函数的内部以 <code>vm._render()</code> 函数的返回值作为第一个参数调用 <code>vm._update()</code> 函数。此处我们只需简单地认为：</p>\n<ul>\n<li><code>vm._render</code> 函数的作用就是根据渲染函数（<code>vm.$options.render</code>）返回生成的虚拟节点</li>\n<li><code>vm._update</code> 函数的作用就是把 <code>vm._render</code> 函数生成的虚拟节点渲染成真正的 DOM 节点</li>\n</ul>\n<p>因此，对于 updateComponent 而言，我们可以把它理解为把虚拟 DOM 转化为真实 DOM 的过程。</p>\n<p>在 <a href=\"https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L141-L213\" target=\"_blank\" rel=\"noopener\">mountComponet</a> 函数内部除了定义从虚拟 DOM 到真实 DOM 的执行函数外，还把 updateComponent 作为第一参数传入实例化的 Watcher 中。</p>\n<p>此时的 <a href=\"https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L197-L203\" target=\"_blank\" rel=\"noopener\">Watcher 实例对象</a>被称为 render watcher（亦即<span style=\"color:red;font-weight:bold\">渲染函数的观察者</span>）。而实例化过程中 Watcher 会对 updateComponent 函数求值，而 updateComponent 函数的执行会间接触发渲染函数（<code>vm.$options.render</code>）的执行，而渲染函数的执行则会触发数据字段（包括 data、props 或 computed 等配置选项对象的子孙属性）的 get 拦截器函数，进而将该 render watcher 收集到依赖容器内，也就 dep 实例对象中的 subs 数组中，从而实现<strong>依赖收集</strong>。这个 dep 实例对象属于数据字段自身所持有，这样当我们尝试修改相应数据字段的值的时候，程序会触发数据字段的 set 拦截器函数里的 dep.notify，从而触发 render watcher 的 update，然后执行其 run 方法，执行过程最终会调用 updateComponent 方法，该方法会重新进行视图渲染。这样触发 set 拦截函数并通过一系列操作后更新视图的过程称为<strong>派发更新</strong>。</p>\n<p>追踪依赖示意流程图：</p>\n<p>由于 mountComponent 作为数据更新视图的函数，那么肯定是频繁调用的，换言之函数内部会不断重复实例化 Watcher，但实际上对于数据表达式的依赖追踪不必重复执行该流程。在 Watcher 实例内部通过唯一标识区分 watcher 实例，并以标识集合作为区分依据，避免了<strong>一次求值过程中收集重复依赖</strong>以及<strong>多次求值收集重复依赖</strong>两类问题。</p>\n<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>计算属性 computed 在 <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L169-L208\" target=\"_blank\" rel=\"noopener\">initComputed</a> 函数中构建。</p>\n<p>对于 computed 计算属性而言，实际上会在内部创建一个 computed watcher，每个 computed watcher 会持有一个 Dep 实例，当我们访问 computed 属性的时候，会调用 computed watcher 的 <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js#L210-L213\" target=\"_blank\" rel=\"noopener\">evaluate</a> 方法，这时候会触发其持有的 depend 方法用于收集依赖，同时也会收集到正在计算的 watcher，然后把它计算的 watcher 作为 Dep 的 Subscriber 订阅者收集起来，收集起来的作用就是当计算属性所依赖的值发生变化以后，会触发 computed watcher 重新计算，如果重新计算过程中计算结果变了也会调用 dep 的 notify 方法，然后通知订阅 computed 的订阅者触发相关的更新。这类 watcher 有个特点：当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性，这类 watcher 的 expression 是计算属性的中的属性名。</p>\n<h2 id=\"侦听属性\"><a href=\"#侦听属性\" class=\"headerlink\" title=\"侦听属性\"></a>侦听属性</h2><p>侦听属性 watch 在 <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L303-L317\" target=\"_blank\" rel=\"noopener\">Vue.prototype.\\$watch</a> 函数中构建。</p>\n<p>对于配置的 watch 数据对象而言，会实现基于 Watcher 的封装并创建 user watcher，可以理解为用户的 watcher，也就是由开发者自定义的回调函数，它可以观察 data 的变化，也可以观察 computed 的变化。当这些数据发生变化以后，会通知这个该 watch 数据对象的 Dep 实例然后调用这个 Dep 实例去遍历所有 user watchers，然后调用它们的 update 方法，然后求值发生新旧值变化就会触发 run 执行用户定义的回调函数（user callback）。</p>\n<h2 id=\"收获\"><a href=\"#收获\" class=\"headerlink\" title=\"收获\"></a>收获</h2><ul>\n<li>对 Vue 处理配置选项的数据字段与视图数据绑定的工作流程以及响应式系统的工作流程有完整的认识，加深了解相关配置或 API 的 What 和 Why，定位框架相关问题的时候更快速</li>\n<li>学会了很多编码层面的优化方式，根据流程避开非最佳的写法，让框架以最短路径完成双向绑定的工作，尽管以现时 JavaScript 引擎的性能而言，这些优化显得微不足道，但追求极致的代码书写应该是每个工程师应该具备的素养</li>\n<li>在了解甚至读懂源码实现原理的前提下，若遇到技术选型或缺陷治理等情况，与他人协商的沟通成本能大幅下降，最重要的是暗中观察业界大佬在讨论问题时起码不会再一脸懵逼。</li>\n</ul>\n<h2 id=\"Todo\"><a href=\"#Todo\" class=\"headerlink\" title=\"Todo\"></a>Todo</h2><ul>\n<li>Vue 初始化流程：Vue API 挂载流程以及实现原理，读懂这部分源码应该对业务实践帮助很大</li>\n<li>模版编译，结合编译相关 Babel 以及 JSX 编译实现，探索前端编译实现方式</li>\n<li>研究 Virtual DOM 的算法与实现，并与 React 实现的 Virtual DOM 作比较</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue 官方中文网</a><ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/reactivity.html\" target=\"_blank\" rel=\"noopener\">深入响应式原理</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/render-function.html\" target=\"_blank\" rel=\"noopener\">渲染函数</a></li>\n</ul>\n</li>\n<li><a href=\"http://hcysun.me/vue-design/\" target=\"_blank\" rel=\"noopener\">Vue 技术内幕</a><ul>\n<li><a href=\"http://hcysun.me/vue-design/art/7vue-reactive.html\" target=\"_blank\" rel=\"noopener\">揭开数据响应系统的面纱</a></li>\n<li><a href=\"http://hcysun.me/vue-design/art/8vue-reactive-dep-watch.html\" target=\"_blank\" rel=\"noopener\">渲染函数的观察者与进阶的数据响应系统</a></li>\n</ul>\n</li>\n<li><a href=\"https://ustbhuangyi.github.io/vue-analysis/reactive/\" target=\"_blank\" rel=\"noopener\">Vue 技术揭秘 - 深入响应式原理</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/21706165?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=58000878338048\" target=\"_blank\" rel=\"noopener\">Vue 双向数据绑定原理分析</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>对 Vue 的响应式原理的实现分析似乎已经是前端界烂大街的话题，尽管如此，在对 Vue 源码研究了一周之后还是想尝试用自己的语言把整个实现原理记录下来。</p>\n<p>这份研究<strong>不会对源码作逐行解读</strong>，只会对响应式系统的流程中 Vue 对不同情况的处理方式以及数据的流向叙述清楚。</p>\n<p>开局借用 <a href=\"https://github.com/ustbhuangyi\" target=\"_blank\" rel=\"noopener\">ustbhuangyi</a> 的一张图，对整个响应式系统有个宏观的概念。</p>\n<p>Vue 的响应式原理的核心就是观察这些数据，包括 data、props、computed 和 watch 的变化，当这些数据发生变化以后，能通知到对应的观察者（Watcher）以实现相关的逻辑，从而驱动视图的更新。整个响应式原理最核心的实现就是 Dep 类（语义为依赖 Dependency），这个类实际上是连接<strong>数据对象</strong>与<strong>观察者</strong>的桥梁。</p>\n<p><img src=\"http://img.mrsingsing.com/vue-reactive-workflow.png\" alt=\"Vue Reactive\"></p>","more":"<h2 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h2><p>在 Vue 初始化阶段，会对传入构造函数的配置对象根据不同的选项作相关的处理。</p>\n<p>对于 data 和 props 而言，Vue 会通过 observe 和 defineReactive 等一系列的操作把 data 和 props 的每个属性变成响应式属性。</p>\n<p>在初始化 data 过程中，data 数据对象经由 observe 以参数形式传入 Observer 类的构造函数。在实例化过程中，Observer 会根据 data 的数据类型执行相关的操作。</p>\n<ul>\n<li>若 data 为<strong>数组类型</strong>，Observer 会改写该数组原型中的变异方法（Mutation Method），包括 push、pop、shift、unshift、splice、sort 和 revers 共七个方法，这么做的目的是解决使用这些方法的原生实现会无法监测数据的变化的问题。随后，会遍历数组成员并逐个执行 observe 函数，这样就实现了通过递归的方式监测多维数组中的每个成员的数据变化。</li>\n<li>若 data 或递归数组成员为<strong>对象类型</strong>，则会遍历并调用 defineReactive 函数。</li>\n</ul>\n<p>而在初始化 props 时，经过 vm 实例键名的重名校验后，同样也是遍历调用 <a href=\"https://github.com/vuejs/vue/blob/3b8925bc7973bb71b33374281db10a945ca9854e/src/core/observer/index.js#L132-L194\" target=\"_blank\" rel=\"noopener\">defineReactive</a> 函数。</p>\n<p>defineReactive 函数是对数据进行双向绑定（或称为响应式化）的核心。</p>\n<p>defineReactive 函数内部先实例化一个 <a href=\"https://github.com/vuejs/vue/blob/3b8925bc79/src/core/observer/dep.js#L9-L50\" target=\"_blank\" rel=\"noopener\">Dep</a> 类，该类的建立是搭建起数据与 Watcher 的桥梁，同时也作为收集和存储 Watcher 的容器。随后，通过 Object.defineProperty 方法改写监测的数据字段的 get 函数和 set 函数。当我们访问监测的数据字段的时候，会触发 get 函数，get 函数内部和 set 函数内部都引用了在上层作用域中对 Dep 类实例化的常量 dep 实例对象。这里巧妙地运用了闭包的原理，以确保每个数据字段在访问和修改时都引用着属于自己的 dep 常量。get 函数会执行 dep 的 depend 方法用于<span style=\"color:red;font-weight:bold\">收集依赖</span>，这些依赖是当前正在计算的 Watcher，并最终经由 watcher 的 addDep 和 dep 的 addSub 添加到 dep 实例中的 subs 数组中（subs 意为 Subscriber 订阅者，该数组可以理解为依赖收集的存储容器）。而当修改数据（执行 set 函数）的时候，会触发 dep 的 notify 方法遍历 subs 数组中的依赖（也就是 watcher 实例）并调用它们原型上的 update 方法和 run 方法，最终通知这些订阅者执行<span style=\"color:red;font-weight:bold\">派发更新</span>的逻辑。这两个函数背后的执行路径在 dep 实例和 watcher 实例之间穿梭，这样实现的目的从源码分析来看，是为了区分不同的 Watcher（有 renderWatcher、computedWatcher 和 userWatcher，后面会提及）以及作相应的性能优化（譬如避免重复收集依赖或基于组件层级作缓存处理等）。</p>\n<p>总结 get 函数和 set 函数的触发时机，以及其职能功用：</p>\n<ul>\n<li>get 函数在<strong>访问</strong>数据字段时触发，其主要职能是<strong>获取监测数据字段的值</strong>并触发 Watcher 的<strong>依赖收集</strong>。</li>\n<li>set 函数在对数据字段<strong>修改</strong>时触发，主要职责是<strong>对新的赋值进行响应式化</strong>以及向 Watcher <strong>派发更新</strong>，从而触发视图的重渲染。</li>\n</ul>\n<p>谈到这里肯定会有个疑问， get 函数所收集的依赖具体是什么？依赖是如何被收集的？set 函数是如何通知所有的 Watcher 更新的？派发更新的过程究竟做了什么？这些疑问都在下节揭晓。</p>\n<h2 id=\"渲染函数\"><a href=\"#渲染函数\" class=\"headerlink\" title=\"渲染函数\"></a>渲染函数</h2><p>在谈及依赖的追踪和触发前，我们有必要先了解 <strong>「依赖」</strong> 这个那么虚的名词用 JavaScript 语言怎么描述。</p>\n<p>谈及双向数据绑定，这里所指的双向指的就是 Data 到 View 以及 View 到 Data 的结合。体现在我们的代码中，就是 Vue 的配置选项即为 Data 的储存容器，而 template 即为概念上的 View。我们知道浏览器在读取 JavaScript 脚本文件后必然经历 DOM 操作方可将相关数据渲染到 DOM 树中，比如使用字符串模版 innerHTML 或通过 appendChild、insertBefore 等 DOM 节点操作插入。</p>\n<p>在 Vue 中，模版 template 会经由 Compiler 被编译成渲染函数（Render Function），以下以直观的感受体验模版和渲染函数的表现形式。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"foo\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译生成的渲染函数是一个匿名函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">anonymous</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">with</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _c(<span class=\"string\">'div'</span>,</span><br><span class=\"line\">      &#123; <span class=\"attr\">attrs</span>: &#123;<span class=\"string\">\"id\"</span>: <span class=\"string\">\"foo\"</span> &#125;&#125;,</span><br><span class=\"line\">      &#123; _v(<span class=\"string\">\"\\n      \"</span>+s_(name)+<span class=\"string\">\"\\n    \"</span>)&#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经编译生成后的渲染函数会被挂载至对应 vm 组件实例的 <code>$options.render</code> 属性下。</p>\n<p>这里也解开了绑定的数据字段是如何和在哪里触发 getter 和 setter 的了。</p>\n<p>下面我们谈谈渲染函数与依赖追踪关系。</p>\n<h2 id=\"追踪依赖及响应变化\"><a href=\"#追踪依赖及响应变化\" class=\"headerlink\" title=\"追踪依赖及响应变化\"></a>追踪依赖及响应变化</h2><p>在 Vue 创建过程中，渲染视图的入口为 <code>_init</code> 函数中执行 vm 实例对象的 <code>$mount</code> 函数。对于每个组件而言，它都会执行组件的 <code>$mount</code> 方法，而不同编译版本的 <code>$mount</code> 执行的落脚点都是 mountComponent 函数。</p>\n<p>mountComponent 函数内部定义了一个 <a href=\"https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L169-L192\" target=\"_blank\" rel=\"noopener\">updateComponent</a> 函数，而 updateComponent 函数的内部以 <code>vm._render()</code> 函数的返回值作为第一个参数调用 <code>vm._update()</code> 函数。此处我们只需简单地认为：</p>\n<ul>\n<li><code>vm._render</code> 函数的作用就是根据渲染函数（<code>vm.$options.render</code>）返回生成的虚拟节点</li>\n<li><code>vm._update</code> 函数的作用就是把 <code>vm._render</code> 函数生成的虚拟节点渲染成真正的 DOM 节点</li>\n</ul>\n<p>因此，对于 updateComponent 而言，我们可以把它理解为把虚拟 DOM 转化为真实 DOM 的过程。</p>\n<p>在 <a href=\"https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L141-L213\" target=\"_blank\" rel=\"noopener\">mountComponet</a> 函数内部除了定义从虚拟 DOM 到真实 DOM 的执行函数外，还把 updateComponent 作为第一参数传入实例化的 Watcher 中。</p>\n<p>此时的 <a href=\"https://github.com/vuejs/vue/blob/d9b27a92bd5277ee23a4e68a8bd31ecc72f4c99b/src/core/instance/lifecycle.js#L197-L203\" target=\"_blank\" rel=\"noopener\">Watcher 实例对象</a>被称为 render watcher（亦即<span style=\"color:red;font-weight:bold\">渲染函数的观察者</span>）。而实例化过程中 Watcher 会对 updateComponent 函数求值，而 updateComponent 函数的执行会间接触发渲染函数（<code>vm.$options.render</code>）的执行，而渲染函数的执行则会触发数据字段（包括 data、props 或 computed 等配置选项对象的子孙属性）的 get 拦截器函数，进而将该 render watcher 收集到依赖容器内，也就 dep 实例对象中的 subs 数组中，从而实现<strong>依赖收集</strong>。这个 dep 实例对象属于数据字段自身所持有，这样当我们尝试修改相应数据字段的值的时候，程序会触发数据字段的 set 拦截器函数里的 dep.notify，从而触发 render watcher 的 update，然后执行其 run 方法，执行过程最终会调用 updateComponent 方法，该方法会重新进行视图渲染。这样触发 set 拦截函数并通过一系列操作后更新视图的过程称为<strong>派发更新</strong>。</p>\n<p>追踪依赖示意流程图：</p>\n<p>由于 mountComponent 作为数据更新视图的函数，那么肯定是频繁调用的，换言之函数内部会不断重复实例化 Watcher，但实际上对于数据表达式的依赖追踪不必重复执行该流程。在 Watcher 实例内部通过唯一标识区分 watcher 实例，并以标识集合作为区分依据，避免了<strong>一次求值过程中收集重复依赖</strong>以及<strong>多次求值收集重复依赖</strong>两类问题。</p>\n<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>计算属性 computed 在 <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L169-L208\" target=\"_blank\" rel=\"noopener\">initComputed</a> 函数中构建。</p>\n<p>对于 computed 计算属性而言，实际上会在内部创建一个 computed watcher，每个 computed watcher 会持有一个 Dep 实例，当我们访问 computed 属性的时候，会调用 computed watcher 的 <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js#L210-L213\" target=\"_blank\" rel=\"noopener\">evaluate</a> 方法，这时候会触发其持有的 depend 方法用于收集依赖，同时也会收集到正在计算的 watcher，然后把它计算的 watcher 作为 Dep 的 Subscriber 订阅者收集起来，收集起来的作用就是当计算属性所依赖的值发生变化以后，会触发 computed watcher 重新计算，如果重新计算过程中计算结果变了也会调用 dep 的 notify 方法，然后通知订阅 computed 的订阅者触发相关的更新。这类 watcher 有个特点：当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性，这类 watcher 的 expression 是计算属性的中的属性名。</p>\n<h2 id=\"侦听属性\"><a href=\"#侦听属性\" class=\"headerlink\" title=\"侦听属性\"></a>侦听属性</h2><p>侦听属性 watch 在 <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L303-L317\" target=\"_blank\" rel=\"noopener\">Vue.prototype.\\$watch</a> 函数中构建。</p>\n<p>对于配置的 watch 数据对象而言，会实现基于 Watcher 的封装并创建 user watcher，可以理解为用户的 watcher，也就是由开发者自定义的回调函数，它可以观察 data 的变化，也可以观察 computed 的变化。当这些数据发生变化以后，会通知这个该 watch 数据对象的 Dep 实例然后调用这个 Dep 实例去遍历所有 user watchers，然后调用它们的 update 方法，然后求值发生新旧值变化就会触发 run 执行用户定义的回调函数（user callback）。</p>\n<h2 id=\"收获\"><a href=\"#收获\" class=\"headerlink\" title=\"收获\"></a>收获</h2><ul>\n<li>对 Vue 处理配置选项的数据字段与视图数据绑定的工作流程以及响应式系统的工作流程有完整的认识，加深了解相关配置或 API 的 What 和 Why，定位框架相关问题的时候更快速</li>\n<li>学会了很多编码层面的优化方式，根据流程避开非最佳的写法，让框架以最短路径完成双向绑定的工作，尽管以现时 JavaScript 引擎的性能而言，这些优化显得微不足道，但追求极致的代码书写应该是每个工程师应该具备的素养</li>\n<li>在了解甚至读懂源码实现原理的前提下，若遇到技术选型或缺陷治理等情况，与他人协商的沟通成本能大幅下降，最重要的是暗中观察业界大佬在讨论问题时起码不会再一脸懵逼。</li>\n</ul>\n<h2 id=\"Todo\"><a href=\"#Todo\" class=\"headerlink\" title=\"Todo\"></a>Todo</h2><ul>\n<li>Vue 初始化流程：Vue API 挂载流程以及实现原理，读懂这部分源码应该对业务实践帮助很大</li>\n<li>模版编译，结合编译相关 Babel 以及 JSX 编译实现，探索前端编译实现方式</li>\n<li>研究 Virtual DOM 的算法与实现，并与 React 实现的 Virtual DOM 作比较</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue 官方中文网</a><ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/reactivity.html\" target=\"_blank\" rel=\"noopener\">深入响应式原理</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/render-function.html\" target=\"_blank\" rel=\"noopener\">渲染函数</a></li>\n</ul>\n</li>\n<li><a href=\"http://hcysun.me/vue-design/\" target=\"_blank\" rel=\"noopener\">Vue 技术内幕</a><ul>\n<li><a href=\"http://hcysun.me/vue-design/art/7vue-reactive.html\" target=\"_blank\" rel=\"noopener\">揭开数据响应系统的面纱</a></li>\n<li><a href=\"http://hcysun.me/vue-design/art/8vue-reactive-dep-watch.html\" target=\"_blank\" rel=\"noopener\">渲染函数的观察者与进阶的数据响应系统</a></li>\n</ul>\n</li>\n<li><a href=\"https://ustbhuangyi.github.io/vue-analysis/reactive/\" target=\"_blank\" rel=\"noopener\">Vue 技术揭秘 - 深入响应式原理</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/21706165?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=58000878338048\" target=\"_blank\" rel=\"noopener\">Vue 双向数据绑定原理分析</a></li>\n</ul>"},{"title":"基于 RBAC 权限模型的架构设计","date":"2020-05-15T00:00:00.000Z","_content":"\n谈到权限控制，实际上在我们的生活中无处不在，例如我们无时无刻都在使用的智能手机，打开手机需要生物指纹或者人脸识别；当你进入公司的时候，你需要工卡在门禁滴一下；又如曾经的你是否有过半夜打开心仪女孩的 QQ 空间，欲一探究竟的时候，却告诉需要添加好友才能访问。这些都是我们日常生活中体现权限的地方，而在软件开发中，权限管理也是无处不在的产品设计功能，尤其是后台管理后台无法对权限管理避而不谈，今天尝试深入了解权限管理设计中最常用的 RBAC 模型。\n\n## 权限模型\n\n**权限** 二字从字面上可拆分为 `权力+限制`，从使用者的角度来说，也就是在限制的范围内正确地行驶权力，而站在设计者的角度来解读，则是通过合理的手段控制使用者能访问到他们能够访问到的资源。\n\n在权限设计领域，最常见的权限模型有以下四种：\n\n- ACL（Access Control List）：访问控制列表 `用户 -> 权限`\n- RBAC（Role-Based Access Control）：基于 **角色** 的权限控制 `用户 -> 角色 -> 权限`\n- ABAC（Attribute-Based Access Control）：基于 **属性** 的权限控制，该模型根据特殊的规则分配权限 `（用户、资源、对象属性）-> 权限`\n- PBAC（Policy-Based Access Control）：基于 **策略** 的权限控制，用户（组）隶属于角色，角色隶属于资源（项目）`用户 -> 角色 -> （资源/项目 + 权限）`\n\n第一种 ACL 模型，权限能直接赋予用户，例如将查看订单列表（权限）赋予某位运营人员（用户）。但是这种模式的缺点在于，但用户量达到一定量级的时候，那么就需要对每个用户都进行一次授权操作，那么这个工作量就会相当大。\n\n因此就出现了 RBAC 模型，这是软件设计中最常用的权限管理模型，相比于 ACL 模型，RBAC 模型在用户与权限之间多了一个元素「角色」，通过权限关联角色、角色关联用户的方法来间接地赋予用户权限，从而实现用户与权限的解耦。\n\n后两种大概知道就行，因为一般不会用到，详情可自行 Google 了解。\n\n<!-- more -->\n\n## RBAC 模型的演进\n\n在 RBAC 模型的演进发展出四个版本，分别是 RBAC 0~3。\n\n### RBAC0 模型\n\nRBAC9 是最基础的权限模型，很多产品基于该模型就已经能满足设计需求。用户和角色之间可以是一对多也可以是多对多关系，而角色和权限之间则多以多对多的关系为主，用户拥有的权限等于他所有的角色持有的权限之和。\n\n**应用场景**：例如在电商公司中抽象出几种管理业务的角色，诸如销售经理、项目经理、市场经理等等，小陈既担当营销部门的市场经理又担当销售部的销售经理，那么就需要将这两个角色的赋予给他。\n\n![RBAC0 模型](http://img.mrsingsing.com/authentication-rbac0)\n\n### RBAC1 模型\n\nRBAC1 模型其实是 RBAC0 的升级版，它对角色这层元素上进行了细分，引入继承的概念，也就是可以继承某个基础角色生成子角色。\n\n![RBAC1 模型](http://img.mrsingsing.com/authentication-rbac1)\n\n**应用场景**：承接上面的例子，市场经理岗位可能会分为总监级别、经理级别、副经理级别，这时候如果小陈只是一个副经理级别的，那么他所拥有的市场经理的权限肯定就没有总监级别的多。\n\nRBAC1 模型则更好地在角色层面进行细分，更好地映射了企业组织架构中的职能的权限，根据实际的管理权限对相似职能的角色进行删减以达到级别分明的效果。\n\n### RBAC2 模型\n\n在 RBAC2 中对角色层面增加了更多的限制：\n\n- 静态职责分离 SSD\n  - 角色互斥：相同用户不能同时拥有互斥关系的角色，例如会计和出纳两个角色就是互斥的\n  - 基数约束：角色被分配到的用户有数量上限，例如公司中只有一个 CEO 职位，那么这个角色的数量就是有限的\n  - 先决条件角色：要拥有更高级别的角色权限，需要先获取到相对来说低级别的一些权限，例如副经理要想获取到总监级别权限，那么他需要先获取到经理级别的权限\n- 动态职责分离 DSD\n  - 动态的限制用户及其拥有的角色，例如一个用户可以同时拥有两个角色，但是运行时只能激活一个角色\n\n![RBAC2 模型](http://img.mrsingsing.com/authentication-rbac2)\n\n### RBAC3 模型\n\nRBAC3 模型就是 `RBAC1 + RBAC2` 两个模型的合集，所以 RBAC3 既有 RBAC1 的角色等级划分，也有 RBAC2 的角色限制。这种模型只有在系统比较复杂的时候才派得上用场，不然设计得过度复杂，对开发和后期维护也不是好事情。\n\nRBAC 模型的优缺点：\n\n**优点**\n\n1. 简化了用户和权限的关系，权限只要一次赋予角色就能重复使用\n2. 对后续的维护更加友好，用户和权限之间存在更多的斡旋空间，便于基于角色进行权限扩展\n\n**缺点**\n\n1. RBAC 模型并未提供控制操作顺序的机制，会对有严格操作顺序的系统造成困难\n\n## RBAC 架构设计\n\n前面我们提到 RBAC 涉及三个层面，就是用户、角色和权限。\n\n用户我们可以理解为独立的个体，例如张三、李四、王五。而角色的定义是很广泛的，如果我们从职位划分有销售经理、市场经理、项目经理等等，按部门划分的话可以是销售部、市场部、项目部，所以说角色应该按照系统的业务需求来划分。而事实上，在我们的架构设计中需要对用户和角色的关系进行描述，比如其内容应该是张三是销售经理、李四是市场经理、王五是项目经理。\n\n还有就是权限层面，权限层面可以划分为查看客户列表、添加客户、删除客户等等。权限和角色是绑定起来的，所以角色和权限的描述可能是这样的：销售经理可以查看客户、添加客户、删除客户；销售仅可以查看客户。\n\n![RBAC 架构设计](http://img.mrsingsing.com/autification-rbac-architect)\n\n在实际的业务开发中，可以对 RBAC 模型做相关的扩展，例如在员工人数众多的情况下，反复地对某个员工进行权限授予是个繁琐的行为，我们可以增加 **用户组** 的概念，直接给用户组分配角色，再把用户加入用户组，这样用户除了自身的权限外，还共享了用户组的所有权限。\n\n## 数据库与功能模块设计\n\n在架构设计的章节中我们提到了除用户、角色和权限外，他们相互联系的关系共五个层面，映射到数据库的设计对应的就是五张表。\n\n- user（用户）：每个用户都有唯一的 UID 识别，并被授予不同的角色\n- role（角色）：不同角色具有不同权限\n- permission（权限）：访问权限\n- 用户-角色映射：用户和角色之间的映射关系\n- 角色-权限映射：角色和权限之间的映射\n\n![数据库设计](http://img.mrsingsing.com/authentication-rbac-database-table-design)\n\n![功能模块](http://img.mrsingsing.com/authentication-rbac-feature-module)\n\n## 前端权限控制思路\n\n前端权限从本质上来说即根据权限表对视图层的展示以及对请求接口的访问进行限制。\n\n下面我们谈谈前端界面对于权限控制的粒度大小，以传统的后台系统为例，有以页面为维度作为权限控制粒度的，拥有权限的人员方可访问对应的页面；有以操作作为权限控制的，对应的前端界面中的页面元素需要隐藏或提示；也存在用户通过浏览器的开发者工具修改 DOM 元素以绕过权限直接操作的，这时候就需要对接口请求做拦截。\n\n- 页面权限（菜单权限）：进入页面的权限\n- 操作权限：增删改查的权限\n- 数据权限：发送接口到服务端的权限\n\n![Ant Design Pro](http://img.mrsingsing.com/authentication-rbac-management-system)\n\n在传统的后台系统中会在登录请求中，得到用户所拥有的权限数据，这部分是需要后端的技术支持的。前端根据权限数据展示对应的菜单，点击菜单，才能查看相关的界面。\n\n界面的控制：如果用户没有登录，手动在地址栏上跳转到管理界面地址，则需要跳转到登录界面。如果用户已经登录，但是手动输入非权限范围内的界面地址，则需要重定向到预设的 404 界面。\n\n如果用户通过非常规操作，比如通过浏览器将某些禁用按钮变成启用状态，此时发送的请求，也应该被前端拦截。\n\n在 React 中，可以通过把权限数据在根节点通过 Context API 向下传递，通过高阶组件对权限控制的菜单、元素进行外层包裹，其次对于数据请求拦截可以在发送 HTTP 请求前做校验。\n\n可以参考 [Ant Design Pro](https://pro.ant.design/docs/authority-management-cn) 的权限设计。\n\n---\n\n**参考资料：**\n\n- [RBAC 模型：基于用户-角色-权限控制的一些思考](http://www.woshipm.com/pd/1150093.html)\n- [基于 RBAC 的前端权限控制](https://juejin.im/post/5e048326f265da33f8653c27)\n- [网易高手：角色权限设计的 100 种解法](https://www.uisdc.com/100-solutions-for-character-permission-design)\n- [角色权限设计：以阿里产品为例，展开体验分析](http://www.woshipm.com/pd/3745592.html)\n- [RBAC 权限管理模型：基本模型及角色模型解析及举例](http://www.woshipm.com/pd/440765.html)\n- [如何设计网站权限系统？](https://www.zhihu.com/question/20313385)\n- [扩展 RBAC 用户角色权限设计方案](https://www.cnblogs.com/zwq194/archive/2011/03/07/1974821.html)\n- [RBAC 权限管理系统设计思路](https://juejin.im/post/5e72cfa16fb9a07cc01a4262)\n","source":"_posts/architect-design-based-on-rbac.md","raw":"---\ntitle: 基于 RBAC 权限模型的架构设计\ndate: '2020-05-15'\n---\n\n谈到权限控制，实际上在我们的生活中无处不在，例如我们无时无刻都在使用的智能手机，打开手机需要生物指纹或者人脸识别；当你进入公司的时候，你需要工卡在门禁滴一下；又如曾经的你是否有过半夜打开心仪女孩的 QQ 空间，欲一探究竟的时候，却告诉需要添加好友才能访问。这些都是我们日常生活中体现权限的地方，而在软件开发中，权限管理也是无处不在的产品设计功能，尤其是后台管理后台无法对权限管理避而不谈，今天尝试深入了解权限管理设计中最常用的 RBAC 模型。\n\n## 权限模型\n\n**权限** 二字从字面上可拆分为 `权力+限制`，从使用者的角度来说，也就是在限制的范围内正确地行驶权力，而站在设计者的角度来解读，则是通过合理的手段控制使用者能访问到他们能够访问到的资源。\n\n在权限设计领域，最常见的权限模型有以下四种：\n\n- ACL（Access Control List）：访问控制列表 `用户 -> 权限`\n- RBAC（Role-Based Access Control）：基于 **角色** 的权限控制 `用户 -> 角色 -> 权限`\n- ABAC（Attribute-Based Access Control）：基于 **属性** 的权限控制，该模型根据特殊的规则分配权限 `（用户、资源、对象属性）-> 权限`\n- PBAC（Policy-Based Access Control）：基于 **策略** 的权限控制，用户（组）隶属于角色，角色隶属于资源（项目）`用户 -> 角色 -> （资源/项目 + 权限）`\n\n第一种 ACL 模型，权限能直接赋予用户，例如将查看订单列表（权限）赋予某位运营人员（用户）。但是这种模式的缺点在于，但用户量达到一定量级的时候，那么就需要对每个用户都进行一次授权操作，那么这个工作量就会相当大。\n\n因此就出现了 RBAC 模型，这是软件设计中最常用的权限管理模型，相比于 ACL 模型，RBAC 模型在用户与权限之间多了一个元素「角色」，通过权限关联角色、角色关联用户的方法来间接地赋予用户权限，从而实现用户与权限的解耦。\n\n后两种大概知道就行，因为一般不会用到，详情可自行 Google 了解。\n\n<!-- more -->\n\n## RBAC 模型的演进\n\n在 RBAC 模型的演进发展出四个版本，分别是 RBAC 0~3。\n\n### RBAC0 模型\n\nRBAC9 是最基础的权限模型，很多产品基于该模型就已经能满足设计需求。用户和角色之间可以是一对多也可以是多对多关系，而角色和权限之间则多以多对多的关系为主，用户拥有的权限等于他所有的角色持有的权限之和。\n\n**应用场景**：例如在电商公司中抽象出几种管理业务的角色，诸如销售经理、项目经理、市场经理等等，小陈既担当营销部门的市场经理又担当销售部的销售经理，那么就需要将这两个角色的赋予给他。\n\n![RBAC0 模型](http://img.mrsingsing.com/authentication-rbac0)\n\n### RBAC1 模型\n\nRBAC1 模型其实是 RBAC0 的升级版，它对角色这层元素上进行了细分，引入继承的概念，也就是可以继承某个基础角色生成子角色。\n\n![RBAC1 模型](http://img.mrsingsing.com/authentication-rbac1)\n\n**应用场景**：承接上面的例子，市场经理岗位可能会分为总监级别、经理级别、副经理级别，这时候如果小陈只是一个副经理级别的，那么他所拥有的市场经理的权限肯定就没有总监级别的多。\n\nRBAC1 模型则更好地在角色层面进行细分，更好地映射了企业组织架构中的职能的权限，根据实际的管理权限对相似职能的角色进行删减以达到级别分明的效果。\n\n### RBAC2 模型\n\n在 RBAC2 中对角色层面增加了更多的限制：\n\n- 静态职责分离 SSD\n  - 角色互斥：相同用户不能同时拥有互斥关系的角色，例如会计和出纳两个角色就是互斥的\n  - 基数约束：角色被分配到的用户有数量上限，例如公司中只有一个 CEO 职位，那么这个角色的数量就是有限的\n  - 先决条件角色：要拥有更高级别的角色权限，需要先获取到相对来说低级别的一些权限，例如副经理要想获取到总监级别权限，那么他需要先获取到经理级别的权限\n- 动态职责分离 DSD\n  - 动态的限制用户及其拥有的角色，例如一个用户可以同时拥有两个角色，但是运行时只能激活一个角色\n\n![RBAC2 模型](http://img.mrsingsing.com/authentication-rbac2)\n\n### RBAC3 模型\n\nRBAC3 模型就是 `RBAC1 + RBAC2` 两个模型的合集，所以 RBAC3 既有 RBAC1 的角色等级划分，也有 RBAC2 的角色限制。这种模型只有在系统比较复杂的时候才派得上用场，不然设计得过度复杂，对开发和后期维护也不是好事情。\n\nRBAC 模型的优缺点：\n\n**优点**\n\n1. 简化了用户和权限的关系，权限只要一次赋予角色就能重复使用\n2. 对后续的维护更加友好，用户和权限之间存在更多的斡旋空间，便于基于角色进行权限扩展\n\n**缺点**\n\n1. RBAC 模型并未提供控制操作顺序的机制，会对有严格操作顺序的系统造成困难\n\n## RBAC 架构设计\n\n前面我们提到 RBAC 涉及三个层面，就是用户、角色和权限。\n\n用户我们可以理解为独立的个体，例如张三、李四、王五。而角色的定义是很广泛的，如果我们从职位划分有销售经理、市场经理、项目经理等等，按部门划分的话可以是销售部、市场部、项目部，所以说角色应该按照系统的业务需求来划分。而事实上，在我们的架构设计中需要对用户和角色的关系进行描述，比如其内容应该是张三是销售经理、李四是市场经理、王五是项目经理。\n\n还有就是权限层面，权限层面可以划分为查看客户列表、添加客户、删除客户等等。权限和角色是绑定起来的，所以角色和权限的描述可能是这样的：销售经理可以查看客户、添加客户、删除客户；销售仅可以查看客户。\n\n![RBAC 架构设计](http://img.mrsingsing.com/autification-rbac-architect)\n\n在实际的业务开发中，可以对 RBAC 模型做相关的扩展，例如在员工人数众多的情况下，反复地对某个员工进行权限授予是个繁琐的行为，我们可以增加 **用户组** 的概念，直接给用户组分配角色，再把用户加入用户组，这样用户除了自身的权限外，还共享了用户组的所有权限。\n\n## 数据库与功能模块设计\n\n在架构设计的章节中我们提到了除用户、角色和权限外，他们相互联系的关系共五个层面，映射到数据库的设计对应的就是五张表。\n\n- user（用户）：每个用户都有唯一的 UID 识别，并被授予不同的角色\n- role（角色）：不同角色具有不同权限\n- permission（权限）：访问权限\n- 用户-角色映射：用户和角色之间的映射关系\n- 角色-权限映射：角色和权限之间的映射\n\n![数据库设计](http://img.mrsingsing.com/authentication-rbac-database-table-design)\n\n![功能模块](http://img.mrsingsing.com/authentication-rbac-feature-module)\n\n## 前端权限控制思路\n\n前端权限从本质上来说即根据权限表对视图层的展示以及对请求接口的访问进行限制。\n\n下面我们谈谈前端界面对于权限控制的粒度大小，以传统的后台系统为例，有以页面为维度作为权限控制粒度的，拥有权限的人员方可访问对应的页面；有以操作作为权限控制的，对应的前端界面中的页面元素需要隐藏或提示；也存在用户通过浏览器的开发者工具修改 DOM 元素以绕过权限直接操作的，这时候就需要对接口请求做拦截。\n\n- 页面权限（菜单权限）：进入页面的权限\n- 操作权限：增删改查的权限\n- 数据权限：发送接口到服务端的权限\n\n![Ant Design Pro](http://img.mrsingsing.com/authentication-rbac-management-system)\n\n在传统的后台系统中会在登录请求中，得到用户所拥有的权限数据，这部分是需要后端的技术支持的。前端根据权限数据展示对应的菜单，点击菜单，才能查看相关的界面。\n\n界面的控制：如果用户没有登录，手动在地址栏上跳转到管理界面地址，则需要跳转到登录界面。如果用户已经登录，但是手动输入非权限范围内的界面地址，则需要重定向到预设的 404 界面。\n\n如果用户通过非常规操作，比如通过浏览器将某些禁用按钮变成启用状态，此时发送的请求，也应该被前端拦截。\n\n在 React 中，可以通过把权限数据在根节点通过 Context API 向下传递，通过高阶组件对权限控制的菜单、元素进行外层包裹，其次对于数据请求拦截可以在发送 HTTP 请求前做校验。\n\n可以参考 [Ant Design Pro](https://pro.ant.design/docs/authority-management-cn) 的权限设计。\n\n---\n\n**参考资料：**\n\n- [RBAC 模型：基于用户-角色-权限控制的一些思考](http://www.woshipm.com/pd/1150093.html)\n- [基于 RBAC 的前端权限控制](https://juejin.im/post/5e048326f265da33f8653c27)\n- [网易高手：角色权限设计的 100 种解法](https://www.uisdc.com/100-solutions-for-character-permission-design)\n- [角色权限设计：以阿里产品为例，展开体验分析](http://www.woshipm.com/pd/3745592.html)\n- [RBAC 权限管理模型：基本模型及角色模型解析及举例](http://www.woshipm.com/pd/440765.html)\n- [如何设计网站权限系统？](https://www.zhihu.com/question/20313385)\n- [扩展 RBAC 用户角色权限设计方案](https://www.cnblogs.com/zwq194/archive/2011/03/07/1974821.html)\n- [RBAC 权限管理系统设计思路](https://juejin.im/post/5e72cfa16fb9a07cc01a4262)\n","slug":"architect-design-based-on-rbac","published":1,"updated":"2021-08-18T03:29:03.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99yq0002v31pmz6012x7","content":"<p>谈到权限控制，实际上在我们的生活中无处不在，例如我们无时无刻都在使用的智能手机，打开手机需要生物指纹或者人脸识别；当你进入公司的时候，你需要工卡在门禁滴一下；又如曾经的你是否有过半夜打开心仪女孩的 QQ 空间，欲一探究竟的时候，却告诉需要添加好友才能访问。这些都是我们日常生活中体现权限的地方，而在软件开发中，权限管理也是无处不在的产品设计功能，尤其是后台管理后台无法对权限管理避而不谈，今天尝试深入了解权限管理设计中最常用的 RBAC 模型。</p>\n<h2 id=\"权限模型\"><a href=\"#权限模型\" class=\"headerlink\" title=\"权限模型\"></a>权限模型</h2><p><strong>权限</strong> 二字从字面上可拆分为 <code>权力+限制</code>，从使用者的角度来说，也就是在限制的范围内正确地行驶权力，而站在设计者的角度来解读，则是通过合理的手段控制使用者能访问到他们能够访问到的资源。</p>\n<p>在权限设计领域，最常见的权限模型有以下四种：</p>\n<ul>\n<li>ACL（Access Control List）：访问控制列表 <code>用户 -&gt; 权限</code></li>\n<li>RBAC（Role-Based Access Control）：基于 <strong>角色</strong> 的权限控制 <code>用户 -&gt; 角色 -&gt; 权限</code></li>\n<li>ABAC（Attribute-Based Access Control）：基于 <strong>属性</strong> 的权限控制，该模型根据特殊的规则分配权限 <code>（用户、资源、对象属性）-&gt; 权限</code></li>\n<li>PBAC（Policy-Based Access Control）：基于 <strong>策略</strong> 的权限控制，用户（组）隶属于角色，角色隶属于资源（项目）<code>用户 -&gt; 角色 -&gt; （资源/项目 + 权限）</code></li>\n</ul>\n<p>第一种 ACL 模型，权限能直接赋予用户，例如将查看订单列表（权限）赋予某位运营人员（用户）。但是这种模式的缺点在于，但用户量达到一定量级的时候，那么就需要对每个用户都进行一次授权操作，那么这个工作量就会相当大。</p>\n<p>因此就出现了 RBAC 模型，这是软件设计中最常用的权限管理模型，相比于 ACL 模型，RBAC 模型在用户与权限之间多了一个元素「角色」，通过权限关联角色、角色关联用户的方法来间接地赋予用户权限，从而实现用户与权限的解耦。</p>\n<p>后两种大概知道就行，因为一般不会用到，详情可自行 Google 了解。</p>\n<a id=\"more\"></a>\n<h2 id=\"RBAC-模型的演进\"><a href=\"#RBAC-模型的演进\" class=\"headerlink\" title=\"RBAC 模型的演进\"></a>RBAC 模型的演进</h2><p>在 RBAC 模型的演进发展出四个版本，分别是 RBAC 0~3。</p>\n<h3 id=\"RBAC0-模型\"><a href=\"#RBAC0-模型\" class=\"headerlink\" title=\"RBAC0 模型\"></a>RBAC0 模型</h3><p>RBAC9 是最基础的权限模型，很多产品基于该模型就已经能满足设计需求。用户和角色之间可以是一对多也可以是多对多关系，而角色和权限之间则多以多对多的关系为主，用户拥有的权限等于他所有的角色持有的权限之和。</p>\n<p><strong>应用场景</strong>：例如在电商公司中抽象出几种管理业务的角色，诸如销售经理、项目经理、市场经理等等，小陈既担当营销部门的市场经理又担当销售部的销售经理，那么就需要将这两个角色的赋予给他。</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac0\" alt=\"RBAC0 模型\"></p>\n<h3 id=\"RBAC1-模型\"><a href=\"#RBAC1-模型\" class=\"headerlink\" title=\"RBAC1 模型\"></a>RBAC1 模型</h3><p>RBAC1 模型其实是 RBAC0 的升级版，它对角色这层元素上进行了细分，引入继承的概念，也就是可以继承某个基础角色生成子角色。</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac1\" alt=\"RBAC1 模型\"></p>\n<p><strong>应用场景</strong>：承接上面的例子，市场经理岗位可能会分为总监级别、经理级别、副经理级别，这时候如果小陈只是一个副经理级别的，那么他所拥有的市场经理的权限肯定就没有总监级别的多。</p>\n<p>RBAC1 模型则更好地在角色层面进行细分，更好地映射了企业组织架构中的职能的权限，根据实际的管理权限对相似职能的角色进行删减以达到级别分明的效果。</p>\n<h3 id=\"RBAC2-模型\"><a href=\"#RBAC2-模型\" class=\"headerlink\" title=\"RBAC2 模型\"></a>RBAC2 模型</h3><p>在 RBAC2 中对角色层面增加了更多的限制：</p>\n<ul>\n<li>静态职责分离 SSD<ul>\n<li>角色互斥：相同用户不能同时拥有互斥关系的角色，例如会计和出纳两个角色就是互斥的</li>\n<li>基数约束：角色被分配到的用户有数量上限，例如公司中只有一个 CEO 职位，那么这个角色的数量就是有限的</li>\n<li>先决条件角色：要拥有更高级别的角色权限，需要先获取到相对来说低级别的一些权限，例如副经理要想获取到总监级别权限，那么他需要先获取到经理级别的权限</li>\n</ul>\n</li>\n<li>动态职责分离 DSD<ul>\n<li>动态的限制用户及其拥有的角色，例如一个用户可以同时拥有两个角色，但是运行时只能激活一个角色</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac2\" alt=\"RBAC2 模型\"></p>\n<h3 id=\"RBAC3-模型\"><a href=\"#RBAC3-模型\" class=\"headerlink\" title=\"RBAC3 模型\"></a>RBAC3 模型</h3><p>RBAC3 模型就是 <code>RBAC1 + RBAC2</code> 两个模型的合集，所以 RBAC3 既有 RBAC1 的角色等级划分，也有 RBAC2 的角色限制。这种模型只有在系统比较复杂的时候才派得上用场，不然设计得过度复杂，对开发和后期维护也不是好事情。</p>\n<p>RBAC 模型的优缺点：</p>\n<p><strong>优点</strong></p>\n<ol>\n<li>简化了用户和权限的关系，权限只要一次赋予角色就能重复使用</li>\n<li>对后续的维护更加友好，用户和权限之间存在更多的斡旋空间，便于基于角色进行权限扩展</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>RBAC 模型并未提供控制操作顺序的机制，会对有严格操作顺序的系统造成困难</li>\n</ol>\n<h2 id=\"RBAC-架构设计\"><a href=\"#RBAC-架构设计\" class=\"headerlink\" title=\"RBAC 架构设计\"></a>RBAC 架构设计</h2><p>前面我们提到 RBAC 涉及三个层面，就是用户、角色和权限。</p>\n<p>用户我们可以理解为独立的个体，例如张三、李四、王五。而角色的定义是很广泛的，如果我们从职位划分有销售经理、市场经理、项目经理等等，按部门划分的话可以是销售部、市场部、项目部，所以说角色应该按照系统的业务需求来划分。而事实上，在我们的架构设计中需要对用户和角色的关系进行描述，比如其内容应该是张三是销售经理、李四是市场经理、王五是项目经理。</p>\n<p>还有就是权限层面，权限层面可以划分为查看客户列表、添加客户、删除客户等等。权限和角色是绑定起来的，所以角色和权限的描述可能是这样的：销售经理可以查看客户、添加客户、删除客户；销售仅可以查看客户。</p>\n<p><img src=\"http://img.mrsingsing.com/autification-rbac-architect\" alt=\"RBAC 架构设计\"></p>\n<p>在实际的业务开发中，可以对 RBAC 模型做相关的扩展，例如在员工人数众多的情况下，反复地对某个员工进行权限授予是个繁琐的行为，我们可以增加 <strong>用户组</strong> 的概念，直接给用户组分配角色，再把用户加入用户组，这样用户除了自身的权限外，还共享了用户组的所有权限。</p>\n<h2 id=\"数据库与功能模块设计\"><a href=\"#数据库与功能模块设计\" class=\"headerlink\" title=\"数据库与功能模块设计\"></a>数据库与功能模块设计</h2><p>在架构设计的章节中我们提到了除用户、角色和权限外，他们相互联系的关系共五个层面，映射到数据库的设计对应的就是五张表。</p>\n<ul>\n<li>user（用户）：每个用户都有唯一的 UID 识别，并被授予不同的角色</li>\n<li>role（角色）：不同角色具有不同权限</li>\n<li>permission（权限）：访问权限</li>\n<li>用户-角色映射：用户和角色之间的映射关系</li>\n<li>角色-权限映射：角色和权限之间的映射</li>\n</ul>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac-database-table-design\" alt=\"数据库设计\"></p>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac-feature-module\" alt=\"功能模块\"></p>\n<h2 id=\"前端权限控制思路\"><a href=\"#前端权限控制思路\" class=\"headerlink\" title=\"前端权限控制思路\"></a>前端权限控制思路</h2><p>前端权限从本质上来说即根据权限表对视图层的展示以及对请求接口的访问进行限制。</p>\n<p>下面我们谈谈前端界面对于权限控制的粒度大小，以传统的后台系统为例，有以页面为维度作为权限控制粒度的，拥有权限的人员方可访问对应的页面；有以操作作为权限控制的，对应的前端界面中的页面元素需要隐藏或提示；也存在用户通过浏览器的开发者工具修改 DOM 元素以绕过权限直接操作的，这时候就需要对接口请求做拦截。</p>\n<ul>\n<li>页面权限（菜单权限）：进入页面的权限</li>\n<li>操作权限：增删改查的权限</li>\n<li>数据权限：发送接口到服务端的权限</li>\n</ul>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac-management-system\" alt=\"Ant Design Pro\"></p>\n<p>在传统的后台系统中会在登录请求中，得到用户所拥有的权限数据，这部分是需要后端的技术支持的。前端根据权限数据展示对应的菜单，点击菜单，才能查看相关的界面。</p>\n<p>界面的控制：如果用户没有登录，手动在地址栏上跳转到管理界面地址，则需要跳转到登录界面。如果用户已经登录，但是手动输入非权限范围内的界面地址，则需要重定向到预设的 404 界面。</p>\n<p>如果用户通过非常规操作，比如通过浏览器将某些禁用按钮变成启用状态，此时发送的请求，也应该被前端拦截。</p>\n<p>在 React 中，可以通过把权限数据在根节点通过 Context API 向下传递，通过高阶组件对权限控制的菜单、元素进行外层包裹，其次对于数据请求拦截可以在发送 HTTP 请求前做校验。</p>\n<p>可以参考 <a href=\"https://pro.ant.design/docs/authority-management-cn\" target=\"_blank\" rel=\"noopener\">Ant Design Pro</a> 的权限设计。</p>\n<hr>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li><a href=\"http://www.woshipm.com/pd/1150093.html\" target=\"_blank\" rel=\"noopener\">RBAC 模型：基于用户-角色-权限控制的一些思考</a></li>\n<li><a href=\"https://juejin.im/post/5e048326f265da33f8653c27\" target=\"_blank\" rel=\"noopener\">基于 RBAC 的前端权限控制</a></li>\n<li><a href=\"https://www.uisdc.com/100-solutions-for-character-permission-design\" target=\"_blank\" rel=\"noopener\">网易高手：角色权限设计的 100 种解法</a></li>\n<li><a href=\"http://www.woshipm.com/pd/3745592.html\" target=\"_blank\" rel=\"noopener\">角色权限设计：以阿里产品为例，展开体验分析</a></li>\n<li><a href=\"http://www.woshipm.com/pd/440765.html\" target=\"_blank\" rel=\"noopener\">RBAC 权限管理模型：基本模型及角色模型解析及举例</a></li>\n<li><a href=\"https://www.zhihu.com/question/20313385\" target=\"_blank\" rel=\"noopener\">如何设计网站权限系统？</a></li>\n<li><a href=\"https://www.cnblogs.com/zwq194/archive/2011/03/07/1974821.html\" target=\"_blank\" rel=\"noopener\">扩展 RBAC 用户角色权限设计方案</a></li>\n<li><a href=\"https://juejin.im/post/5e72cfa16fb9a07cc01a4262\" target=\"_blank\" rel=\"noopener\">RBAC 权限管理系统设计思路</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>谈到权限控制，实际上在我们的生活中无处不在，例如我们无时无刻都在使用的智能手机，打开手机需要生物指纹或者人脸识别；当你进入公司的时候，你需要工卡在门禁滴一下；又如曾经的你是否有过半夜打开心仪女孩的 QQ 空间，欲一探究竟的时候，却告诉需要添加好友才能访问。这些都是我们日常生活中体现权限的地方，而在软件开发中，权限管理也是无处不在的产品设计功能，尤其是后台管理后台无法对权限管理避而不谈，今天尝试深入了解权限管理设计中最常用的 RBAC 模型。</p>\n<h2 id=\"权限模型\"><a href=\"#权限模型\" class=\"headerlink\" title=\"权限模型\"></a>权限模型</h2><p><strong>权限</strong> 二字从字面上可拆分为 <code>权力+限制</code>，从使用者的角度来说，也就是在限制的范围内正确地行驶权力，而站在设计者的角度来解读，则是通过合理的手段控制使用者能访问到他们能够访问到的资源。</p>\n<p>在权限设计领域，最常见的权限模型有以下四种：</p>\n<ul>\n<li>ACL（Access Control List）：访问控制列表 <code>用户 -&gt; 权限</code></li>\n<li>RBAC（Role-Based Access Control）：基于 <strong>角色</strong> 的权限控制 <code>用户 -&gt; 角色 -&gt; 权限</code></li>\n<li>ABAC（Attribute-Based Access Control）：基于 <strong>属性</strong> 的权限控制，该模型根据特殊的规则分配权限 <code>（用户、资源、对象属性）-&gt; 权限</code></li>\n<li>PBAC（Policy-Based Access Control）：基于 <strong>策略</strong> 的权限控制，用户（组）隶属于角色，角色隶属于资源（项目）<code>用户 -&gt; 角色 -&gt; （资源/项目 + 权限）</code></li>\n</ul>\n<p>第一种 ACL 模型，权限能直接赋予用户，例如将查看订单列表（权限）赋予某位运营人员（用户）。但是这种模式的缺点在于，但用户量达到一定量级的时候，那么就需要对每个用户都进行一次授权操作，那么这个工作量就会相当大。</p>\n<p>因此就出现了 RBAC 模型，这是软件设计中最常用的权限管理模型，相比于 ACL 模型，RBAC 模型在用户与权限之间多了一个元素「角色」，通过权限关联角色、角色关联用户的方法来间接地赋予用户权限，从而实现用户与权限的解耦。</p>\n<p>后两种大概知道就行，因为一般不会用到，详情可自行 Google 了解。</p>","more":"<h2 id=\"RBAC-模型的演进\"><a href=\"#RBAC-模型的演进\" class=\"headerlink\" title=\"RBAC 模型的演进\"></a>RBAC 模型的演进</h2><p>在 RBAC 模型的演进发展出四个版本，分别是 RBAC 0~3。</p>\n<h3 id=\"RBAC0-模型\"><a href=\"#RBAC0-模型\" class=\"headerlink\" title=\"RBAC0 模型\"></a>RBAC0 模型</h3><p>RBAC9 是最基础的权限模型，很多产品基于该模型就已经能满足设计需求。用户和角色之间可以是一对多也可以是多对多关系，而角色和权限之间则多以多对多的关系为主，用户拥有的权限等于他所有的角色持有的权限之和。</p>\n<p><strong>应用场景</strong>：例如在电商公司中抽象出几种管理业务的角色，诸如销售经理、项目经理、市场经理等等，小陈既担当营销部门的市场经理又担当销售部的销售经理，那么就需要将这两个角色的赋予给他。</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac0\" alt=\"RBAC0 模型\"></p>\n<h3 id=\"RBAC1-模型\"><a href=\"#RBAC1-模型\" class=\"headerlink\" title=\"RBAC1 模型\"></a>RBAC1 模型</h3><p>RBAC1 模型其实是 RBAC0 的升级版，它对角色这层元素上进行了细分，引入继承的概念，也就是可以继承某个基础角色生成子角色。</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac1\" alt=\"RBAC1 模型\"></p>\n<p><strong>应用场景</strong>：承接上面的例子，市场经理岗位可能会分为总监级别、经理级别、副经理级别，这时候如果小陈只是一个副经理级别的，那么他所拥有的市场经理的权限肯定就没有总监级别的多。</p>\n<p>RBAC1 模型则更好地在角色层面进行细分，更好地映射了企业组织架构中的职能的权限，根据实际的管理权限对相似职能的角色进行删减以达到级别分明的效果。</p>\n<h3 id=\"RBAC2-模型\"><a href=\"#RBAC2-模型\" class=\"headerlink\" title=\"RBAC2 模型\"></a>RBAC2 模型</h3><p>在 RBAC2 中对角色层面增加了更多的限制：</p>\n<ul>\n<li>静态职责分离 SSD<ul>\n<li>角色互斥：相同用户不能同时拥有互斥关系的角色，例如会计和出纳两个角色就是互斥的</li>\n<li>基数约束：角色被分配到的用户有数量上限，例如公司中只有一个 CEO 职位，那么这个角色的数量就是有限的</li>\n<li>先决条件角色：要拥有更高级别的角色权限，需要先获取到相对来说低级别的一些权限，例如副经理要想获取到总监级别权限，那么他需要先获取到经理级别的权限</li>\n</ul>\n</li>\n<li>动态职责分离 DSD<ul>\n<li>动态的限制用户及其拥有的角色，例如一个用户可以同时拥有两个角色，但是运行时只能激活一个角色</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac2\" alt=\"RBAC2 模型\"></p>\n<h3 id=\"RBAC3-模型\"><a href=\"#RBAC3-模型\" class=\"headerlink\" title=\"RBAC3 模型\"></a>RBAC3 模型</h3><p>RBAC3 模型就是 <code>RBAC1 + RBAC2</code> 两个模型的合集，所以 RBAC3 既有 RBAC1 的角色等级划分，也有 RBAC2 的角色限制。这种模型只有在系统比较复杂的时候才派得上用场，不然设计得过度复杂，对开发和后期维护也不是好事情。</p>\n<p>RBAC 模型的优缺点：</p>\n<p><strong>优点</strong></p>\n<ol>\n<li>简化了用户和权限的关系，权限只要一次赋予角色就能重复使用</li>\n<li>对后续的维护更加友好，用户和权限之间存在更多的斡旋空间，便于基于角色进行权限扩展</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>RBAC 模型并未提供控制操作顺序的机制，会对有严格操作顺序的系统造成困难</li>\n</ol>\n<h2 id=\"RBAC-架构设计\"><a href=\"#RBAC-架构设计\" class=\"headerlink\" title=\"RBAC 架构设计\"></a>RBAC 架构设计</h2><p>前面我们提到 RBAC 涉及三个层面，就是用户、角色和权限。</p>\n<p>用户我们可以理解为独立的个体，例如张三、李四、王五。而角色的定义是很广泛的，如果我们从职位划分有销售经理、市场经理、项目经理等等，按部门划分的话可以是销售部、市场部、项目部，所以说角色应该按照系统的业务需求来划分。而事实上，在我们的架构设计中需要对用户和角色的关系进行描述，比如其内容应该是张三是销售经理、李四是市场经理、王五是项目经理。</p>\n<p>还有就是权限层面，权限层面可以划分为查看客户列表、添加客户、删除客户等等。权限和角色是绑定起来的，所以角色和权限的描述可能是这样的：销售经理可以查看客户、添加客户、删除客户；销售仅可以查看客户。</p>\n<p><img src=\"http://img.mrsingsing.com/autification-rbac-architect\" alt=\"RBAC 架构设计\"></p>\n<p>在实际的业务开发中，可以对 RBAC 模型做相关的扩展，例如在员工人数众多的情况下，反复地对某个员工进行权限授予是个繁琐的行为，我们可以增加 <strong>用户组</strong> 的概念，直接给用户组分配角色，再把用户加入用户组，这样用户除了自身的权限外，还共享了用户组的所有权限。</p>\n<h2 id=\"数据库与功能模块设计\"><a href=\"#数据库与功能模块设计\" class=\"headerlink\" title=\"数据库与功能模块设计\"></a>数据库与功能模块设计</h2><p>在架构设计的章节中我们提到了除用户、角色和权限外，他们相互联系的关系共五个层面，映射到数据库的设计对应的就是五张表。</p>\n<ul>\n<li>user（用户）：每个用户都有唯一的 UID 识别，并被授予不同的角色</li>\n<li>role（角色）：不同角色具有不同权限</li>\n<li>permission（权限）：访问权限</li>\n<li>用户-角色映射：用户和角色之间的映射关系</li>\n<li>角色-权限映射：角色和权限之间的映射</li>\n</ul>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac-database-table-design\" alt=\"数据库设计\"></p>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac-feature-module\" alt=\"功能模块\"></p>\n<h2 id=\"前端权限控制思路\"><a href=\"#前端权限控制思路\" class=\"headerlink\" title=\"前端权限控制思路\"></a>前端权限控制思路</h2><p>前端权限从本质上来说即根据权限表对视图层的展示以及对请求接口的访问进行限制。</p>\n<p>下面我们谈谈前端界面对于权限控制的粒度大小，以传统的后台系统为例，有以页面为维度作为权限控制粒度的，拥有权限的人员方可访问对应的页面；有以操作作为权限控制的，对应的前端界面中的页面元素需要隐藏或提示；也存在用户通过浏览器的开发者工具修改 DOM 元素以绕过权限直接操作的，这时候就需要对接口请求做拦截。</p>\n<ul>\n<li>页面权限（菜单权限）：进入页面的权限</li>\n<li>操作权限：增删改查的权限</li>\n<li>数据权限：发送接口到服务端的权限</li>\n</ul>\n<p><img src=\"http://img.mrsingsing.com/authentication-rbac-management-system\" alt=\"Ant Design Pro\"></p>\n<p>在传统的后台系统中会在登录请求中，得到用户所拥有的权限数据，这部分是需要后端的技术支持的。前端根据权限数据展示对应的菜单，点击菜单，才能查看相关的界面。</p>\n<p>界面的控制：如果用户没有登录，手动在地址栏上跳转到管理界面地址，则需要跳转到登录界面。如果用户已经登录，但是手动输入非权限范围内的界面地址，则需要重定向到预设的 404 界面。</p>\n<p>如果用户通过非常规操作，比如通过浏览器将某些禁用按钮变成启用状态，此时发送的请求，也应该被前端拦截。</p>\n<p>在 React 中，可以通过把权限数据在根节点通过 Context API 向下传递，通过高阶组件对权限控制的菜单、元素进行外层包裹，其次对于数据请求拦截可以在发送 HTTP 请求前做校验。</p>\n<p>可以参考 <a href=\"https://pro.ant.design/docs/authority-management-cn\" target=\"_blank\" rel=\"noopener\">Ant Design Pro</a> 的权限设计。</p>\n<hr>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li><a href=\"http://www.woshipm.com/pd/1150093.html\" target=\"_blank\" rel=\"noopener\">RBAC 模型：基于用户-角色-权限控制的一些思考</a></li>\n<li><a href=\"https://juejin.im/post/5e048326f265da33f8653c27\" target=\"_blank\" rel=\"noopener\">基于 RBAC 的前端权限控制</a></li>\n<li><a href=\"https://www.uisdc.com/100-solutions-for-character-permission-design\" target=\"_blank\" rel=\"noopener\">网易高手：角色权限设计的 100 种解法</a></li>\n<li><a href=\"http://www.woshipm.com/pd/3745592.html\" target=\"_blank\" rel=\"noopener\">角色权限设计：以阿里产品为例，展开体验分析</a></li>\n<li><a href=\"http://www.woshipm.com/pd/440765.html\" target=\"_blank\" rel=\"noopener\">RBAC 权限管理模型：基本模型及角色模型解析及举例</a></li>\n<li><a href=\"https://www.zhihu.com/question/20313385\" target=\"_blank\" rel=\"noopener\">如何设计网站权限系统？</a></li>\n<li><a href=\"https://www.cnblogs.com/zwq194/archive/2011/03/07/1974821.html\" target=\"_blank\" rel=\"noopener\">扩展 RBAC 用户角色权限设计方案</a></li>\n<li><a href=\"https://juejin.im/post/5e72cfa16fb9a07cc01a4262\" target=\"_blank\" rel=\"noopener\">RBAC 权限管理系统设计思路</a></li>\n</ul>"},{"title":"关于 CDN 内容分发网络","date":"2020-08-20T00:00:00.000Z","_content":"\n**內容分发网络（Content Delivery Network 或 Content Distribution Network，简称 CDN）** 通过将源站内容分发至 **最接近用户** 的节点，从而 **降低核心系统负载（系统、网络）**，使用户可就近取得所需内容，**提高用户访问的响应速度**。这种技术方案解决了因分布、带宽、服务器性能带来的访问延迟问题，适用于图片小文件、大文件下载、音视频点播、全站加速和安全加速等场景。\n\n## 工作原理\n\n通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN 系统能够实时地根据 **网络流量** 和 **各节点的连接**、**负载状况** 以及 **到用户的距离** 和 **响应时间** 等综合信息将用户的请求重新导向离用户最近的服务节点上。\n\n利用公式简述 CDN 可表示为：\n\n```js\nCDN = 更智能的镜像 + 缓存 + 流量导流;\n```\n\n简单地说，CDN 是一个经策略性部署的整体系统，包括**分布式存储**、**负载均衡**、**网络请求的重定向** 和 **内容管理** 4 个要件，而内容管理和全局的网络流量管理（Traffic Management）是 CDN 的核心所在。\n\n## 工作流程\n\n用户终端访问 CDN 的过程分为两个步骤，一是用户通过 DNS 找到最近的 CDN 边缘节点 IP，二是数据在网络中送达用户终端。\n\n最简单的 CDN 网络由一个 DNS 服务器和几台缓存服务器组成，假设您的加速域名为 `www.taobao.com`，接入 CDN 网络，开始使用加速服务后，当终端用户（广州）发起 HTTP 请求时，处理流程如下：\n\n![CDN Workflow](http://img.mrsingsing.com/about-cdn-cdn-workflow.jpg)\n\n<!-- more -->\n\n1. 当终端用户（广州）向 `www.taobao.com` 下的某资源发起请求时，首先向 LDNS（本地 DNS）发起域名解析请求。\n2. LDNS 检查缓存中是否有 `www.taobao.com` 的 IP 地址记录。如果有，则直接返回给终端用户；如果没有，则向授权 DNS 查询。\n3. 当授权 DNS 解析 `www.taobao.com` 时，返回域名 CNAME `www.taobao.alicdn.com` 对应 IP 地址。\n4. 域名解析请求发送至 DNS 调度系统，并为请求分配最佳节点 IP 地址。\n5. LDNS 获取 DNS 返回的解析 IP 地址。\n6. 用户获取解析 IP 地址。\n7. 用户向获取的 IP 地址发起对该资源的访问请求。\n   - 如果该 IP 地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤 7 和 8，请求结束。\n   - 如果该 IP 地址对应的节点未缓存该资源，则节点向它的上级缓存服务器请求内容，直至追溯到网站的源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，途中的杭州节点，并返回给用户，请求结束。\n\n> Local DNS 通常是你的运营商提供的 DNS，一般域名解析的第一站会到这里\n> 回源 HOST 是指 CDN 节点在回源过程中，在源站访问的站点域名。\n\n在步骤四中，DNS 调度系统可以实现负载均衡功能，负载均衡分为全局负载均衡和区域负载均衡，其内部逻辑大致如下：\n\n1. CDN 全局负载均衡设备会根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的**区域负载均衡设备**，告诉用户向这台设备发起请求。\n2. 区域负载均衡设备会为用户选择一台合适的**缓存服务器**提供服务，选择的依据包括：\n   - 根据用户 IP 地址，判断哪一台服务器距用户最近；\n   - 用户所处的运营商；\n   - 根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；\n   - 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。\n     基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。\n3. 全局负载均衡设备把服务器的 IP 地址返回给用户。\n\n## 组成部分\n\n典型的 CDN 系统由下面三个部分组成：\n\n- **分发服务系统**：最基本的工作单元就是 Cache 设备，Cache（边缘 Cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时 Cache 还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache 设备的数量、规模、总服务能力是衡量一个 CDN 系统服务能力的最基本的指标。\n- **负载均衡系统**：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。GSLB 主要根据用户就近性原则，通过对每个服务节点进行”最优“判断，确定向用户提供服务的 Cache 的物理位置。SLB 主要负责节点内部的设备负载均衡\n- **运营管理系统**：分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。\n\nCDN 通常由源站负责内容生产，主干节点负责二级缓存和加速，通常在 BGP 网络。\n\n广义上的内容分发网络可以包含源站一起，甚至多媒体分发（视频）。商业意义上的 CDN 只包含 CDN 提供商的网络，不包含源站。部分 CDN 支持图片及多媒体处理扩展等附加功能：压缩、剪切、水印、鉴黄。\n\n**CDN 切面**\n\n![CDN 切面](http://img.mrsingsing.com/about-cdn-section.jpg)\n\n**CDN 数据流向**\n\n![CDN 切面](http://img.mrsingsing.com/about-cdn-data-flow.jpg)\n\n## 应用场景\n\n### 网站加速\n\n站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器 ECS，静态资源如各类型 HTML、CSS、JS、图片、文件、短视频等，建议结合对象存储 OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。\n\n![七牛云网站加速](http://img.mrsingsing.com/about-cdn-qiniu-accelerate.png)\n\n建议将 CDN 产品与 OSS 产品结合使用，可以加速资源的加载速度，提高网站图片、短视频等分发效率。\n\n**业务价值：**\n\n- 终端用户访问慢：网站小文件内容多打开速度太慢\n- 跨区域访问质量差：终端用户分布在不同区域，不同区域的访问速度和质量高低不一\n- 高并发压力大：运营推广期间，源站服务器压力大，容易挂掉，造成服务不可用\n- 图片格式分辨率处理复杂：无法根据适合的终端情况进行图片压缩和优化\n\n### 超大文件下载\n\n大文件下载优化加速分发：网站或应用 App 的主要业务为大文件下载，例如：安装包文件 `apk`、音频文件 `mp3`、驱动程序 `exe`、应用更新文件 `zip` 等，平均单个文件大小在 20M 以上，如游戏、各类客户端下载和 App 下载商店等。\n\n![七牛云超大文件下载](http://img.mrsingsing.com/about-cdn-qiniu-file.png)\n\n**业务价值：**\n\n- 终端用户无法下载或者下载太慢。\n- 网络环境不稳定时，下载容易中断。重新下载会耗费额外的资源。\n- 网站内容不安全，容易被劫持。\n- 文件存储成本过高，同时对源站性能要求高。\n\n### 音视频点播\n\n音视频点播优化加速服务：网站或应用 App 的主要业务为视频点播或短视频类。支持例如：`mp4`、`flv`、`rmvb`、`wmv`、`HLS` 等主流视频格式。\n\n视音频点播主要适用于各类视音频站点，如影视类视频网站、在线教育类视频网站、新闻类视频站点、短视频社交类网站以及音频类相关站点和应用。\n\nCDN 支持流媒体协议，例如 RTMP 协议。在很多情况下，这相当于一个代理，从上一级缓存读取内容，转发给用户。由于流媒体往往是连续的，因而可以进行预先缓存的策略，也可以预先推送到用户的客户端。\n\n对于静态页面来讲，内容的分发往往采取 **拉取** 的方式，也即当发现未命中的时候，再去上一级进行拉取。但是，流媒体数据量大，如果出现回源，压力会比较大，所以往往采取主动推送的模式，将热点数据主动推送到边缘节点。\n\n对于流媒体来讲，很多 CDN 还提供 **预处理** 服务，也即文件在分发之前，经过一定的处理。例如将视频转换为不同的码流，以适应不同的网络带宽的用户需求；再如对视频进行分片，降低存储压力，也使得客户端可以选择使用不同的码率加载不同的分片。这就是我们常见的，超清、标清、流畅等。\n\n**业务价值：**\n\n- 终端用户访问视频时打不开视频或容易卡顿，观看不流畅。\n- 上传、转码、存储、分发、播放的开发配置流程复杂，点播服务技术门槛高。\n- 视频资源容易被劫持或盗用，版权得不到有效保护。\n- 终端客户上传的小视频等内容无法被快速审核，导致政策风险。\n\n### 音视频直播\n\n视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。\n\n### 边缘程序\n\n传统的 CDN 服务是纯粹的缓存和分发服务，缺乏可以直接提供给您的计算能力。访问 CDN 的海量请求中，复杂的计算逻辑必须回服务器源站执行，这增加了您的服务器消耗以及架构的复杂性。ER 可提供直接在 CDN 边缘节点计算处理的能力，将极大提高 CDN 的可定制化，可编程化，从而大量减少需回源的请求，降低用户的请求延时。同时 CDN 边缘节点拥有天然的高可用、高伸缩、全球负载均衡的特性，边缘的计算服务可应用于更多的使用场景。\n\n- Geo：边缘打点服务，可以采集到边缘节点的请求相关信息：如 IP、地理、设备信息等\n- Fetch：边缘代理服务，在 JS 代码中调用内置 api fetch 做了 http 自请求，响应给客户端 fetch 的最终内容\n- AB test：AB 测试的功能\n- Precache/Prefetch：CDN 预热功能，预热任务在响应客户端时将异步完成\n- Race：回源同拉功能，将回源速度最快的源站的内容优先返回给客户端\n- Log：边缘日志服务，在响应结束后异步地生成日志并回传给您的 Server\n- 3xx：回源 302 跟随功能\n- Redirect：边缘请求重定向功能\n- Deny bot：边缘反爬虫服务\n- Waf：边缘 waf 服务，当满足某些条件时，将禁止该请求\n\n通常，使用了 CDN 后，您可以根据延时、下载速度、打开速度、丢包率、回源率和缓存命中率判断加速效果。\n\n## 衡量指标\n\n使用 CDN 加速，能够帮助您分担源站压力，加速资源访问速度。除了通用的数据观测指标外，不同的场景下也有更具体的指标。观测这些指标，不仅可以帮助您体验 CDN 加速的效果，也能观测自身业务使用 CDN 的情况，帮助您更好地做出调整和决策。\n\n### 通用指标\n\n您可以根据以下几个主要性能指标，观察使用 CDN 前后，您的网站情况。这些指标包含但不限于：\n\n- **延时**：指一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。延时越低，性能越好。\n- **下载速度**：指用户从网络上或者网络服务器上下载的数据时的传输速度。下载速度越快，性能越好。\n- **打开速度**：指用户打开网站的速度。打开速度越快，性能越好。\n- **丢包率**：指用户在网络传输中所丢失数据包数量占所发送数据组的比率。\n- **回源率**：回源率分为回源请求数比例及回源流量比例两种。\n  - **回源请求数比**：指边缘节点对于没有缓存、缓存过期（可缓存）和不可缓存的请求占全部请求记录的比例。越低则性能越好。\n  - **回源流量比**：回源流量是回源请求文件大小产生的流量和请求本身产生的流量。所以 `回源流量比=回源流量/（回源流量+用户请求访问的流量）`，比值越低，性能越好。\n- **缓存命中率**：指终端用户访问加速节点时，该节点已缓存了要被访问的数据的次数占全部访问次数的比例。缓存命中率越高，性能越好。\n\n> 说明：上文提到的回源率、缓存命中率都是指使用 CDN 后衡量的指标。如果您还没有使用 CDN，那么回源请求数为 100%，缓存命中率为 0。\n\n一般情况下，使用 CDN 后，您的网络延时、丢包率和回源率都会降低，与之相对的下载速度、打开速度、缓存命中率则会提高。但是，由于业务场景和业务类型的不同，即使选择了相同配置的 CDN 服务，实际产生的加速效果也不相同。因此，这里只是提供了定性的指标以供观测。\n\nCDN 的各类应用场景都各自具有一些具体指标。您可以根据您的业务场景，进一步观测。\n\n### 加速小文件的主要指标\n\n小文件，主要指 `html`、`js`、`jpg`、`css` 等文件后缀的网页素材。这类加速对延迟要求较高，因为通常而言，页面加载时间的加长对用户流失会造成巨大影响。\n\n延迟主要包括以下 3 个性能指标：建立连接时间、首包时间、内容下载时间。其中，**首包时间**是最核心的指标。\n\n- 建立连接时间：指 DNS 解析完成，然后找到对应 IP 地址后建立 TCP 连接的过程。建立连接的时间长短，基本可以反映 **CDN 服务的节点资源以及调度能力**。\n- 首包时间：指从客户端开始发送请求到收到服务器端发来的第一个包之间所需要的时间。这反映了 CDN 服务节点程序的整体性能。\n\n在上传路径中，首包时间主要包含了 DNS 解析时间、TCP 用时、SSL 用时、发送时间和响应时间。上传\n\n![CDN Upload Flow](http://img.mrsingsing.com/about-cdn-upload-flow.png)\n\n在下载路径中，首包时间主要包含了 DNS 解析时间、TCP 用时、SSL 用时、发送时间、响应时间和下载用时。下载\n\n![CDN Download Flow](http://img.mrsingsing.com/about-cdn-download-flow.png)\n\n### 加速大文件下载的主要指标\n\n大文件下载，一般指各类单个文件大小大于 20M 的下载。因此对这类场景，最核心的指标就是 **下载速度** 和 **下载总时间**。\n\n### 加速音视频点播的主要指标\n\n视音频点播的场景，主要涵盖 `flv`、`mp4`、`wmv`、`mkv` 等视音频文件。在这类场景中的主要衡量指标包括首播时间和卡顿率：\n\n- **首播时间**：首播时间是从打开到看到视频画面的时间。往往会受域名解析、连接、首包时间的影响。\n- **卡顿率**：卡顿指视音频播放、资源加载等场景下出现画面滞帧。因此卡顿率主要指把所有用户播放视频的卡顿时间上报，每 100 个用户里面播放出现卡顿的比例。卡顿率越低，性能越好。\n\n## CDN 提供商\n\n每个 CDN 服务提供商的配置信息不同。\n\n- [阿里云](https://www.aliyun.com/product/cdn)\n- [腾讯云](https://cloud.tencent.com/product/cdn)\n- [华为云](https://www.huaweicloud.com/product/cdn.html)\n- [七牛云](https://www.qiniu.com/products/fusion)\n\n### 动态 CDN\n\n动态加速针对动态资源进行加速分发。\n\n- **边缘计算的模式**：既然数据是动态生成的，所以 **数据的逻辑计算和存储**，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。就像对生鲜的烹饪是动态的，没办法事先做好缓存，因而将生鲜超市放在你家旁边，既能够送货上门，也能够现场烹饪，也是边缘计算的一种体现。\n- **路径优化的模式**：数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过 CDN 的网络，对路径进行优化。因为 CDN 节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由 CDN 来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。\n\n对于常用的 TCP 连接，在公网上传输的时候经常会丢数据，导致 TCP 的窗口始终很小，发送速度上不去。根据前面的 TCP 流量控制和拥塞控制的原理，在 CDN 加速网络中可以调整 TCP 的参数，使得 TCP 可以更加激进地传输数据。可以通过多个请求复用一个连接，保证每次动态请求到达时。连接都已经建立了，不必临时三次握手或者建立过多的连接，增加服务器的压力。另外，可以通过对传输数据进行压缩，增加传输效率。所有这些手段就像冷链运输，整个物流优化了，全程冷冻高速运输。不管生鲜是从你旁边的超市送到你家的，还是从产地送的，保证到你家是新鲜的。\n\n### 刷新预热\n\n- 刷新功能是指提交 URL 刷新或目录刷新请求后，CDN 节点的缓存内容将会被强制过期，当您向 CDN 节点请求资源时，CDN 会直接回源站获取对应的资源返回给您，并将其缓存。刷新功能会降低缓存命中率。\n- 预热功能是指提交 URL 预热请求后，源站将会主动将对应的资源缓存到 CDN 节点，当您首次请求时，就能直接从 CDN 节点缓存中获取到最新的请求资源，无需再回源站获取。预热功能会提高缓存命中率。\n\n## 参考资料\n\n- [📖 维基百科：内容分发网络](https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF)\n- [📝 CDN 的基本工作过程](http://book.51cto.com/art/201205/338756.htm)\n- [📝 CDN 知识详解](https://zhuanlan.zhihu.com/p/28939811)\n- [📝 HTTP 缓存与 CDN 缓存配置指南](http://dopro.io/http-cache-and-cdn-cache.html)\n- [📝 江湖失传的最后一份 CDN 秘籍](https://zhuanlan.zhihu.com/p/31167721?group_id=915177705310674944)\n- [📝 CDN HTTPS 安全加速基本概念、解决方案及优化实践](https://juejin.im/post/59f9538f6fb9a0450a66aa2b)\n- [📝 面向前端的 CDN 原理介绍](https://github.com/renaesop/blog/issues/1)\n- [📝 阿里云 CDN 文档：CDN 的衡量指标](https://help.aliyun.com/document_detail/140425.html)\n- [📝 SSR 页面 CDN 缓存实践](https://juejin.im/post/6847902220222988301)\n","source":"_posts/about-content-delivery-network.md","raw":"---\ntitle: 关于 CDN 内容分发网络\ndate: '2020-08-20'\n---\n\n**內容分发网络（Content Delivery Network 或 Content Distribution Network，简称 CDN）** 通过将源站内容分发至 **最接近用户** 的节点，从而 **降低核心系统负载（系统、网络）**，使用户可就近取得所需内容，**提高用户访问的响应速度**。这种技术方案解决了因分布、带宽、服务器性能带来的访问延迟问题，适用于图片小文件、大文件下载、音视频点播、全站加速和安全加速等场景。\n\n## 工作原理\n\n通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN 系统能够实时地根据 **网络流量** 和 **各节点的连接**、**负载状况** 以及 **到用户的距离** 和 **响应时间** 等综合信息将用户的请求重新导向离用户最近的服务节点上。\n\n利用公式简述 CDN 可表示为：\n\n```js\nCDN = 更智能的镜像 + 缓存 + 流量导流;\n```\n\n简单地说，CDN 是一个经策略性部署的整体系统，包括**分布式存储**、**负载均衡**、**网络请求的重定向** 和 **内容管理** 4 个要件，而内容管理和全局的网络流量管理（Traffic Management）是 CDN 的核心所在。\n\n## 工作流程\n\n用户终端访问 CDN 的过程分为两个步骤，一是用户通过 DNS 找到最近的 CDN 边缘节点 IP，二是数据在网络中送达用户终端。\n\n最简单的 CDN 网络由一个 DNS 服务器和几台缓存服务器组成，假设您的加速域名为 `www.taobao.com`，接入 CDN 网络，开始使用加速服务后，当终端用户（广州）发起 HTTP 请求时，处理流程如下：\n\n![CDN Workflow](http://img.mrsingsing.com/about-cdn-cdn-workflow.jpg)\n\n<!-- more -->\n\n1. 当终端用户（广州）向 `www.taobao.com` 下的某资源发起请求时，首先向 LDNS（本地 DNS）发起域名解析请求。\n2. LDNS 检查缓存中是否有 `www.taobao.com` 的 IP 地址记录。如果有，则直接返回给终端用户；如果没有，则向授权 DNS 查询。\n3. 当授权 DNS 解析 `www.taobao.com` 时，返回域名 CNAME `www.taobao.alicdn.com` 对应 IP 地址。\n4. 域名解析请求发送至 DNS 调度系统，并为请求分配最佳节点 IP 地址。\n5. LDNS 获取 DNS 返回的解析 IP 地址。\n6. 用户获取解析 IP 地址。\n7. 用户向获取的 IP 地址发起对该资源的访问请求。\n   - 如果该 IP 地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤 7 和 8，请求结束。\n   - 如果该 IP 地址对应的节点未缓存该资源，则节点向它的上级缓存服务器请求内容，直至追溯到网站的源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，途中的杭州节点，并返回给用户，请求结束。\n\n> Local DNS 通常是你的运营商提供的 DNS，一般域名解析的第一站会到这里\n> 回源 HOST 是指 CDN 节点在回源过程中，在源站访问的站点域名。\n\n在步骤四中，DNS 调度系统可以实现负载均衡功能，负载均衡分为全局负载均衡和区域负载均衡，其内部逻辑大致如下：\n\n1. CDN 全局负载均衡设备会根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的**区域负载均衡设备**，告诉用户向这台设备发起请求。\n2. 区域负载均衡设备会为用户选择一台合适的**缓存服务器**提供服务，选择的依据包括：\n   - 根据用户 IP 地址，判断哪一台服务器距用户最近；\n   - 用户所处的运营商；\n   - 根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；\n   - 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。\n     基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。\n3. 全局负载均衡设备把服务器的 IP 地址返回给用户。\n\n## 组成部分\n\n典型的 CDN 系统由下面三个部分组成：\n\n- **分发服务系统**：最基本的工作单元就是 Cache 设备，Cache（边缘 Cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时 Cache 还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache 设备的数量、规模、总服务能力是衡量一个 CDN 系统服务能力的最基本的指标。\n- **负载均衡系统**：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。GSLB 主要根据用户就近性原则，通过对每个服务节点进行”最优“判断，确定向用户提供服务的 Cache 的物理位置。SLB 主要负责节点内部的设备负载均衡\n- **运营管理系统**：分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。\n\nCDN 通常由源站负责内容生产，主干节点负责二级缓存和加速，通常在 BGP 网络。\n\n广义上的内容分发网络可以包含源站一起，甚至多媒体分发（视频）。商业意义上的 CDN 只包含 CDN 提供商的网络，不包含源站。部分 CDN 支持图片及多媒体处理扩展等附加功能：压缩、剪切、水印、鉴黄。\n\n**CDN 切面**\n\n![CDN 切面](http://img.mrsingsing.com/about-cdn-section.jpg)\n\n**CDN 数据流向**\n\n![CDN 切面](http://img.mrsingsing.com/about-cdn-data-flow.jpg)\n\n## 应用场景\n\n### 网站加速\n\n站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器 ECS，静态资源如各类型 HTML、CSS、JS、图片、文件、短视频等，建议结合对象存储 OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。\n\n![七牛云网站加速](http://img.mrsingsing.com/about-cdn-qiniu-accelerate.png)\n\n建议将 CDN 产品与 OSS 产品结合使用，可以加速资源的加载速度，提高网站图片、短视频等分发效率。\n\n**业务价值：**\n\n- 终端用户访问慢：网站小文件内容多打开速度太慢\n- 跨区域访问质量差：终端用户分布在不同区域，不同区域的访问速度和质量高低不一\n- 高并发压力大：运营推广期间，源站服务器压力大，容易挂掉，造成服务不可用\n- 图片格式分辨率处理复杂：无法根据适合的终端情况进行图片压缩和优化\n\n### 超大文件下载\n\n大文件下载优化加速分发：网站或应用 App 的主要业务为大文件下载，例如：安装包文件 `apk`、音频文件 `mp3`、驱动程序 `exe`、应用更新文件 `zip` 等，平均单个文件大小在 20M 以上，如游戏、各类客户端下载和 App 下载商店等。\n\n![七牛云超大文件下载](http://img.mrsingsing.com/about-cdn-qiniu-file.png)\n\n**业务价值：**\n\n- 终端用户无法下载或者下载太慢。\n- 网络环境不稳定时，下载容易中断。重新下载会耗费额外的资源。\n- 网站内容不安全，容易被劫持。\n- 文件存储成本过高，同时对源站性能要求高。\n\n### 音视频点播\n\n音视频点播优化加速服务：网站或应用 App 的主要业务为视频点播或短视频类。支持例如：`mp4`、`flv`、`rmvb`、`wmv`、`HLS` 等主流视频格式。\n\n视音频点播主要适用于各类视音频站点，如影视类视频网站、在线教育类视频网站、新闻类视频站点、短视频社交类网站以及音频类相关站点和应用。\n\nCDN 支持流媒体协议，例如 RTMP 协议。在很多情况下，这相当于一个代理，从上一级缓存读取内容，转发给用户。由于流媒体往往是连续的，因而可以进行预先缓存的策略，也可以预先推送到用户的客户端。\n\n对于静态页面来讲，内容的分发往往采取 **拉取** 的方式，也即当发现未命中的时候，再去上一级进行拉取。但是，流媒体数据量大，如果出现回源，压力会比较大，所以往往采取主动推送的模式，将热点数据主动推送到边缘节点。\n\n对于流媒体来讲，很多 CDN 还提供 **预处理** 服务，也即文件在分发之前，经过一定的处理。例如将视频转换为不同的码流，以适应不同的网络带宽的用户需求；再如对视频进行分片，降低存储压力，也使得客户端可以选择使用不同的码率加载不同的分片。这就是我们常见的，超清、标清、流畅等。\n\n**业务价值：**\n\n- 终端用户访问视频时打不开视频或容易卡顿，观看不流畅。\n- 上传、转码、存储、分发、播放的开发配置流程复杂，点播服务技术门槛高。\n- 视频资源容易被劫持或盗用，版权得不到有效保护。\n- 终端客户上传的小视频等内容无法被快速审核，导致政策风险。\n\n### 音视频直播\n\n视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。\n\n### 边缘程序\n\n传统的 CDN 服务是纯粹的缓存和分发服务，缺乏可以直接提供给您的计算能力。访问 CDN 的海量请求中，复杂的计算逻辑必须回服务器源站执行，这增加了您的服务器消耗以及架构的复杂性。ER 可提供直接在 CDN 边缘节点计算处理的能力，将极大提高 CDN 的可定制化，可编程化，从而大量减少需回源的请求，降低用户的请求延时。同时 CDN 边缘节点拥有天然的高可用、高伸缩、全球负载均衡的特性，边缘的计算服务可应用于更多的使用场景。\n\n- Geo：边缘打点服务，可以采集到边缘节点的请求相关信息：如 IP、地理、设备信息等\n- Fetch：边缘代理服务，在 JS 代码中调用内置 api fetch 做了 http 自请求，响应给客户端 fetch 的最终内容\n- AB test：AB 测试的功能\n- Precache/Prefetch：CDN 预热功能，预热任务在响应客户端时将异步完成\n- Race：回源同拉功能，将回源速度最快的源站的内容优先返回给客户端\n- Log：边缘日志服务，在响应结束后异步地生成日志并回传给您的 Server\n- 3xx：回源 302 跟随功能\n- Redirect：边缘请求重定向功能\n- Deny bot：边缘反爬虫服务\n- Waf：边缘 waf 服务，当满足某些条件时，将禁止该请求\n\n通常，使用了 CDN 后，您可以根据延时、下载速度、打开速度、丢包率、回源率和缓存命中率判断加速效果。\n\n## 衡量指标\n\n使用 CDN 加速，能够帮助您分担源站压力，加速资源访问速度。除了通用的数据观测指标外，不同的场景下也有更具体的指标。观测这些指标，不仅可以帮助您体验 CDN 加速的效果，也能观测自身业务使用 CDN 的情况，帮助您更好地做出调整和决策。\n\n### 通用指标\n\n您可以根据以下几个主要性能指标，观察使用 CDN 前后，您的网站情况。这些指标包含但不限于：\n\n- **延时**：指一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。延时越低，性能越好。\n- **下载速度**：指用户从网络上或者网络服务器上下载的数据时的传输速度。下载速度越快，性能越好。\n- **打开速度**：指用户打开网站的速度。打开速度越快，性能越好。\n- **丢包率**：指用户在网络传输中所丢失数据包数量占所发送数据组的比率。\n- **回源率**：回源率分为回源请求数比例及回源流量比例两种。\n  - **回源请求数比**：指边缘节点对于没有缓存、缓存过期（可缓存）和不可缓存的请求占全部请求记录的比例。越低则性能越好。\n  - **回源流量比**：回源流量是回源请求文件大小产生的流量和请求本身产生的流量。所以 `回源流量比=回源流量/（回源流量+用户请求访问的流量）`，比值越低，性能越好。\n- **缓存命中率**：指终端用户访问加速节点时，该节点已缓存了要被访问的数据的次数占全部访问次数的比例。缓存命中率越高，性能越好。\n\n> 说明：上文提到的回源率、缓存命中率都是指使用 CDN 后衡量的指标。如果您还没有使用 CDN，那么回源请求数为 100%，缓存命中率为 0。\n\n一般情况下，使用 CDN 后，您的网络延时、丢包率和回源率都会降低，与之相对的下载速度、打开速度、缓存命中率则会提高。但是，由于业务场景和业务类型的不同，即使选择了相同配置的 CDN 服务，实际产生的加速效果也不相同。因此，这里只是提供了定性的指标以供观测。\n\nCDN 的各类应用场景都各自具有一些具体指标。您可以根据您的业务场景，进一步观测。\n\n### 加速小文件的主要指标\n\n小文件，主要指 `html`、`js`、`jpg`、`css` 等文件后缀的网页素材。这类加速对延迟要求较高，因为通常而言，页面加载时间的加长对用户流失会造成巨大影响。\n\n延迟主要包括以下 3 个性能指标：建立连接时间、首包时间、内容下载时间。其中，**首包时间**是最核心的指标。\n\n- 建立连接时间：指 DNS 解析完成，然后找到对应 IP 地址后建立 TCP 连接的过程。建立连接的时间长短，基本可以反映 **CDN 服务的节点资源以及调度能力**。\n- 首包时间：指从客户端开始发送请求到收到服务器端发来的第一个包之间所需要的时间。这反映了 CDN 服务节点程序的整体性能。\n\n在上传路径中，首包时间主要包含了 DNS 解析时间、TCP 用时、SSL 用时、发送时间和响应时间。上传\n\n![CDN Upload Flow](http://img.mrsingsing.com/about-cdn-upload-flow.png)\n\n在下载路径中，首包时间主要包含了 DNS 解析时间、TCP 用时、SSL 用时、发送时间、响应时间和下载用时。下载\n\n![CDN Download Flow](http://img.mrsingsing.com/about-cdn-download-flow.png)\n\n### 加速大文件下载的主要指标\n\n大文件下载，一般指各类单个文件大小大于 20M 的下载。因此对这类场景，最核心的指标就是 **下载速度** 和 **下载总时间**。\n\n### 加速音视频点播的主要指标\n\n视音频点播的场景，主要涵盖 `flv`、`mp4`、`wmv`、`mkv` 等视音频文件。在这类场景中的主要衡量指标包括首播时间和卡顿率：\n\n- **首播时间**：首播时间是从打开到看到视频画面的时间。往往会受域名解析、连接、首包时间的影响。\n- **卡顿率**：卡顿指视音频播放、资源加载等场景下出现画面滞帧。因此卡顿率主要指把所有用户播放视频的卡顿时间上报，每 100 个用户里面播放出现卡顿的比例。卡顿率越低，性能越好。\n\n## CDN 提供商\n\n每个 CDN 服务提供商的配置信息不同。\n\n- [阿里云](https://www.aliyun.com/product/cdn)\n- [腾讯云](https://cloud.tencent.com/product/cdn)\n- [华为云](https://www.huaweicloud.com/product/cdn.html)\n- [七牛云](https://www.qiniu.com/products/fusion)\n\n### 动态 CDN\n\n动态加速针对动态资源进行加速分发。\n\n- **边缘计算的模式**：既然数据是动态生成的，所以 **数据的逻辑计算和存储**，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。就像对生鲜的烹饪是动态的，没办法事先做好缓存，因而将生鲜超市放在你家旁边，既能够送货上门，也能够现场烹饪，也是边缘计算的一种体现。\n- **路径优化的模式**：数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过 CDN 的网络，对路径进行优化。因为 CDN 节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由 CDN 来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。\n\n对于常用的 TCP 连接，在公网上传输的时候经常会丢数据，导致 TCP 的窗口始终很小，发送速度上不去。根据前面的 TCP 流量控制和拥塞控制的原理，在 CDN 加速网络中可以调整 TCP 的参数，使得 TCP 可以更加激进地传输数据。可以通过多个请求复用一个连接，保证每次动态请求到达时。连接都已经建立了，不必临时三次握手或者建立过多的连接，增加服务器的压力。另外，可以通过对传输数据进行压缩，增加传输效率。所有这些手段就像冷链运输，整个物流优化了，全程冷冻高速运输。不管生鲜是从你旁边的超市送到你家的，还是从产地送的，保证到你家是新鲜的。\n\n### 刷新预热\n\n- 刷新功能是指提交 URL 刷新或目录刷新请求后，CDN 节点的缓存内容将会被强制过期，当您向 CDN 节点请求资源时，CDN 会直接回源站获取对应的资源返回给您，并将其缓存。刷新功能会降低缓存命中率。\n- 预热功能是指提交 URL 预热请求后，源站将会主动将对应的资源缓存到 CDN 节点，当您首次请求时，就能直接从 CDN 节点缓存中获取到最新的请求资源，无需再回源站获取。预热功能会提高缓存命中率。\n\n## 参考资料\n\n- [📖 维基百科：内容分发网络](https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF)\n- [📝 CDN 的基本工作过程](http://book.51cto.com/art/201205/338756.htm)\n- [📝 CDN 知识详解](https://zhuanlan.zhihu.com/p/28939811)\n- [📝 HTTP 缓存与 CDN 缓存配置指南](http://dopro.io/http-cache-and-cdn-cache.html)\n- [📝 江湖失传的最后一份 CDN 秘籍](https://zhuanlan.zhihu.com/p/31167721?group_id=915177705310674944)\n- [📝 CDN HTTPS 安全加速基本概念、解决方案及优化实践](https://juejin.im/post/59f9538f6fb9a0450a66aa2b)\n- [📝 面向前端的 CDN 原理介绍](https://github.com/renaesop/blog/issues/1)\n- [📝 阿里云 CDN 文档：CDN 的衡量指标](https://help.aliyun.com/document_detail/140425.html)\n- [📝 SSR 页面 CDN 缓存实践](https://juejin.im/post/6847902220222988301)\n","slug":"about-content-delivery-network","published":1,"updated":"2021-08-18T06:38:14.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99yr0003v31pctz9u03g","content":"<p><strong>內容分发网络（Content Delivery Network 或 Content Distribution Network，简称 CDN）</strong> 通过将源站内容分发至 <strong>最接近用户</strong> 的节点，从而 <strong>降低核心系统负载（系统、网络）</strong>，使用户可就近取得所需内容，<strong>提高用户访问的响应速度</strong>。这种技术方案解决了因分布、带宽、服务器性能带来的访问延迟问题，适用于图片小文件、大文件下载、音视频点播、全站加速和安全加速等场景。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN 系统能够实时地根据 <strong>网络流量</strong> 和 <strong>各节点的连接</strong>、<strong>负载状况</strong> 以及 <strong>到用户的距离</strong> 和 <strong>响应时间</strong> 等综合信息将用户的请求重新导向离用户最近的服务节点上。</p>\n<p>利用公式简述 CDN 可表示为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CDN = 更智能的镜像 + 缓存 + 流量导流;</span><br></pre></td></tr></table></figure>\n<p>简单地说，CDN 是一个经策略性部署的整体系统，包括<strong>分布式存储</strong>、<strong>负载均衡</strong>、<strong>网络请求的重定向</strong> 和 <strong>内容管理</strong> 4 个要件，而内容管理和全局的网络流量管理（Traffic Management）是 CDN 的核心所在。</p>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p>用户终端访问 CDN 的过程分为两个步骤，一是用户通过 DNS 找到最近的 CDN 边缘节点 IP，二是数据在网络中送达用户终端。</p>\n<p>最简单的 CDN 网络由一个 DNS 服务器和几台缓存服务器组成，假设您的加速域名为 <code>www.taobao.com</code>，接入 CDN 网络，开始使用加速服务后，当终端用户（广州）发起 HTTP 请求时，处理流程如下：</p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-cdn-workflow.jpg\" alt=\"CDN Workflow\"></p>\n<a id=\"more\"></a>\n<ol>\n<li>当终端用户（广州）向 <code>www.taobao.com</code> 下的某资源发起请求时，首先向 LDNS（本地 DNS）发起域名解析请求。</li>\n<li>LDNS 检查缓存中是否有 <code>www.taobao.com</code> 的 IP 地址记录。如果有，则直接返回给终端用户；如果没有，则向授权 DNS 查询。</li>\n<li>当授权 DNS 解析 <code>www.taobao.com</code> 时，返回域名 CNAME <code>www.taobao.alicdn.com</code> 对应 IP 地址。</li>\n<li>域名解析请求发送至 DNS 调度系统，并为请求分配最佳节点 IP 地址。</li>\n<li>LDNS 获取 DNS 返回的解析 IP 地址。</li>\n<li>用户获取解析 IP 地址。</li>\n<li>用户向获取的 IP 地址发起对该资源的访问请求。<ul>\n<li>如果该 IP 地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤 7 和 8，请求结束。</li>\n<li>如果该 IP 地址对应的节点未缓存该资源，则节点向它的上级缓存服务器请求内容，直至追溯到网站的源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，途中的杭州节点，并返回给用户，请求结束。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>Local DNS 通常是你的运营商提供的 DNS，一般域名解析的第一站会到这里<br>回源 HOST 是指 CDN 节点在回源过程中，在源站访问的站点域名。</p>\n</blockquote>\n<p>在步骤四中，DNS 调度系统可以实现负载均衡功能，负载均衡分为全局负载均衡和区域负载均衡，其内部逻辑大致如下：</p>\n<ol>\n<li>CDN 全局负载均衡设备会根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的<strong>区域负载均衡设备</strong>，告诉用户向这台设备发起请求。</li>\n<li>区域负载均衡设备会为用户选择一台合适的<strong>缓存服务器</strong>提供服务，选择的依据包括：<ul>\n<li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li>\n<li>用户所处的运营商；</li>\n<li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；</li>\n<li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。<br>基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。</li>\n</ul>\n</li>\n<li>全局负载均衡设备把服务器的 IP 地址返回给用户。</li>\n</ol>\n<h2 id=\"组成部分\"><a href=\"#组成部分\" class=\"headerlink\" title=\"组成部分\"></a>组成部分</h2><p>典型的 CDN 系统由下面三个部分组成：</p>\n<ul>\n<li><strong>分发服务系统</strong>：最基本的工作单元就是 Cache 设备，Cache（边缘 Cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时 Cache 还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache 设备的数量、规模、总服务能力是衡量一个 CDN 系统服务能力的最基本的指标。</li>\n<li><strong>负载均衡系统</strong>：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。GSLB 主要根据用户就近性原则，通过对每个服务节点进行”最优“判断，确定向用户提供服务的 Cache 的物理位置。SLB 主要负责节点内部的设备负载均衡</li>\n<li><strong>运营管理系统</strong>：分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</li>\n</ul>\n<p>CDN 通常由源站负责内容生产，主干节点负责二级缓存和加速，通常在 BGP 网络。</p>\n<p>广义上的内容分发网络可以包含源站一起，甚至多媒体分发（视频）。商业意义上的 CDN 只包含 CDN 提供商的网络，不包含源站。部分 CDN 支持图片及多媒体处理扩展等附加功能：压缩、剪切、水印、鉴黄。</p>\n<p><strong>CDN 切面</strong></p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-section.jpg\" alt=\"CDN 切面\"></p>\n<p><strong>CDN 数据流向</strong></p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-data-flow.jpg\" alt=\"CDN 切面\"></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><h3 id=\"网站加速\"><a href=\"#网站加速\" class=\"headerlink\" title=\"网站加速\"></a>网站加速</h3><p>站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器 ECS，静态资源如各类型 HTML、CSS、JS、图片、文件、短视频等，建议结合对象存储 OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。</p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-qiniu-accelerate.png\" alt=\"七牛云网站加速\"></p>\n<p>建议将 CDN 产品与 OSS 产品结合使用，可以加速资源的加载速度，提高网站图片、短视频等分发效率。</p>\n<p><strong>业务价值：</strong></p>\n<ul>\n<li>终端用户访问慢：网站小文件内容多打开速度太慢</li>\n<li>跨区域访问质量差：终端用户分布在不同区域，不同区域的访问速度和质量高低不一</li>\n<li>高并发压力大：运营推广期间，源站服务器压力大，容易挂掉，造成服务不可用</li>\n<li>图片格式分辨率处理复杂：无法根据适合的终端情况进行图片压缩和优化</li>\n</ul>\n<h3 id=\"超大文件下载\"><a href=\"#超大文件下载\" class=\"headerlink\" title=\"超大文件下载\"></a>超大文件下载</h3><p>大文件下载优化加速分发：网站或应用 App 的主要业务为大文件下载，例如：安装包文件 <code>apk</code>、音频文件 <code>mp3</code>、驱动程序 <code>exe</code>、应用更新文件 <code>zip</code> 等，平均单个文件大小在 20M 以上，如游戏、各类客户端下载和 App 下载商店等。</p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-qiniu-file.png\" alt=\"七牛云超大文件下载\"></p>\n<p><strong>业务价值：</strong></p>\n<ul>\n<li>终端用户无法下载或者下载太慢。</li>\n<li>网络环境不稳定时，下载容易中断。重新下载会耗费额外的资源。</li>\n<li>网站内容不安全，容易被劫持。</li>\n<li>文件存储成本过高，同时对源站性能要求高。</li>\n</ul>\n<h3 id=\"音视频点播\"><a href=\"#音视频点播\" class=\"headerlink\" title=\"音视频点播\"></a>音视频点播</h3><p>音视频点播优化加速服务：网站或应用 App 的主要业务为视频点播或短视频类。支持例如：<code>mp4</code>、<code>flv</code>、<code>rmvb</code>、<code>wmv</code>、<code>HLS</code> 等主流视频格式。</p>\n<p>视音频点播主要适用于各类视音频站点，如影视类视频网站、在线教育类视频网站、新闻类视频站点、短视频社交类网站以及音频类相关站点和应用。</p>\n<p>CDN 支持流媒体协议，例如 RTMP 协议。在很多情况下，这相当于一个代理，从上一级缓存读取内容，转发给用户。由于流媒体往往是连续的，因而可以进行预先缓存的策略，也可以预先推送到用户的客户端。</p>\n<p>对于静态页面来讲，内容的分发往往采取 <strong>拉取</strong> 的方式，也即当发现未命中的时候，再去上一级进行拉取。但是，流媒体数据量大，如果出现回源，压力会比较大，所以往往采取主动推送的模式，将热点数据主动推送到边缘节点。</p>\n<p>对于流媒体来讲，很多 CDN 还提供 <strong>预处理</strong> 服务，也即文件在分发之前，经过一定的处理。例如将视频转换为不同的码流，以适应不同的网络带宽的用户需求；再如对视频进行分片，降低存储压力，也使得客户端可以选择使用不同的码率加载不同的分片。这就是我们常见的，超清、标清、流畅等。</p>\n<p><strong>业务价值：</strong></p>\n<ul>\n<li>终端用户访问视频时打不开视频或容易卡顿，观看不流畅。</li>\n<li>上传、转码、存储、分发、播放的开发配置流程复杂，点播服务技术门槛高。</li>\n<li>视频资源容易被劫持或盗用，版权得不到有效保护。</li>\n<li>终端客户上传的小视频等内容无法被快速审核，导致政策风险。</li>\n</ul>\n<h3 id=\"音视频直播\"><a href=\"#音视频直播\" class=\"headerlink\" title=\"音视频直播\"></a>音视频直播</h3><p>视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。</p>\n<h3 id=\"边缘程序\"><a href=\"#边缘程序\" class=\"headerlink\" title=\"边缘程序\"></a>边缘程序</h3><p>传统的 CDN 服务是纯粹的缓存和分发服务，缺乏可以直接提供给您的计算能力。访问 CDN 的海量请求中，复杂的计算逻辑必须回服务器源站执行，这增加了您的服务器消耗以及架构的复杂性。ER 可提供直接在 CDN 边缘节点计算处理的能力，将极大提高 CDN 的可定制化，可编程化，从而大量减少需回源的请求，降低用户的请求延时。同时 CDN 边缘节点拥有天然的高可用、高伸缩、全球负载均衡的特性，边缘的计算服务可应用于更多的使用场景。</p>\n<ul>\n<li>Geo：边缘打点服务，可以采集到边缘节点的请求相关信息：如 IP、地理、设备信息等</li>\n<li>Fetch：边缘代理服务，在 JS 代码中调用内置 api fetch 做了 http 自请求，响应给客户端 fetch 的最终内容</li>\n<li>AB test：AB 测试的功能</li>\n<li>Precache/Prefetch：CDN 预热功能，预热任务在响应客户端时将异步完成</li>\n<li>Race：回源同拉功能，将回源速度最快的源站的内容优先返回给客户端</li>\n<li>Log：边缘日志服务，在响应结束后异步地生成日志并回传给您的 Server</li>\n<li>3xx：回源 302 跟随功能</li>\n<li>Redirect：边缘请求重定向功能</li>\n<li>Deny bot：边缘反爬虫服务</li>\n<li>Waf：边缘 waf 服务，当满足某些条件时，将禁止该请求</li>\n</ul>\n<p>通常，使用了 CDN 后，您可以根据延时、下载速度、打开速度、丢包率、回源率和缓存命中率判断加速效果。</p>\n<h2 id=\"衡量指标\"><a href=\"#衡量指标\" class=\"headerlink\" title=\"衡量指标\"></a>衡量指标</h2><p>使用 CDN 加速，能够帮助您分担源站压力，加速资源访问速度。除了通用的数据观测指标外，不同的场景下也有更具体的指标。观测这些指标，不仅可以帮助您体验 CDN 加速的效果，也能观测自身业务使用 CDN 的情况，帮助您更好地做出调整和决策。</p>\n<h3 id=\"通用指标\"><a href=\"#通用指标\" class=\"headerlink\" title=\"通用指标\"></a>通用指标</h3><p>您可以根据以下几个主要性能指标，观察使用 CDN 前后，您的网站情况。这些指标包含但不限于：</p>\n<ul>\n<li><strong>延时</strong>：指一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。延时越低，性能越好。</li>\n<li><strong>下载速度</strong>：指用户从网络上或者网络服务器上下载的数据时的传输速度。下载速度越快，性能越好。</li>\n<li><strong>打开速度</strong>：指用户打开网站的速度。打开速度越快，性能越好。</li>\n<li><strong>丢包率</strong>：指用户在网络传输中所丢失数据包数量占所发送数据组的比率。</li>\n<li><strong>回源率</strong>：回源率分为回源请求数比例及回源流量比例两种。<ul>\n<li><strong>回源请求数比</strong>：指边缘节点对于没有缓存、缓存过期（可缓存）和不可缓存的请求占全部请求记录的比例。越低则性能越好。</li>\n<li><strong>回源流量比</strong>：回源流量是回源请求文件大小产生的流量和请求本身产生的流量。所以 <code>回源流量比=回源流量/（回源流量+用户请求访问的流量）</code>，比值越低，性能越好。</li>\n</ul>\n</li>\n<li><strong>缓存命中率</strong>：指终端用户访问加速节点时，该节点已缓存了要被访问的数据的次数占全部访问次数的比例。缓存命中率越高，性能越好。</li>\n</ul>\n<blockquote>\n<p>说明：上文提到的回源率、缓存命中率都是指使用 CDN 后衡量的指标。如果您还没有使用 CDN，那么回源请求数为 100%，缓存命中率为 0。</p>\n</blockquote>\n<p>一般情况下，使用 CDN 后，您的网络延时、丢包率和回源率都会降低，与之相对的下载速度、打开速度、缓存命中率则会提高。但是，由于业务场景和业务类型的不同，即使选择了相同配置的 CDN 服务，实际产生的加速效果也不相同。因此，这里只是提供了定性的指标以供观测。</p>\n<p>CDN 的各类应用场景都各自具有一些具体指标。您可以根据您的业务场景，进一步观测。</p>\n<h3 id=\"加速小文件的主要指标\"><a href=\"#加速小文件的主要指标\" class=\"headerlink\" title=\"加速小文件的主要指标\"></a>加速小文件的主要指标</h3><p>小文件，主要指 <code>html</code>、<code>js</code>、<code>jpg</code>、<code>css</code> 等文件后缀的网页素材。这类加速对延迟要求较高，因为通常而言，页面加载时间的加长对用户流失会造成巨大影响。</p>\n<p>延迟主要包括以下 3 个性能指标：建立连接时间、首包时间、内容下载时间。其中，<strong>首包时间</strong>是最核心的指标。</p>\n<ul>\n<li>建立连接时间：指 DNS 解析完成，然后找到对应 IP 地址后建立 TCP 连接的过程。建立连接的时间长短，基本可以反映 <strong>CDN 服务的节点资源以及调度能力</strong>。</li>\n<li>首包时间：指从客户端开始发送请求到收到服务器端发来的第一个包之间所需要的时间。这反映了 CDN 服务节点程序的整体性能。</li>\n</ul>\n<p>在上传路径中，首包时间主要包含了 DNS 解析时间、TCP 用时、SSL 用时、发送时间和响应时间。上传</p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-upload-flow.png\" alt=\"CDN Upload Flow\"></p>\n<p>在下载路径中，首包时间主要包含了 DNS 解析时间、TCP 用时、SSL 用时、发送时间、响应时间和下载用时。下载</p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-download-flow.png\" alt=\"CDN Download Flow\"></p>\n<h3 id=\"加速大文件下载的主要指标\"><a href=\"#加速大文件下载的主要指标\" class=\"headerlink\" title=\"加速大文件下载的主要指标\"></a>加速大文件下载的主要指标</h3><p>大文件下载，一般指各类单个文件大小大于 20M 的下载。因此对这类场景，最核心的指标就是 <strong>下载速度</strong> 和 <strong>下载总时间</strong>。</p>\n<h3 id=\"加速音视频点播的主要指标\"><a href=\"#加速音视频点播的主要指标\" class=\"headerlink\" title=\"加速音视频点播的主要指标\"></a>加速音视频点播的主要指标</h3><p>视音频点播的场景，主要涵盖 <code>flv</code>、<code>mp4</code>、<code>wmv</code>、<code>mkv</code> 等视音频文件。在这类场景中的主要衡量指标包括首播时间和卡顿率：</p>\n<ul>\n<li><strong>首播时间</strong>：首播时间是从打开到看到视频画面的时间。往往会受域名解析、连接、首包时间的影响。</li>\n<li><strong>卡顿率</strong>：卡顿指视音频播放、资源加载等场景下出现画面滞帧。因此卡顿率主要指把所有用户播放视频的卡顿时间上报，每 100 个用户里面播放出现卡顿的比例。卡顿率越低，性能越好。</li>\n</ul>\n<h2 id=\"CDN-提供商\"><a href=\"#CDN-提供商\" class=\"headerlink\" title=\"CDN 提供商\"></a>CDN 提供商</h2><p>每个 CDN 服务提供商的配置信息不同。</p>\n<ul>\n<li><a href=\"https://www.aliyun.com/product/cdn\" target=\"_blank\" rel=\"noopener\">阿里云</a></li>\n<li><a href=\"https://cloud.tencent.com/product/cdn\" target=\"_blank\" rel=\"noopener\">腾讯云</a></li>\n<li><a href=\"https://www.huaweicloud.com/product/cdn.html\" target=\"_blank\" rel=\"noopener\">华为云</a></li>\n<li><a href=\"https://www.qiniu.com/products/fusion\" target=\"_blank\" rel=\"noopener\">七牛云</a></li>\n</ul>\n<h3 id=\"动态-CDN\"><a href=\"#动态-CDN\" class=\"headerlink\" title=\"动态 CDN\"></a>动态 CDN</h3><p>动态加速针对动态资源进行加速分发。</p>\n<ul>\n<li><strong>边缘计算的模式</strong>：既然数据是动态生成的，所以 <strong>数据的逻辑计算和存储</strong>，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。就像对生鲜的烹饪是动态的，没办法事先做好缓存，因而将生鲜超市放在你家旁边，既能够送货上门，也能够现场烹饪，也是边缘计算的一种体现。</li>\n<li><strong>路径优化的模式</strong>：数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过 CDN 的网络，对路径进行优化。因为 CDN 节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由 CDN 来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。</li>\n</ul>\n<p>对于常用的 TCP 连接，在公网上传输的时候经常会丢数据，导致 TCP 的窗口始终很小，发送速度上不去。根据前面的 TCP 流量控制和拥塞控制的原理，在 CDN 加速网络中可以调整 TCP 的参数，使得 TCP 可以更加激进地传输数据。可以通过多个请求复用一个连接，保证每次动态请求到达时。连接都已经建立了，不必临时三次握手或者建立过多的连接，增加服务器的压力。另外，可以通过对传输数据进行压缩，增加传输效率。所有这些手段就像冷链运输，整个物流优化了，全程冷冻高速运输。不管生鲜是从你旁边的超市送到你家的，还是从产地送的，保证到你家是新鲜的。</p>\n<h3 id=\"刷新预热\"><a href=\"#刷新预热\" class=\"headerlink\" title=\"刷新预热\"></a>刷新预热</h3><ul>\n<li>刷新功能是指提交 URL 刷新或目录刷新请求后，CDN 节点的缓存内容将会被强制过期，当您向 CDN 节点请求资源时，CDN 会直接回源站获取对应的资源返回给您，并将其缓存。刷新功能会降低缓存命中率。</li>\n<li>预热功能是指提交 URL 预热请求后，源站将会主动将对应的资源缓存到 CDN 节点，当您首次请求时，就能直接从 CDN 节点缓存中获取到最新的请求资源，无需再回源站获取。预热功能会提高缓存命中率。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF\" target=\"_blank\" rel=\"noopener\">📖 维基百科：内容分发网络</a></li>\n<li><a href=\"http://book.51cto.com/art/201205/338756.htm\" target=\"_blank\" rel=\"noopener\">📝 CDN 的基本工作过程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28939811\" target=\"_blank\" rel=\"noopener\">📝 CDN 知识详解</a></li>\n<li><a href=\"http://dopro.io/http-cache-and-cdn-cache.html\" target=\"_blank\" rel=\"noopener\">📝 HTTP 缓存与 CDN 缓存配置指南</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/31167721?group_id=915177705310674944\" target=\"_blank\" rel=\"noopener\">📝 江湖失传的最后一份 CDN 秘籍</a></li>\n<li><a href=\"https://juejin.im/post/59f9538f6fb9a0450a66aa2b\" target=\"_blank\" rel=\"noopener\">📝 CDN HTTPS 安全加速基本概念、解决方案及优化实践</a></li>\n<li><a href=\"https://github.com/renaesop/blog/issues/1\" target=\"_blank\" rel=\"noopener\">📝 面向前端的 CDN 原理介绍</a></li>\n<li><a href=\"https://help.aliyun.com/document_detail/140425.html\" target=\"_blank\" rel=\"noopener\">📝 阿里云 CDN 文档：CDN 的衡量指标</a></li>\n<li><a href=\"https://juejin.im/post/6847902220222988301\" target=\"_blank\" rel=\"noopener\">📝 SSR 页面 CDN 缓存实践</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>內容分发网络（Content Delivery Network 或 Content Distribution Network，简称 CDN）</strong> 通过将源站内容分发至 <strong>最接近用户</strong> 的节点，从而 <strong>降低核心系统负载（系统、网络）</strong>，使用户可就近取得所需内容，<strong>提高用户访问的响应速度</strong>。这种技术方案解决了因分布、带宽、服务器性能带来的访问延迟问题，适用于图片小文件、大文件下载、音视频点播、全站加速和安全加速等场景。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN 系统能够实时地根据 <strong>网络流量</strong> 和 <strong>各节点的连接</strong>、<strong>负载状况</strong> 以及 <strong>到用户的距离</strong> 和 <strong>响应时间</strong> 等综合信息将用户的请求重新导向离用户最近的服务节点上。</p>\n<p>利用公式简述 CDN 可表示为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CDN = 更智能的镜像 + 缓存 + 流量导流;</span><br></pre></td></tr></table></figure>\n<p>简单地说，CDN 是一个经策略性部署的整体系统，包括<strong>分布式存储</strong>、<strong>负载均衡</strong>、<strong>网络请求的重定向</strong> 和 <strong>内容管理</strong> 4 个要件，而内容管理和全局的网络流量管理（Traffic Management）是 CDN 的核心所在。</p>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p>用户终端访问 CDN 的过程分为两个步骤，一是用户通过 DNS 找到最近的 CDN 边缘节点 IP，二是数据在网络中送达用户终端。</p>\n<p>最简单的 CDN 网络由一个 DNS 服务器和几台缓存服务器组成，假设您的加速域名为 <code>www.taobao.com</code>，接入 CDN 网络，开始使用加速服务后，当终端用户（广州）发起 HTTP 请求时，处理流程如下：</p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-cdn-workflow.jpg\" alt=\"CDN Workflow\"></p>","more":"<ol>\n<li>当终端用户（广州）向 <code>www.taobao.com</code> 下的某资源发起请求时，首先向 LDNS（本地 DNS）发起域名解析请求。</li>\n<li>LDNS 检查缓存中是否有 <code>www.taobao.com</code> 的 IP 地址记录。如果有，则直接返回给终端用户；如果没有，则向授权 DNS 查询。</li>\n<li>当授权 DNS 解析 <code>www.taobao.com</code> 时，返回域名 CNAME <code>www.taobao.alicdn.com</code> 对应 IP 地址。</li>\n<li>域名解析请求发送至 DNS 调度系统，并为请求分配最佳节点 IP 地址。</li>\n<li>LDNS 获取 DNS 返回的解析 IP 地址。</li>\n<li>用户获取解析 IP 地址。</li>\n<li>用户向获取的 IP 地址发起对该资源的访问请求。<ul>\n<li>如果该 IP 地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤 7 和 8，请求结束。</li>\n<li>如果该 IP 地址对应的节点未缓存该资源，则节点向它的上级缓存服务器请求内容，直至追溯到网站的源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，途中的杭州节点，并返回给用户，请求结束。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>Local DNS 通常是你的运营商提供的 DNS，一般域名解析的第一站会到这里<br>回源 HOST 是指 CDN 节点在回源过程中，在源站访问的站点域名。</p>\n</blockquote>\n<p>在步骤四中，DNS 调度系统可以实现负载均衡功能，负载均衡分为全局负载均衡和区域负载均衡，其内部逻辑大致如下：</p>\n<ol>\n<li>CDN 全局负载均衡设备会根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的<strong>区域负载均衡设备</strong>，告诉用户向这台设备发起请求。</li>\n<li>区域负载均衡设备会为用户选择一台合适的<strong>缓存服务器</strong>提供服务，选择的依据包括：<ul>\n<li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li>\n<li>用户所处的运营商；</li>\n<li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；</li>\n<li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。<br>基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。</li>\n</ul>\n</li>\n<li>全局负载均衡设备把服务器的 IP 地址返回给用户。</li>\n</ol>\n<h2 id=\"组成部分\"><a href=\"#组成部分\" class=\"headerlink\" title=\"组成部分\"></a>组成部分</h2><p>典型的 CDN 系统由下面三个部分组成：</p>\n<ul>\n<li><strong>分发服务系统</strong>：最基本的工作单元就是 Cache 设备，Cache（边缘 Cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时 Cache 还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache 设备的数量、规模、总服务能力是衡量一个 CDN 系统服务能力的最基本的指标。</li>\n<li><strong>负载均衡系统</strong>：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。GSLB 主要根据用户就近性原则，通过对每个服务节点进行”最优“判断，确定向用户提供服务的 Cache 的物理位置。SLB 主要负责节点内部的设备负载均衡</li>\n<li><strong>运营管理系统</strong>：分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</li>\n</ul>\n<p>CDN 通常由源站负责内容生产，主干节点负责二级缓存和加速，通常在 BGP 网络。</p>\n<p>广义上的内容分发网络可以包含源站一起，甚至多媒体分发（视频）。商业意义上的 CDN 只包含 CDN 提供商的网络，不包含源站。部分 CDN 支持图片及多媒体处理扩展等附加功能：压缩、剪切、水印、鉴黄。</p>\n<p><strong>CDN 切面</strong></p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-section.jpg\" alt=\"CDN 切面\"></p>\n<p><strong>CDN 数据流向</strong></p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-data-flow.jpg\" alt=\"CDN 切面\"></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><h3 id=\"网站加速\"><a href=\"#网站加速\" class=\"headerlink\" title=\"网站加速\"></a>网站加速</h3><p>站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器 ECS，静态资源如各类型 HTML、CSS、JS、图片、文件、短视频等，建议结合对象存储 OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。</p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-qiniu-accelerate.png\" alt=\"七牛云网站加速\"></p>\n<p>建议将 CDN 产品与 OSS 产品结合使用，可以加速资源的加载速度，提高网站图片、短视频等分发效率。</p>\n<p><strong>业务价值：</strong></p>\n<ul>\n<li>终端用户访问慢：网站小文件内容多打开速度太慢</li>\n<li>跨区域访问质量差：终端用户分布在不同区域，不同区域的访问速度和质量高低不一</li>\n<li>高并发压力大：运营推广期间，源站服务器压力大，容易挂掉，造成服务不可用</li>\n<li>图片格式分辨率处理复杂：无法根据适合的终端情况进行图片压缩和优化</li>\n</ul>\n<h3 id=\"超大文件下载\"><a href=\"#超大文件下载\" class=\"headerlink\" title=\"超大文件下载\"></a>超大文件下载</h3><p>大文件下载优化加速分发：网站或应用 App 的主要业务为大文件下载，例如：安装包文件 <code>apk</code>、音频文件 <code>mp3</code>、驱动程序 <code>exe</code>、应用更新文件 <code>zip</code> 等，平均单个文件大小在 20M 以上，如游戏、各类客户端下载和 App 下载商店等。</p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-qiniu-file.png\" alt=\"七牛云超大文件下载\"></p>\n<p><strong>业务价值：</strong></p>\n<ul>\n<li>终端用户无法下载或者下载太慢。</li>\n<li>网络环境不稳定时，下载容易中断。重新下载会耗费额外的资源。</li>\n<li>网站内容不安全，容易被劫持。</li>\n<li>文件存储成本过高，同时对源站性能要求高。</li>\n</ul>\n<h3 id=\"音视频点播\"><a href=\"#音视频点播\" class=\"headerlink\" title=\"音视频点播\"></a>音视频点播</h3><p>音视频点播优化加速服务：网站或应用 App 的主要业务为视频点播或短视频类。支持例如：<code>mp4</code>、<code>flv</code>、<code>rmvb</code>、<code>wmv</code>、<code>HLS</code> 等主流视频格式。</p>\n<p>视音频点播主要适用于各类视音频站点，如影视类视频网站、在线教育类视频网站、新闻类视频站点、短视频社交类网站以及音频类相关站点和应用。</p>\n<p>CDN 支持流媒体协议，例如 RTMP 协议。在很多情况下，这相当于一个代理，从上一级缓存读取内容，转发给用户。由于流媒体往往是连续的，因而可以进行预先缓存的策略，也可以预先推送到用户的客户端。</p>\n<p>对于静态页面来讲，内容的分发往往采取 <strong>拉取</strong> 的方式，也即当发现未命中的时候，再去上一级进行拉取。但是，流媒体数据量大，如果出现回源，压力会比较大，所以往往采取主动推送的模式，将热点数据主动推送到边缘节点。</p>\n<p>对于流媒体来讲，很多 CDN 还提供 <strong>预处理</strong> 服务，也即文件在分发之前，经过一定的处理。例如将视频转换为不同的码流，以适应不同的网络带宽的用户需求；再如对视频进行分片，降低存储压力，也使得客户端可以选择使用不同的码率加载不同的分片。这就是我们常见的，超清、标清、流畅等。</p>\n<p><strong>业务价值：</strong></p>\n<ul>\n<li>终端用户访问视频时打不开视频或容易卡顿，观看不流畅。</li>\n<li>上传、转码、存储、分发、播放的开发配置流程复杂，点播服务技术门槛高。</li>\n<li>视频资源容易被劫持或盗用，版权得不到有效保护。</li>\n<li>终端客户上传的小视频等内容无法被快速审核，导致政策风险。</li>\n</ul>\n<h3 id=\"音视频直播\"><a href=\"#音视频直播\" class=\"headerlink\" title=\"音视频直播\"></a>音视频直播</h3><p>视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。</p>\n<h3 id=\"边缘程序\"><a href=\"#边缘程序\" class=\"headerlink\" title=\"边缘程序\"></a>边缘程序</h3><p>传统的 CDN 服务是纯粹的缓存和分发服务，缺乏可以直接提供给您的计算能力。访问 CDN 的海量请求中，复杂的计算逻辑必须回服务器源站执行，这增加了您的服务器消耗以及架构的复杂性。ER 可提供直接在 CDN 边缘节点计算处理的能力，将极大提高 CDN 的可定制化，可编程化，从而大量减少需回源的请求，降低用户的请求延时。同时 CDN 边缘节点拥有天然的高可用、高伸缩、全球负载均衡的特性，边缘的计算服务可应用于更多的使用场景。</p>\n<ul>\n<li>Geo：边缘打点服务，可以采集到边缘节点的请求相关信息：如 IP、地理、设备信息等</li>\n<li>Fetch：边缘代理服务，在 JS 代码中调用内置 api fetch 做了 http 自请求，响应给客户端 fetch 的最终内容</li>\n<li>AB test：AB 测试的功能</li>\n<li>Precache/Prefetch：CDN 预热功能，预热任务在响应客户端时将异步完成</li>\n<li>Race：回源同拉功能，将回源速度最快的源站的内容优先返回给客户端</li>\n<li>Log：边缘日志服务，在响应结束后异步地生成日志并回传给您的 Server</li>\n<li>3xx：回源 302 跟随功能</li>\n<li>Redirect：边缘请求重定向功能</li>\n<li>Deny bot：边缘反爬虫服务</li>\n<li>Waf：边缘 waf 服务，当满足某些条件时，将禁止该请求</li>\n</ul>\n<p>通常，使用了 CDN 后，您可以根据延时、下载速度、打开速度、丢包率、回源率和缓存命中率判断加速效果。</p>\n<h2 id=\"衡量指标\"><a href=\"#衡量指标\" class=\"headerlink\" title=\"衡量指标\"></a>衡量指标</h2><p>使用 CDN 加速，能够帮助您分担源站压力，加速资源访问速度。除了通用的数据观测指标外，不同的场景下也有更具体的指标。观测这些指标，不仅可以帮助您体验 CDN 加速的效果，也能观测自身业务使用 CDN 的情况，帮助您更好地做出调整和决策。</p>\n<h3 id=\"通用指标\"><a href=\"#通用指标\" class=\"headerlink\" title=\"通用指标\"></a>通用指标</h3><p>您可以根据以下几个主要性能指标，观察使用 CDN 前后，您的网站情况。这些指标包含但不限于：</p>\n<ul>\n<li><strong>延时</strong>：指一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。延时越低，性能越好。</li>\n<li><strong>下载速度</strong>：指用户从网络上或者网络服务器上下载的数据时的传输速度。下载速度越快，性能越好。</li>\n<li><strong>打开速度</strong>：指用户打开网站的速度。打开速度越快，性能越好。</li>\n<li><strong>丢包率</strong>：指用户在网络传输中所丢失数据包数量占所发送数据组的比率。</li>\n<li><strong>回源率</strong>：回源率分为回源请求数比例及回源流量比例两种。<ul>\n<li><strong>回源请求数比</strong>：指边缘节点对于没有缓存、缓存过期（可缓存）和不可缓存的请求占全部请求记录的比例。越低则性能越好。</li>\n<li><strong>回源流量比</strong>：回源流量是回源请求文件大小产生的流量和请求本身产生的流量。所以 <code>回源流量比=回源流量/（回源流量+用户请求访问的流量）</code>，比值越低，性能越好。</li>\n</ul>\n</li>\n<li><strong>缓存命中率</strong>：指终端用户访问加速节点时，该节点已缓存了要被访问的数据的次数占全部访问次数的比例。缓存命中率越高，性能越好。</li>\n</ul>\n<blockquote>\n<p>说明：上文提到的回源率、缓存命中率都是指使用 CDN 后衡量的指标。如果您还没有使用 CDN，那么回源请求数为 100%，缓存命中率为 0。</p>\n</blockquote>\n<p>一般情况下，使用 CDN 后，您的网络延时、丢包率和回源率都会降低，与之相对的下载速度、打开速度、缓存命中率则会提高。但是，由于业务场景和业务类型的不同，即使选择了相同配置的 CDN 服务，实际产生的加速效果也不相同。因此，这里只是提供了定性的指标以供观测。</p>\n<p>CDN 的各类应用场景都各自具有一些具体指标。您可以根据您的业务场景，进一步观测。</p>\n<h3 id=\"加速小文件的主要指标\"><a href=\"#加速小文件的主要指标\" class=\"headerlink\" title=\"加速小文件的主要指标\"></a>加速小文件的主要指标</h3><p>小文件，主要指 <code>html</code>、<code>js</code>、<code>jpg</code>、<code>css</code> 等文件后缀的网页素材。这类加速对延迟要求较高，因为通常而言，页面加载时间的加长对用户流失会造成巨大影响。</p>\n<p>延迟主要包括以下 3 个性能指标：建立连接时间、首包时间、内容下载时间。其中，<strong>首包时间</strong>是最核心的指标。</p>\n<ul>\n<li>建立连接时间：指 DNS 解析完成，然后找到对应 IP 地址后建立 TCP 连接的过程。建立连接的时间长短，基本可以反映 <strong>CDN 服务的节点资源以及调度能力</strong>。</li>\n<li>首包时间：指从客户端开始发送请求到收到服务器端发来的第一个包之间所需要的时间。这反映了 CDN 服务节点程序的整体性能。</li>\n</ul>\n<p>在上传路径中，首包时间主要包含了 DNS 解析时间、TCP 用时、SSL 用时、发送时间和响应时间。上传</p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-upload-flow.png\" alt=\"CDN Upload Flow\"></p>\n<p>在下载路径中，首包时间主要包含了 DNS 解析时间、TCP 用时、SSL 用时、发送时间、响应时间和下载用时。下载</p>\n<p><img src=\"http://img.mrsingsing.com/about-cdn-download-flow.png\" alt=\"CDN Download Flow\"></p>\n<h3 id=\"加速大文件下载的主要指标\"><a href=\"#加速大文件下载的主要指标\" class=\"headerlink\" title=\"加速大文件下载的主要指标\"></a>加速大文件下载的主要指标</h3><p>大文件下载，一般指各类单个文件大小大于 20M 的下载。因此对这类场景，最核心的指标就是 <strong>下载速度</strong> 和 <strong>下载总时间</strong>。</p>\n<h3 id=\"加速音视频点播的主要指标\"><a href=\"#加速音视频点播的主要指标\" class=\"headerlink\" title=\"加速音视频点播的主要指标\"></a>加速音视频点播的主要指标</h3><p>视音频点播的场景，主要涵盖 <code>flv</code>、<code>mp4</code>、<code>wmv</code>、<code>mkv</code> 等视音频文件。在这类场景中的主要衡量指标包括首播时间和卡顿率：</p>\n<ul>\n<li><strong>首播时间</strong>：首播时间是从打开到看到视频画面的时间。往往会受域名解析、连接、首包时间的影响。</li>\n<li><strong>卡顿率</strong>：卡顿指视音频播放、资源加载等场景下出现画面滞帧。因此卡顿率主要指把所有用户播放视频的卡顿时间上报，每 100 个用户里面播放出现卡顿的比例。卡顿率越低，性能越好。</li>\n</ul>\n<h2 id=\"CDN-提供商\"><a href=\"#CDN-提供商\" class=\"headerlink\" title=\"CDN 提供商\"></a>CDN 提供商</h2><p>每个 CDN 服务提供商的配置信息不同。</p>\n<ul>\n<li><a href=\"https://www.aliyun.com/product/cdn\" target=\"_blank\" rel=\"noopener\">阿里云</a></li>\n<li><a href=\"https://cloud.tencent.com/product/cdn\" target=\"_blank\" rel=\"noopener\">腾讯云</a></li>\n<li><a href=\"https://www.huaweicloud.com/product/cdn.html\" target=\"_blank\" rel=\"noopener\">华为云</a></li>\n<li><a href=\"https://www.qiniu.com/products/fusion\" target=\"_blank\" rel=\"noopener\">七牛云</a></li>\n</ul>\n<h3 id=\"动态-CDN\"><a href=\"#动态-CDN\" class=\"headerlink\" title=\"动态 CDN\"></a>动态 CDN</h3><p>动态加速针对动态资源进行加速分发。</p>\n<ul>\n<li><strong>边缘计算的模式</strong>：既然数据是动态生成的，所以 <strong>数据的逻辑计算和存储</strong>，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。就像对生鲜的烹饪是动态的，没办法事先做好缓存，因而将生鲜超市放在你家旁边，既能够送货上门，也能够现场烹饪，也是边缘计算的一种体现。</li>\n<li><strong>路径优化的模式</strong>：数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过 CDN 的网络，对路径进行优化。因为 CDN 节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由 CDN 来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。</li>\n</ul>\n<p>对于常用的 TCP 连接，在公网上传输的时候经常会丢数据，导致 TCP 的窗口始终很小，发送速度上不去。根据前面的 TCP 流量控制和拥塞控制的原理，在 CDN 加速网络中可以调整 TCP 的参数，使得 TCP 可以更加激进地传输数据。可以通过多个请求复用一个连接，保证每次动态请求到达时。连接都已经建立了，不必临时三次握手或者建立过多的连接，增加服务器的压力。另外，可以通过对传输数据进行压缩，增加传输效率。所有这些手段就像冷链运输，整个物流优化了，全程冷冻高速运输。不管生鲜是从你旁边的超市送到你家的，还是从产地送的，保证到你家是新鲜的。</p>\n<h3 id=\"刷新预热\"><a href=\"#刷新预热\" class=\"headerlink\" title=\"刷新预热\"></a>刷新预热</h3><ul>\n<li>刷新功能是指提交 URL 刷新或目录刷新请求后，CDN 节点的缓存内容将会被强制过期，当您向 CDN 节点请求资源时，CDN 会直接回源站获取对应的资源返回给您，并将其缓存。刷新功能会降低缓存命中率。</li>\n<li>预热功能是指提交 URL 预热请求后，源站将会主动将对应的资源缓存到 CDN 节点，当您首次请求时，就能直接从 CDN 节点缓存中获取到最新的请求资源，无需再回源站获取。预热功能会提高缓存命中率。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF\" target=\"_blank\" rel=\"noopener\">📖 维基百科：内容分发网络</a></li>\n<li><a href=\"http://book.51cto.com/art/201205/338756.htm\" target=\"_blank\" rel=\"noopener\">📝 CDN 的基本工作过程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28939811\" target=\"_blank\" rel=\"noopener\">📝 CDN 知识详解</a></li>\n<li><a href=\"http://dopro.io/http-cache-and-cdn-cache.html\" target=\"_blank\" rel=\"noopener\">📝 HTTP 缓存与 CDN 缓存配置指南</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/31167721?group_id=915177705310674944\" target=\"_blank\" rel=\"noopener\">📝 江湖失传的最后一份 CDN 秘籍</a></li>\n<li><a href=\"https://juejin.im/post/59f9538f6fb9a0450a66aa2b\" target=\"_blank\" rel=\"noopener\">📝 CDN HTTPS 安全加速基本概念、解决方案及优化实践</a></li>\n<li><a href=\"https://github.com/renaesop/blog/issues/1\" target=\"_blank\" rel=\"noopener\">📝 面向前端的 CDN 原理介绍</a></li>\n<li><a href=\"https://help.aliyun.com/document_detail/140425.html\" target=\"_blank\" rel=\"noopener\">📝 阿里云 CDN 文档：CDN 的衡量指标</a></li>\n<li><a href=\"https://juejin.im/post/6847902220222988301\" target=\"_blank\" rel=\"noopener\">📝 SSR 页面 CDN 缓存实践</a></li>\n</ul>"},{"title":"基于 roadhog^2.x 的后台项目构建性能优化","date":"2019-01-20T00:00:00.000Z","_content":"\n## 技术选型\n\n目前我司后台系统采用基于 [Webpack](https://github.com/webpack/webpack) 为底层封装的打包工具 [roadhog](https://github.com/sorrycc/roadhog)。开发者通过工具暴露的有限的可配置参数，可以简单明了地针对项目需要进行自定义配置。该款工具的目的很明确，就是为了简化 webpack 的配置。这对于入门级别的工程师是非常友好的，因为降低了学习 webpack 的成本，免去捣鼓 webpack 复杂的配置，方便开发者快速进入开发流程。\n\n从目前项目版本的 `package.json` 向上层依赖溯源可以得出这样的依赖关系：\n\n> roadhog^2.4.2 => af-webpack^0.23.0-beta.1 => webpack^3.56\n\nroadhog 基于 [`umi/af-webpack`](https://github.com/umijs/umi/tree/master/packages/af-webpack) 作为底层。从社区反馈的信息得知，现时（2019.1）作者的工作重点都在 [umi](https://github.com/umijs/umi)，而 roadhog 无打算迭代升级的打算。即便将 roadhog 升级至最新版本，所依赖的底层 webpack 的版本也只是 3.5.6，webpack4+ 的优化配置均无法使用。由于工具文档提供信息有限，因此要将优化进行到极致从源码依赖着手推动项目构建优化是免不了的工作。\n\n## 构建现况分析\n\n> 版本 release/2.29.0\n\n**分析材料**\n\n- 通过 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 对打包模块进行可视化分析\n- 对打包出来后的资源文件进行分析\n- 项目组织结构分析\n\n**构建情况分析**\n\n- 构建内存占用过高：130% 需要给 node 配置更多内存防止内存溢出导致失败\n- 构建进度观察：卡在 10%、86%、**91%**\n- 构建使用时间：407s 366s 386s 380s 372s => 平均 382s\n- 静态资源数量：分割成共 92 个资源文件（包括入口文件，但除去默认拷贝输出的文件）\n- 静态资源大小\n  - Start：总 150MB，平均，最大 5.05MB\n  - Parsed：总 88MB，平均，最大 2.48MB\n  - Gzipped：总 25MB，平均，最大 686.48KB\n\n| 静态资源大小 | 数量 |\n| ------------ | ---- |\n| >2MB         | 5    |\n| >1MB         | 24   |\n| >500KB       | 60   |\n\n<!-- more -->\n\n## 项目构建优化方案\n\n按照 [Webpack 构建性能优化探索](https://github.com/pigcan/blog/issues/1) 提供的思路，可以从四个维度着手项目构建的优化：\n\n- 从环境着手，提升下载依赖速度\n- 从项目自身着手，代码组织是否合理，依赖使用是否合理，反面提升效率\n- 从 Webpack 自身优化手段着手，优化配置，提升 Webpack 效率\n- 从 Webpack 可能存在的不足着手，优化不足，进一步提升效率\n\n### 去除废弃依赖\n\n观察 `package.json`，发现一些项目中废弃的依赖并没有及时处理，因此把无用的和重复安装的依赖去除。\n\n### 提取第三方公共模块\n\n此前项目中页面代码根据路由按需加载，每个页面 route 和 model 引用的第三方模块，例如 `react`、`dva`、`query-string`、`antd`、`moment` 等，都会在各自的页面中重复打包一份，这就导致根据页面分割的资源文件尺寸较大，冗余代码较多。\n\n除此之外，值得注意的是，项目中使用的 [AntDesign](https://github.com/ant-design/ant-design) 组件，尽管通过 [babel-plugin-import](https://github.com/ant-design/babel-plugin-import) 实现了组件模块的按需加载，页面引用并不会将完整的 AntDesign 引入。但是由于开始时候大部分页面都不会从零开始写，而是会选择移植相似页面的逻辑再加以修改，因此会导致相当一部分页面会将没有使用到的组件进行打包，同样会造成冗余。\n\n因此，整个项目的性能优化必然从资源依赖的第三方库着手，提前编译提取。\n\n分析 `package.json` 可以得知整个项目依赖主要有几个部分：\n\n- [antd](https://github.com/ant-design/ant-design) 基础 UI 组件库 📌\n- [dva](https://github.com/dvajs/dva) 数据管理框架\n- [moment](https://github.com/moment/moment) 时间操作工具库 📌\n- [ali-oss](https://github.com/ali-sdk/ali-oss) 阿里云 OSS 插件\n- [react](https://github.com/facebook/react) 界面框架\n- react-dom\n- react-router-dom\n- universal-cookie\n- ...等等\n\nroadhog 暴露了 commons 参数对应 Webpack 中 plugins 的多个 `webpack.CommonsChunkPlugin` 实例。下面有两种可选择的方案供实现：\n\n- 被至少固定个数（默认两个） entry/page 依赖即提取公共，这样 common 公共模块会比较大，项目整体尺寸最小，但页面首屏渲染需要加载的资源尺寸会比较大\n- 被所有 entry/page 依赖才提取为公共，这样 common 公共模块比较小，项目整体尺寸较大\n\n最终决定将所有依赖的第三方模块提前打包，在用户访问页面时需要将基础工具和基础组件的打包文件先加载，后续用户界面资源文件加载就会相对另一种方案会更加快速。\n\n相关扩展：\n\n- [详解 CommonsChunkPlugin 的配置和用法](https://segmentfault.com/a/1190000012828879)\n\n- [webpack.optimize.CommonsChunkPlugin 详解](https://juejin.im/post/5c2205e15188257507558c5a)\n\n- [webpack、manifest、runtime、缓存与 CommonsChunkPlugin](https://www.jianshu.com/p/95752b101582)\n\n### 第三方模块不同兼容库重复打包\n\n![优化前打包结果](http://img.mrsingsing.com/roadhog-performance-build-analyze.jpg)\n\nvendor 提取第三方模块后，发现几个比较大的页面资源文件里仍然存在 antd.lib 组件库的代码，而且这些 `ant.lib` 都是完整一个模块被打包进了这些页面当中，但其实 AntDesign 已经被我完整单独地打包成另外一个文件了，这个打包的文件是由 `ant.es` 打包出来的。\n\n- antd.es\n- antd.lib\n\n通过对打包后的文件以及业务代码的检查，发现是引用 Antd 组件库发生了问题，由于使用了 webpack-plugin-import 插件，将 Antd 中名为 es 的组件库按需加载并通过 babel 转化独立打包成 vendor，因此当使用 `import {message} from \"antd/lib/index\"` 这种写法的时候，当前页面会将 Antd lib 目录下的组件全部打包，造成页面打包文件臃肿。\n\n书写规范\n使用了 extraBabelPlugins 就会按需加载\n\n```js\n// wrong\nimport { message } from 'antd/lib/index';\n\n// good\nimport { message } from 'antd';\n```\n\n### 忽略 moment 语言包的打包\n\n![忽略 moment 语言包](http://img.mrsingsing.com/roadhog-performance-moment-locale.jpg)\n\n打包后 moment 包的体积比较大，其中 locale 语言包部分占据了比较大的体积，由于我们的项目没有国际化需求，因此可以通过配置 roadhog 提供的 `ignoreMomentLocale: true` 减少打包出来的 vendor 尺寸。\n\n但是，如果项目中使用到 AntDesign 组件，并且使用到时间选择组件 `date-picker`（默认是英文文案），那么这里需要做一些处理以使项目中组件能够显示中文。\n\n我是在项目最上层，单独引入 moment 的中文语言包。\n\n```js\nimport moment from 'moment';\nimport 'moment/locale/zh-cn';\n\nmoment.locale('zh-cn');\n```\n\n这样项目中使用到 moment 工具库的 `date-picker` 都会显示中文文案。\n\n### 压缩耗时\n\n项目构建过程会卡在 91%，通过查阅相关资料和了解社区反馈后，明确原因为该阶段 Webpack 正在对代码进行混淆压缩操作，但同时由于 Webpack 的压缩插件 UglifyJS 无法对 ES6+ 的代码进行压缩，需要使用 [babel-minify](https://github.com/babel/minify) 获取更好的 treeshaking 效果（虽然 Webpack4 已经支持 ES6+ 代码压缩，但是目前 Roadhog 采用的是 Webpack3+）。\n\n[构建速度慢的解决方法@sorrycc](https://hackmd.io/YHK_yuRtT0ePPVLY0_kUzw)\n\n体现特征：\n\n- 构建速度慢\n- 内存消耗高\n\n解决方法：\n\n- 减少依赖文件\n  - 优化 common 提取策略，让整体尺寸尽可能少\n  - externals 掉一些大的库，降低整体尺寸\n  - 利用 webpack 的 TreeShaking + es module，排除掉一些没有用到的模块\n- 减少需要压缩的文件\n\n### 外部扩展\n\nexternals 是非常有效的一个方案，可以一下子减少大量需要编译、压缩的模块。将一些不常更新版本比较稳定的模块文件直接注入 HMTL 文件，当读取到该脚本时将自动加载，这不仅能加快构建速度，而且能够利用 CDN 进行资源缓存。\n\n但是会带来的问题是：\n\n- 无法利用 Webpack 的 Tree-Shaking\n- 多个库之间如果存在公共模块（比如 lodash），就无法复用\n\n使用 externals 需要在 HTML 里引用额外的 JS 文件，这里也有几个潜在的问题：\n\n- 如果你的 CDN 不支持 Combo，并且不是 http/2，那么速度会很慢\n- 你需要手动维护一份 CDN 文件列表，并且跟进他们的更新，也是件麻烦的事情\n\n这里主要将三个尺寸较大且比较少项目页面引用的模块 externals 掉。\n\n```js\nexternals: {\n    'ali-oss': 'window.OSS',\n    'react': 'window.react',\n    'react-dom': 'window.ReactDOM'\n}\n```\n\n### 项目样式文件减少\n\nExtractTextPlugin 提取 CSS (antd + 业务)\n\n能用公共就用公共（因为大部分的页面的样式几乎一样），不然每个页面开一个 less 引用公共，会重复打包，造成冗余。\n\n### Gzip 传输压缩\n\ngzip 需要在服务器配置开启\n\n这里提供一种 Nginx 的配置。[传送门](https://blog.csdn.net/qq_36030288/article/details/54576503)\n\n[前端性能优化：gzip 压缩文件传输数据](https://www.cnblogs.com/zs-note/p/9556390.html)\n\n## 优化效果分析\n\n![优化效果分析](http://img.mrsingsing.com/roadhog-performance-optimizition-result.jpg)\n\n- 开发体验：70s => 20s 启动项目时间提升 71%\n- 构建速度：382s => 40s 项目构建速度提升 89%\n- 资源文件：88Mb（未开启 Gzip） => 25Mb（开启 Gzip） => 1Mb（优化后开启 Gzip） 资源文件尺寸大幅度降低\n\n## 后续需要解决的问题\n\n### 单独打包的 AntDesign 尺寸过大\n\n- 可视化分析尺寸较大的文件包括 rc-editor-core / draft.js 等\n- 通过依赖找到根源是 rc-editor-mention => rc-editor-core => draft-js 来自 Mention 组件，但是项目中并没有使用到\n- 得出结果提取打包将整个组件库都打包进来了\n\n社区中有反应希望提取公共模块打包时将其中某些部分忽略不打包，而维护者似乎告知需要使用 `babel-plugin-import` 按需引用，并没提供提取公共模块的解决方案。 [传送门](https://github.com/ant-design/ant-design/issues/10180)\n\n## 参考资料\n\n- [支持 vendor 的配置 Issue #370](https://github.com/sorrycc/roadhog/issues/370)\n- [roadhog2 如何成功提取 vendor · Issue #577](https://github.com/sorrycc/roadhog/issues/577)\n- [编译很慢 #722](https://github.com/sorrycc/roadhog/issues/722)\n- [roadhog 1.3x 打包慢的解决办法](https://github.com/liangxinwei/blog/blob/master/webpack/2.md)\n- [Roadhog 构建优化](http://www.mamicode.com/info-detail-2413081.html)\n- [JS/CSS 体积减少了 67%，我们是如何做到的？](https://www.itcodemonkey.com/article/12011.html)\n- [Webpack 日常使用与优化](https://github.com/creeperyang/blog/issues/37)\n","source":"_posts/building-performance-optimization-based-on-roadhog.md","raw":"---\ntitle: 基于 roadhog^2.x 的后台项目构建性能优化\ndate: '2019-01-20'\n---\n\n## 技术选型\n\n目前我司后台系统采用基于 [Webpack](https://github.com/webpack/webpack) 为底层封装的打包工具 [roadhog](https://github.com/sorrycc/roadhog)。开发者通过工具暴露的有限的可配置参数，可以简单明了地针对项目需要进行自定义配置。该款工具的目的很明确，就是为了简化 webpack 的配置。这对于入门级别的工程师是非常友好的，因为降低了学习 webpack 的成本，免去捣鼓 webpack 复杂的配置，方便开发者快速进入开发流程。\n\n从目前项目版本的 `package.json` 向上层依赖溯源可以得出这样的依赖关系：\n\n> roadhog^2.4.2 => af-webpack^0.23.0-beta.1 => webpack^3.56\n\nroadhog 基于 [`umi/af-webpack`](https://github.com/umijs/umi/tree/master/packages/af-webpack) 作为底层。从社区反馈的信息得知，现时（2019.1）作者的工作重点都在 [umi](https://github.com/umijs/umi)，而 roadhog 无打算迭代升级的打算。即便将 roadhog 升级至最新版本，所依赖的底层 webpack 的版本也只是 3.5.6，webpack4+ 的优化配置均无法使用。由于工具文档提供信息有限，因此要将优化进行到极致从源码依赖着手推动项目构建优化是免不了的工作。\n\n## 构建现况分析\n\n> 版本 release/2.29.0\n\n**分析材料**\n\n- 通过 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 对打包模块进行可视化分析\n- 对打包出来后的资源文件进行分析\n- 项目组织结构分析\n\n**构建情况分析**\n\n- 构建内存占用过高：130% 需要给 node 配置更多内存防止内存溢出导致失败\n- 构建进度观察：卡在 10%、86%、**91%**\n- 构建使用时间：407s 366s 386s 380s 372s => 平均 382s\n- 静态资源数量：分割成共 92 个资源文件（包括入口文件，但除去默认拷贝输出的文件）\n- 静态资源大小\n  - Start：总 150MB，平均，最大 5.05MB\n  - Parsed：总 88MB，平均，最大 2.48MB\n  - Gzipped：总 25MB，平均，最大 686.48KB\n\n| 静态资源大小 | 数量 |\n| ------------ | ---- |\n| >2MB         | 5    |\n| >1MB         | 24   |\n| >500KB       | 60   |\n\n<!-- more -->\n\n## 项目构建优化方案\n\n按照 [Webpack 构建性能优化探索](https://github.com/pigcan/blog/issues/1) 提供的思路，可以从四个维度着手项目构建的优化：\n\n- 从环境着手，提升下载依赖速度\n- 从项目自身着手，代码组织是否合理，依赖使用是否合理，反面提升效率\n- 从 Webpack 自身优化手段着手，优化配置，提升 Webpack 效率\n- 从 Webpack 可能存在的不足着手，优化不足，进一步提升效率\n\n### 去除废弃依赖\n\n观察 `package.json`，发现一些项目中废弃的依赖并没有及时处理，因此把无用的和重复安装的依赖去除。\n\n### 提取第三方公共模块\n\n此前项目中页面代码根据路由按需加载，每个页面 route 和 model 引用的第三方模块，例如 `react`、`dva`、`query-string`、`antd`、`moment` 等，都会在各自的页面中重复打包一份，这就导致根据页面分割的资源文件尺寸较大，冗余代码较多。\n\n除此之外，值得注意的是，项目中使用的 [AntDesign](https://github.com/ant-design/ant-design) 组件，尽管通过 [babel-plugin-import](https://github.com/ant-design/babel-plugin-import) 实现了组件模块的按需加载，页面引用并不会将完整的 AntDesign 引入。但是由于开始时候大部分页面都不会从零开始写，而是会选择移植相似页面的逻辑再加以修改，因此会导致相当一部分页面会将没有使用到的组件进行打包，同样会造成冗余。\n\n因此，整个项目的性能优化必然从资源依赖的第三方库着手，提前编译提取。\n\n分析 `package.json` 可以得知整个项目依赖主要有几个部分：\n\n- [antd](https://github.com/ant-design/ant-design) 基础 UI 组件库 📌\n- [dva](https://github.com/dvajs/dva) 数据管理框架\n- [moment](https://github.com/moment/moment) 时间操作工具库 📌\n- [ali-oss](https://github.com/ali-sdk/ali-oss) 阿里云 OSS 插件\n- [react](https://github.com/facebook/react) 界面框架\n- react-dom\n- react-router-dom\n- universal-cookie\n- ...等等\n\nroadhog 暴露了 commons 参数对应 Webpack 中 plugins 的多个 `webpack.CommonsChunkPlugin` 实例。下面有两种可选择的方案供实现：\n\n- 被至少固定个数（默认两个） entry/page 依赖即提取公共，这样 common 公共模块会比较大，项目整体尺寸最小，但页面首屏渲染需要加载的资源尺寸会比较大\n- 被所有 entry/page 依赖才提取为公共，这样 common 公共模块比较小，项目整体尺寸较大\n\n最终决定将所有依赖的第三方模块提前打包，在用户访问页面时需要将基础工具和基础组件的打包文件先加载，后续用户界面资源文件加载就会相对另一种方案会更加快速。\n\n相关扩展：\n\n- [详解 CommonsChunkPlugin 的配置和用法](https://segmentfault.com/a/1190000012828879)\n\n- [webpack.optimize.CommonsChunkPlugin 详解](https://juejin.im/post/5c2205e15188257507558c5a)\n\n- [webpack、manifest、runtime、缓存与 CommonsChunkPlugin](https://www.jianshu.com/p/95752b101582)\n\n### 第三方模块不同兼容库重复打包\n\n![优化前打包结果](http://img.mrsingsing.com/roadhog-performance-build-analyze.jpg)\n\nvendor 提取第三方模块后，发现几个比较大的页面资源文件里仍然存在 antd.lib 组件库的代码，而且这些 `ant.lib` 都是完整一个模块被打包进了这些页面当中，但其实 AntDesign 已经被我完整单独地打包成另外一个文件了，这个打包的文件是由 `ant.es` 打包出来的。\n\n- antd.es\n- antd.lib\n\n通过对打包后的文件以及业务代码的检查，发现是引用 Antd 组件库发生了问题，由于使用了 webpack-plugin-import 插件，将 Antd 中名为 es 的组件库按需加载并通过 babel 转化独立打包成 vendor，因此当使用 `import {message} from \"antd/lib/index\"` 这种写法的时候，当前页面会将 Antd lib 目录下的组件全部打包，造成页面打包文件臃肿。\n\n书写规范\n使用了 extraBabelPlugins 就会按需加载\n\n```js\n// wrong\nimport { message } from 'antd/lib/index';\n\n// good\nimport { message } from 'antd';\n```\n\n### 忽略 moment 语言包的打包\n\n![忽略 moment 语言包](http://img.mrsingsing.com/roadhog-performance-moment-locale.jpg)\n\n打包后 moment 包的体积比较大，其中 locale 语言包部分占据了比较大的体积，由于我们的项目没有国际化需求，因此可以通过配置 roadhog 提供的 `ignoreMomentLocale: true` 减少打包出来的 vendor 尺寸。\n\n但是，如果项目中使用到 AntDesign 组件，并且使用到时间选择组件 `date-picker`（默认是英文文案），那么这里需要做一些处理以使项目中组件能够显示中文。\n\n我是在项目最上层，单独引入 moment 的中文语言包。\n\n```js\nimport moment from 'moment';\nimport 'moment/locale/zh-cn';\n\nmoment.locale('zh-cn');\n```\n\n这样项目中使用到 moment 工具库的 `date-picker` 都会显示中文文案。\n\n### 压缩耗时\n\n项目构建过程会卡在 91%，通过查阅相关资料和了解社区反馈后，明确原因为该阶段 Webpack 正在对代码进行混淆压缩操作，但同时由于 Webpack 的压缩插件 UglifyJS 无法对 ES6+ 的代码进行压缩，需要使用 [babel-minify](https://github.com/babel/minify) 获取更好的 treeshaking 效果（虽然 Webpack4 已经支持 ES6+ 代码压缩，但是目前 Roadhog 采用的是 Webpack3+）。\n\n[构建速度慢的解决方法@sorrycc](https://hackmd.io/YHK_yuRtT0ePPVLY0_kUzw)\n\n体现特征：\n\n- 构建速度慢\n- 内存消耗高\n\n解决方法：\n\n- 减少依赖文件\n  - 优化 common 提取策略，让整体尺寸尽可能少\n  - externals 掉一些大的库，降低整体尺寸\n  - 利用 webpack 的 TreeShaking + es module，排除掉一些没有用到的模块\n- 减少需要压缩的文件\n\n### 外部扩展\n\nexternals 是非常有效的一个方案，可以一下子减少大量需要编译、压缩的模块。将一些不常更新版本比较稳定的模块文件直接注入 HMTL 文件，当读取到该脚本时将自动加载，这不仅能加快构建速度，而且能够利用 CDN 进行资源缓存。\n\n但是会带来的问题是：\n\n- 无法利用 Webpack 的 Tree-Shaking\n- 多个库之间如果存在公共模块（比如 lodash），就无法复用\n\n使用 externals 需要在 HTML 里引用额外的 JS 文件，这里也有几个潜在的问题：\n\n- 如果你的 CDN 不支持 Combo，并且不是 http/2，那么速度会很慢\n- 你需要手动维护一份 CDN 文件列表，并且跟进他们的更新，也是件麻烦的事情\n\n这里主要将三个尺寸较大且比较少项目页面引用的模块 externals 掉。\n\n```js\nexternals: {\n    'ali-oss': 'window.OSS',\n    'react': 'window.react',\n    'react-dom': 'window.ReactDOM'\n}\n```\n\n### 项目样式文件减少\n\nExtractTextPlugin 提取 CSS (antd + 业务)\n\n能用公共就用公共（因为大部分的页面的样式几乎一样），不然每个页面开一个 less 引用公共，会重复打包，造成冗余。\n\n### Gzip 传输压缩\n\ngzip 需要在服务器配置开启\n\n这里提供一种 Nginx 的配置。[传送门](https://blog.csdn.net/qq_36030288/article/details/54576503)\n\n[前端性能优化：gzip 压缩文件传输数据](https://www.cnblogs.com/zs-note/p/9556390.html)\n\n## 优化效果分析\n\n![优化效果分析](http://img.mrsingsing.com/roadhog-performance-optimizition-result.jpg)\n\n- 开发体验：70s => 20s 启动项目时间提升 71%\n- 构建速度：382s => 40s 项目构建速度提升 89%\n- 资源文件：88Mb（未开启 Gzip） => 25Mb（开启 Gzip） => 1Mb（优化后开启 Gzip） 资源文件尺寸大幅度降低\n\n## 后续需要解决的问题\n\n### 单独打包的 AntDesign 尺寸过大\n\n- 可视化分析尺寸较大的文件包括 rc-editor-core / draft.js 等\n- 通过依赖找到根源是 rc-editor-mention => rc-editor-core => draft-js 来自 Mention 组件，但是项目中并没有使用到\n- 得出结果提取打包将整个组件库都打包进来了\n\n社区中有反应希望提取公共模块打包时将其中某些部分忽略不打包，而维护者似乎告知需要使用 `babel-plugin-import` 按需引用，并没提供提取公共模块的解决方案。 [传送门](https://github.com/ant-design/ant-design/issues/10180)\n\n## 参考资料\n\n- [支持 vendor 的配置 Issue #370](https://github.com/sorrycc/roadhog/issues/370)\n- [roadhog2 如何成功提取 vendor · Issue #577](https://github.com/sorrycc/roadhog/issues/577)\n- [编译很慢 #722](https://github.com/sorrycc/roadhog/issues/722)\n- [roadhog 1.3x 打包慢的解决办法](https://github.com/liangxinwei/blog/blob/master/webpack/2.md)\n- [Roadhog 构建优化](http://www.mamicode.com/info-detail-2413081.html)\n- [JS/CSS 体积减少了 67%，我们是如何做到的？](https://www.itcodemonkey.com/article/12011.html)\n- [Webpack 日常使用与优化](https://github.com/creeperyang/blog/issues/37)\n","slug":"building-performance-optimization-based-on-roadhog","published":1,"updated":"2021-08-18T03:33:43.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99ys0004v31pg1kc0ist","content":"<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><p>目前我司后台系统采用基于 <a href=\"https://github.com/webpack/webpack\" target=\"_blank\" rel=\"noopener\">Webpack</a> 为底层封装的打包工具 <a href=\"https://github.com/sorrycc/roadhog\" target=\"_blank\" rel=\"noopener\">roadhog</a>。开发者通过工具暴露的有限的可配置参数，可以简单明了地针对项目需要进行自定义配置。该款工具的目的很明确，就是为了简化 webpack 的配置。这对于入门级别的工程师是非常友好的，因为降低了学习 webpack 的成本，免去捣鼓 webpack 复杂的配置，方便开发者快速进入开发流程。</p>\n<p>从目前项目版本的 <code>package.json</code> 向上层依赖溯源可以得出这样的依赖关系：</p>\n<blockquote>\n<p>roadhog^2.4.2 =&gt; af-webpack^0.23.0-beta.1 =&gt; webpack^3.56</p>\n</blockquote>\n<p>roadhog 基于 <a href=\"https://github.com/umijs/umi/tree/master/packages/af-webpack\" target=\"_blank\" rel=\"noopener\"><code>umi/af-webpack</code></a> 作为底层。从社区反馈的信息得知，现时（2019.1）作者的工作重点都在 <a href=\"https://github.com/umijs/umi\" target=\"_blank\" rel=\"noopener\">umi</a>，而 roadhog 无打算迭代升级的打算。即便将 roadhog 升级至最新版本，所依赖的底层 webpack 的版本也只是 3.5.6，webpack4+ 的优化配置均无法使用。由于工具文档提供信息有限，因此要将优化进行到极致从源码依赖着手推动项目构建优化是免不了的工作。</p>\n<h2 id=\"构建现况分析\"><a href=\"#构建现况分析\" class=\"headerlink\" title=\"构建现况分析\"></a>构建现况分析</h2><blockquote>\n<p>版本 release/2.29.0</p>\n</blockquote>\n<p><strong>分析材料</strong></p>\n<ul>\n<li>通过 <a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a> 对打包模块进行可视化分析</li>\n<li>对打包出来后的资源文件进行分析</li>\n<li>项目组织结构分析</li>\n</ul>\n<p><strong>构建情况分析</strong></p>\n<ul>\n<li>构建内存占用过高：130% 需要给 node 配置更多内存防止内存溢出导致失败</li>\n<li>构建进度观察：卡在 10%、86%、<strong>91%</strong></li>\n<li>构建使用时间：407s 366s 386s 380s 372s =&gt; 平均 382s</li>\n<li>静态资源数量：分割成共 92 个资源文件（包括入口文件，但除去默认拷贝输出的文件）</li>\n<li>静态资源大小<ul>\n<li>Start：总 150MB，平均，最大 5.05MB</li>\n<li>Parsed：总 88MB，平均，最大 2.48MB</li>\n<li>Gzipped：总 25MB，平均，最大 686.48KB</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>静态资源大小</th>\n<th>数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;2MB</td>\n<td>5</td>\n</tr>\n<tr>\n<td>&gt;1MB</td>\n<td>24</td>\n</tr>\n<tr>\n<td>&gt;500KB</td>\n<td>60</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h2 id=\"项目构建优化方案\"><a href=\"#项目构建优化方案\" class=\"headerlink\" title=\"项目构建优化方案\"></a>项目构建优化方案</h2><p>按照 <a href=\"https://github.com/pigcan/blog/issues/1\" target=\"_blank\" rel=\"noopener\">Webpack 构建性能优化探索</a> 提供的思路，可以从四个维度着手项目构建的优化：</p>\n<ul>\n<li>从环境着手，提升下载依赖速度</li>\n<li>从项目自身着手，代码组织是否合理，依赖使用是否合理，反面提升效率</li>\n<li>从 Webpack 自身优化手段着手，优化配置，提升 Webpack 效率</li>\n<li>从 Webpack 可能存在的不足着手，优化不足，进一步提升效率</li>\n</ul>\n<h3 id=\"去除废弃依赖\"><a href=\"#去除废弃依赖\" class=\"headerlink\" title=\"去除废弃依赖\"></a>去除废弃依赖</h3><p>观察 <code>package.json</code>，发现一些项目中废弃的依赖并没有及时处理，因此把无用的和重复安装的依赖去除。</p>\n<h3 id=\"提取第三方公共模块\"><a href=\"#提取第三方公共模块\" class=\"headerlink\" title=\"提取第三方公共模块\"></a>提取第三方公共模块</h3><p>此前项目中页面代码根据路由按需加载，每个页面 route 和 model 引用的第三方模块，例如 <code>react</code>、<code>dva</code>、<code>query-string</code>、<code>antd</code>、<code>moment</code> 等，都会在各自的页面中重复打包一份，这就导致根据页面分割的资源文件尺寸较大，冗余代码较多。</p>\n<p>除此之外，值得注意的是，项目中使用的 <a href=\"https://github.com/ant-design/ant-design\" target=\"_blank\" rel=\"noopener\">AntDesign</a> 组件，尽管通过 <a href=\"https://github.com/ant-design/babel-plugin-import\" target=\"_blank\" rel=\"noopener\">babel-plugin-import</a> 实现了组件模块的按需加载，页面引用并不会将完整的 AntDesign 引入。但是由于开始时候大部分页面都不会从零开始写，而是会选择移植相似页面的逻辑再加以修改，因此会导致相当一部分页面会将没有使用到的组件进行打包，同样会造成冗余。</p>\n<p>因此，整个项目的性能优化必然从资源依赖的第三方库着手，提前编译提取。</p>\n<p>分析 <code>package.json</code> 可以得知整个项目依赖主要有几个部分：</p>\n<ul>\n<li><a href=\"https://github.com/ant-design/ant-design\" target=\"_blank\" rel=\"noopener\">antd</a> 基础 UI 组件库 📌</li>\n<li><a href=\"https://github.com/dvajs/dva\" target=\"_blank\" rel=\"noopener\">dva</a> 数据管理框架</li>\n<li><a href=\"https://github.com/moment/moment\" target=\"_blank\" rel=\"noopener\">moment</a> 时间操作工具库 📌</li>\n<li><a href=\"https://github.com/ali-sdk/ali-oss\" target=\"_blank\" rel=\"noopener\">ali-oss</a> 阿里云 OSS 插件</li>\n<li><a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">react</a> 界面框架</li>\n<li>react-dom</li>\n<li>react-router-dom</li>\n<li>universal-cookie</li>\n<li>…等等</li>\n</ul>\n<p>roadhog 暴露了 commons 参数对应 Webpack 中 plugins 的多个 <code>webpack.CommonsChunkPlugin</code> 实例。下面有两种可选择的方案供实现：</p>\n<ul>\n<li>被至少固定个数（默认两个） entry/page 依赖即提取公共，这样 common 公共模块会比较大，项目整体尺寸最小，但页面首屏渲染需要加载的资源尺寸会比较大</li>\n<li>被所有 entry/page 依赖才提取为公共，这样 common 公共模块比较小，项目整体尺寸较大</li>\n</ul>\n<p>最终决定将所有依赖的第三方模块提前打包，在用户访问页面时需要将基础工具和基础组件的打包文件先加载，后续用户界面资源文件加载就会相对另一种方案会更加快速。</p>\n<p>相关扩展：</p>\n<ul>\n<li><p><a href=\"https://segmentfault.com/a/1190000012828879\" target=\"_blank\" rel=\"noopener\">详解 CommonsChunkPlugin 的配置和用法</a></p>\n</li>\n<li><p><a href=\"https://juejin.im/post/5c2205e15188257507558c5a\" target=\"_blank\" rel=\"noopener\">webpack.optimize.CommonsChunkPlugin 详解</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/95752b101582\" target=\"_blank\" rel=\"noopener\">webpack、manifest、runtime、缓存与 CommonsChunkPlugin</a></p>\n</li>\n</ul>\n<h3 id=\"第三方模块不同兼容库重复打包\"><a href=\"#第三方模块不同兼容库重复打包\" class=\"headerlink\" title=\"第三方模块不同兼容库重复打包\"></a>第三方模块不同兼容库重复打包</h3><p><img src=\"http://img.mrsingsing.com/roadhog-performance-build-analyze.jpg\" alt=\"优化前打包结果\"></p>\n<p>vendor 提取第三方模块后，发现几个比较大的页面资源文件里仍然存在 antd.lib 组件库的代码，而且这些 <code>ant.lib</code> 都是完整一个模块被打包进了这些页面当中，但其实 AntDesign 已经被我完整单独地打包成另外一个文件了，这个打包的文件是由 <code>ant.es</code> 打包出来的。</p>\n<ul>\n<li>antd.es</li>\n<li>antd.lib</li>\n</ul>\n<p>通过对打包后的文件以及业务代码的检查，发现是引用 Antd 组件库发生了问题，由于使用了 webpack-plugin-import 插件，将 Antd 中名为 es 的组件库按需加载并通过 babel 转化独立打包成 vendor，因此当使用 <code>import {message} from &quot;antd/lib/index&quot;</code> 这种写法的时候，当前页面会将 Antd lib 目录下的组件全部打包，造成页面打包文件臃肿。</p>\n<p>书写规范<br>使用了 extraBabelPlugins 就会按需加载</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// wrong</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; message &#125; <span class=\"keyword\">from</span> <span class=\"string\">'antd/lib/index'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; message &#125; <span class=\"keyword\">from</span> <span class=\"string\">'antd'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"忽略-moment-语言包的打包\"><a href=\"#忽略-moment-语言包的打包\" class=\"headerlink\" title=\"忽略 moment 语言包的打包\"></a>忽略 moment 语言包的打包</h3><p><img src=\"http://img.mrsingsing.com/roadhog-performance-moment-locale.jpg\" alt=\"忽略 moment 语言包\"></p>\n<p>打包后 moment 包的体积比较大，其中 locale 语言包部分占据了比较大的体积，由于我们的项目没有国际化需求，因此可以通过配置 roadhog 提供的 <code>ignoreMomentLocale: true</code> 减少打包出来的 vendor 尺寸。</p>\n<p>但是，如果项目中使用到 AntDesign 组件，并且使用到时间选择组件 <code>date-picker</code>（默认是英文文案），那么这里需要做一些处理以使项目中组件能够显示中文。</p>\n<p>我是在项目最上层，单独引入 moment 的中文语言包。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> moment <span class=\"keyword\">from</span> <span class=\"string\">'moment'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'moment/locale/zh-cn'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">moment.locale(<span class=\"string\">'zh-cn'</span>);</span><br></pre></td></tr></table></figure>\n<p>这样项目中使用到 moment 工具库的 <code>date-picker</code> 都会显示中文文案。</p>\n<h3 id=\"压缩耗时\"><a href=\"#压缩耗时\" class=\"headerlink\" title=\"压缩耗时\"></a>压缩耗时</h3><p>项目构建过程会卡在 91%，通过查阅相关资料和了解社区反馈后，明确原因为该阶段 Webpack 正在对代码进行混淆压缩操作，但同时由于 Webpack 的压缩插件 UglifyJS 无法对 ES6+ 的代码进行压缩，需要使用 <a href=\"https://github.com/babel/minify\" target=\"_blank\" rel=\"noopener\">babel-minify</a> 获取更好的 treeshaking 效果（虽然 Webpack4 已经支持 ES6+ 代码压缩，但是目前 Roadhog 采用的是 Webpack3+）。</p>\n<p><a href=\"https://hackmd.io/YHK_yuRtT0ePPVLY0_kUzw\" target=\"_blank\" rel=\"noopener\">构建速度慢的解决方法@sorrycc</a></p>\n<p>体现特征：</p>\n<ul>\n<li>构建速度慢</li>\n<li>内存消耗高</li>\n</ul>\n<p>解决方法：</p>\n<ul>\n<li>减少依赖文件<ul>\n<li>优化 common 提取策略，让整体尺寸尽可能少</li>\n<li>externals 掉一些大的库，降低整体尺寸</li>\n<li>利用 webpack 的 TreeShaking + es module，排除掉一些没有用到的模块</li>\n</ul>\n</li>\n<li>减少需要压缩的文件</li>\n</ul>\n<h3 id=\"外部扩展\"><a href=\"#外部扩展\" class=\"headerlink\" title=\"外部扩展\"></a>外部扩展</h3><p>externals 是非常有效的一个方案，可以一下子减少大量需要编译、压缩的模块。将一些不常更新版本比较稳定的模块文件直接注入 HMTL 文件，当读取到该脚本时将自动加载，这不仅能加快构建速度，而且能够利用 CDN 进行资源缓存。</p>\n<p>但是会带来的问题是：</p>\n<ul>\n<li>无法利用 Webpack 的 Tree-Shaking</li>\n<li>多个库之间如果存在公共模块（比如 lodash），就无法复用</li>\n</ul>\n<p>使用 externals 需要在 HTML 里引用额外的 JS 文件，这里也有几个潜在的问题：</p>\n<ul>\n<li>如果你的 CDN 不支持 Combo，并且不是 http/2，那么速度会很慢</li>\n<li>你需要手动维护一份 CDN 文件列表，并且跟进他们的更新，也是件麻烦的事情</li>\n</ul>\n<p>这里主要将三个尺寸较大且比较少项目页面引用的模块 externals 掉。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">externals: &#123;</span><br><span class=\"line\">    <span class=\"string\">'ali-oss'</span>: <span class=\"string\">'window.OSS'</span>,</span><br><span class=\"line\">    <span class=\"string\">'react'</span>: <span class=\"string\">'window.react'</span>,</span><br><span class=\"line\">    <span class=\"string\">'react-dom'</span>: <span class=\"string\">'window.ReactDOM'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"项目样式文件减少\"><a href=\"#项目样式文件减少\" class=\"headerlink\" title=\"项目样式文件减少\"></a>项目样式文件减少</h3><p>ExtractTextPlugin 提取 CSS (antd + 业务)</p>\n<p>能用公共就用公共（因为大部分的页面的样式几乎一样），不然每个页面开一个 less 引用公共，会重复打包，造成冗余。</p>\n<h3 id=\"Gzip-传输压缩\"><a href=\"#Gzip-传输压缩\" class=\"headerlink\" title=\"Gzip 传输压缩\"></a>Gzip 传输压缩</h3><p>gzip 需要在服务器配置开启</p>\n<p>这里提供一种 Nginx 的配置。<a href=\"https://blog.csdn.net/qq_36030288/article/details/54576503\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<p><a href=\"https://www.cnblogs.com/zs-note/p/9556390.html\" target=\"_blank\" rel=\"noopener\">前端性能优化：gzip 压缩文件传输数据</a></p>\n<h2 id=\"优化效果分析\"><a href=\"#优化效果分析\" class=\"headerlink\" title=\"优化效果分析\"></a>优化效果分析</h2><p><img src=\"http://img.mrsingsing.com/roadhog-performance-optimizition-result.jpg\" alt=\"优化效果分析\"></p>\n<ul>\n<li>开发体验：70s =&gt; 20s 启动项目时间提升 71%</li>\n<li>构建速度：382s =&gt; 40s 项目构建速度提升 89%</li>\n<li>资源文件：88Mb（未开启 Gzip） =&gt; 25Mb（开启 Gzip） =&gt; 1Mb（优化后开启 Gzip） 资源文件尺寸大幅度降低</li>\n</ul>\n<h2 id=\"后续需要解决的问题\"><a href=\"#后续需要解决的问题\" class=\"headerlink\" title=\"后续需要解决的问题\"></a>后续需要解决的问题</h2><h3 id=\"单独打包的-AntDesign-尺寸过大\"><a href=\"#单独打包的-AntDesign-尺寸过大\" class=\"headerlink\" title=\"单独打包的 AntDesign 尺寸过大\"></a>单独打包的 AntDesign 尺寸过大</h3><ul>\n<li>可视化分析尺寸较大的文件包括 rc-editor-core / draft.js 等</li>\n<li>通过依赖找到根源是 rc-editor-mention =&gt; rc-editor-core =&gt; draft-js 来自 Mention 组件，但是项目中并没有使用到</li>\n<li>得出结果提取打包将整个组件库都打包进来了</li>\n</ul>\n<p>社区中有反应希望提取公共模块打包时将其中某些部分忽略不打包，而维护者似乎告知需要使用 <code>babel-plugin-import</code> 按需引用，并没提供提取公共模块的解决方案。 <a href=\"https://github.com/ant-design/ant-design/issues/10180\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/sorrycc/roadhog/issues/370\" target=\"_blank\" rel=\"noopener\">支持 vendor 的配置 Issue #370</a></li>\n<li><a href=\"https://github.com/sorrycc/roadhog/issues/577\" target=\"_blank\" rel=\"noopener\">roadhog2 如何成功提取 vendor · Issue #577</a></li>\n<li><a href=\"https://github.com/sorrycc/roadhog/issues/722\" target=\"_blank\" rel=\"noopener\">编译很慢 #722</a></li>\n<li><a href=\"https://github.com/liangxinwei/blog/blob/master/webpack/2.md\" target=\"_blank\" rel=\"noopener\">roadhog 1.3x 打包慢的解决办法</a></li>\n<li><a href=\"http://www.mamicode.com/info-detail-2413081.html\" target=\"_blank\" rel=\"noopener\">Roadhog 构建优化</a></li>\n<li><a href=\"https://www.itcodemonkey.com/article/12011.html\" target=\"_blank\" rel=\"noopener\">JS/CSS 体积减少了 67%，我们是如何做到的？</a></li>\n<li><a href=\"https://github.com/creeperyang/blog/issues/37\" target=\"_blank\" rel=\"noopener\">Webpack 日常使用与优化</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><p>目前我司后台系统采用基于 <a href=\"https://github.com/webpack/webpack\" target=\"_blank\" rel=\"noopener\">Webpack</a> 为底层封装的打包工具 <a href=\"https://github.com/sorrycc/roadhog\" target=\"_blank\" rel=\"noopener\">roadhog</a>。开发者通过工具暴露的有限的可配置参数，可以简单明了地针对项目需要进行自定义配置。该款工具的目的很明确，就是为了简化 webpack 的配置。这对于入门级别的工程师是非常友好的，因为降低了学习 webpack 的成本，免去捣鼓 webpack 复杂的配置，方便开发者快速进入开发流程。</p>\n<p>从目前项目版本的 <code>package.json</code> 向上层依赖溯源可以得出这样的依赖关系：</p>\n<blockquote>\n<p>roadhog^2.4.2 =&gt; af-webpack^0.23.0-beta.1 =&gt; webpack^3.56</p>\n</blockquote>\n<p>roadhog 基于 <a href=\"https://github.com/umijs/umi/tree/master/packages/af-webpack\" target=\"_blank\" rel=\"noopener\"><code>umi/af-webpack</code></a> 作为底层。从社区反馈的信息得知，现时（2019.1）作者的工作重点都在 <a href=\"https://github.com/umijs/umi\" target=\"_blank\" rel=\"noopener\">umi</a>，而 roadhog 无打算迭代升级的打算。即便将 roadhog 升级至最新版本，所依赖的底层 webpack 的版本也只是 3.5.6，webpack4+ 的优化配置均无法使用。由于工具文档提供信息有限，因此要将优化进行到极致从源码依赖着手推动项目构建优化是免不了的工作。</p>\n<h2 id=\"构建现况分析\"><a href=\"#构建现况分析\" class=\"headerlink\" title=\"构建现况分析\"></a>构建现况分析</h2><blockquote>\n<p>版本 release/2.29.0</p>\n</blockquote>\n<p><strong>分析材料</strong></p>\n<ul>\n<li>通过 <a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a> 对打包模块进行可视化分析</li>\n<li>对打包出来后的资源文件进行分析</li>\n<li>项目组织结构分析</li>\n</ul>\n<p><strong>构建情况分析</strong></p>\n<ul>\n<li>构建内存占用过高：130% 需要给 node 配置更多内存防止内存溢出导致失败</li>\n<li>构建进度观察：卡在 10%、86%、<strong>91%</strong></li>\n<li>构建使用时间：407s 366s 386s 380s 372s =&gt; 平均 382s</li>\n<li>静态资源数量：分割成共 92 个资源文件（包括入口文件，但除去默认拷贝输出的文件）</li>\n<li>静态资源大小<ul>\n<li>Start：总 150MB，平均，最大 5.05MB</li>\n<li>Parsed：总 88MB，平均，最大 2.48MB</li>\n<li>Gzipped：总 25MB，平均，最大 686.48KB</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>静态资源大小</th>\n<th>数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;2MB</td>\n<td>5</td>\n</tr>\n<tr>\n<td>&gt;1MB</td>\n<td>24</td>\n</tr>\n<tr>\n<td>&gt;500KB</td>\n<td>60</td>\n</tr>\n</tbody>\n</table>","more":"<h2 id=\"项目构建优化方案\"><a href=\"#项目构建优化方案\" class=\"headerlink\" title=\"项目构建优化方案\"></a>项目构建优化方案</h2><p>按照 <a href=\"https://github.com/pigcan/blog/issues/1\" target=\"_blank\" rel=\"noopener\">Webpack 构建性能优化探索</a> 提供的思路，可以从四个维度着手项目构建的优化：</p>\n<ul>\n<li>从环境着手，提升下载依赖速度</li>\n<li>从项目自身着手，代码组织是否合理，依赖使用是否合理，反面提升效率</li>\n<li>从 Webpack 自身优化手段着手，优化配置，提升 Webpack 效率</li>\n<li>从 Webpack 可能存在的不足着手，优化不足，进一步提升效率</li>\n</ul>\n<h3 id=\"去除废弃依赖\"><a href=\"#去除废弃依赖\" class=\"headerlink\" title=\"去除废弃依赖\"></a>去除废弃依赖</h3><p>观察 <code>package.json</code>，发现一些项目中废弃的依赖并没有及时处理，因此把无用的和重复安装的依赖去除。</p>\n<h3 id=\"提取第三方公共模块\"><a href=\"#提取第三方公共模块\" class=\"headerlink\" title=\"提取第三方公共模块\"></a>提取第三方公共模块</h3><p>此前项目中页面代码根据路由按需加载，每个页面 route 和 model 引用的第三方模块，例如 <code>react</code>、<code>dva</code>、<code>query-string</code>、<code>antd</code>、<code>moment</code> 等，都会在各自的页面中重复打包一份，这就导致根据页面分割的资源文件尺寸较大，冗余代码较多。</p>\n<p>除此之外，值得注意的是，项目中使用的 <a href=\"https://github.com/ant-design/ant-design\" target=\"_blank\" rel=\"noopener\">AntDesign</a> 组件，尽管通过 <a href=\"https://github.com/ant-design/babel-plugin-import\" target=\"_blank\" rel=\"noopener\">babel-plugin-import</a> 实现了组件模块的按需加载，页面引用并不会将完整的 AntDesign 引入。但是由于开始时候大部分页面都不会从零开始写，而是会选择移植相似页面的逻辑再加以修改，因此会导致相当一部分页面会将没有使用到的组件进行打包，同样会造成冗余。</p>\n<p>因此，整个项目的性能优化必然从资源依赖的第三方库着手，提前编译提取。</p>\n<p>分析 <code>package.json</code> 可以得知整个项目依赖主要有几个部分：</p>\n<ul>\n<li><a href=\"https://github.com/ant-design/ant-design\" target=\"_blank\" rel=\"noopener\">antd</a> 基础 UI 组件库 📌</li>\n<li><a href=\"https://github.com/dvajs/dva\" target=\"_blank\" rel=\"noopener\">dva</a> 数据管理框架</li>\n<li><a href=\"https://github.com/moment/moment\" target=\"_blank\" rel=\"noopener\">moment</a> 时间操作工具库 📌</li>\n<li><a href=\"https://github.com/ali-sdk/ali-oss\" target=\"_blank\" rel=\"noopener\">ali-oss</a> 阿里云 OSS 插件</li>\n<li><a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">react</a> 界面框架</li>\n<li>react-dom</li>\n<li>react-router-dom</li>\n<li>universal-cookie</li>\n<li>…等等</li>\n</ul>\n<p>roadhog 暴露了 commons 参数对应 Webpack 中 plugins 的多个 <code>webpack.CommonsChunkPlugin</code> 实例。下面有两种可选择的方案供实现：</p>\n<ul>\n<li>被至少固定个数（默认两个） entry/page 依赖即提取公共，这样 common 公共模块会比较大，项目整体尺寸最小，但页面首屏渲染需要加载的资源尺寸会比较大</li>\n<li>被所有 entry/page 依赖才提取为公共，这样 common 公共模块比较小，项目整体尺寸较大</li>\n</ul>\n<p>最终决定将所有依赖的第三方模块提前打包，在用户访问页面时需要将基础工具和基础组件的打包文件先加载，后续用户界面资源文件加载就会相对另一种方案会更加快速。</p>\n<p>相关扩展：</p>\n<ul>\n<li><p><a href=\"https://segmentfault.com/a/1190000012828879\" target=\"_blank\" rel=\"noopener\">详解 CommonsChunkPlugin 的配置和用法</a></p>\n</li>\n<li><p><a href=\"https://juejin.im/post/5c2205e15188257507558c5a\" target=\"_blank\" rel=\"noopener\">webpack.optimize.CommonsChunkPlugin 详解</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/95752b101582\" target=\"_blank\" rel=\"noopener\">webpack、manifest、runtime、缓存与 CommonsChunkPlugin</a></p>\n</li>\n</ul>\n<h3 id=\"第三方模块不同兼容库重复打包\"><a href=\"#第三方模块不同兼容库重复打包\" class=\"headerlink\" title=\"第三方模块不同兼容库重复打包\"></a>第三方模块不同兼容库重复打包</h3><p><img src=\"http://img.mrsingsing.com/roadhog-performance-build-analyze.jpg\" alt=\"优化前打包结果\"></p>\n<p>vendor 提取第三方模块后，发现几个比较大的页面资源文件里仍然存在 antd.lib 组件库的代码，而且这些 <code>ant.lib</code> 都是完整一个模块被打包进了这些页面当中，但其实 AntDesign 已经被我完整单独地打包成另外一个文件了，这个打包的文件是由 <code>ant.es</code> 打包出来的。</p>\n<ul>\n<li>antd.es</li>\n<li>antd.lib</li>\n</ul>\n<p>通过对打包后的文件以及业务代码的检查，发现是引用 Antd 组件库发生了问题，由于使用了 webpack-plugin-import 插件，将 Antd 中名为 es 的组件库按需加载并通过 babel 转化独立打包成 vendor，因此当使用 <code>import {message} from &quot;antd/lib/index&quot;</code> 这种写法的时候，当前页面会将 Antd lib 目录下的组件全部打包，造成页面打包文件臃肿。</p>\n<p>书写规范<br>使用了 extraBabelPlugins 就会按需加载</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// wrong</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; message &#125; <span class=\"keyword\">from</span> <span class=\"string\">'antd/lib/index'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; message &#125; <span class=\"keyword\">from</span> <span class=\"string\">'antd'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"忽略-moment-语言包的打包\"><a href=\"#忽略-moment-语言包的打包\" class=\"headerlink\" title=\"忽略 moment 语言包的打包\"></a>忽略 moment 语言包的打包</h3><p><img src=\"http://img.mrsingsing.com/roadhog-performance-moment-locale.jpg\" alt=\"忽略 moment 语言包\"></p>\n<p>打包后 moment 包的体积比较大，其中 locale 语言包部分占据了比较大的体积，由于我们的项目没有国际化需求，因此可以通过配置 roadhog 提供的 <code>ignoreMomentLocale: true</code> 减少打包出来的 vendor 尺寸。</p>\n<p>但是，如果项目中使用到 AntDesign 组件，并且使用到时间选择组件 <code>date-picker</code>（默认是英文文案），那么这里需要做一些处理以使项目中组件能够显示中文。</p>\n<p>我是在项目最上层，单独引入 moment 的中文语言包。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> moment <span class=\"keyword\">from</span> <span class=\"string\">'moment'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'moment/locale/zh-cn'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">moment.locale(<span class=\"string\">'zh-cn'</span>);</span><br></pre></td></tr></table></figure>\n<p>这样项目中使用到 moment 工具库的 <code>date-picker</code> 都会显示中文文案。</p>\n<h3 id=\"压缩耗时\"><a href=\"#压缩耗时\" class=\"headerlink\" title=\"压缩耗时\"></a>压缩耗时</h3><p>项目构建过程会卡在 91%，通过查阅相关资料和了解社区反馈后，明确原因为该阶段 Webpack 正在对代码进行混淆压缩操作，但同时由于 Webpack 的压缩插件 UglifyJS 无法对 ES6+ 的代码进行压缩，需要使用 <a href=\"https://github.com/babel/minify\" target=\"_blank\" rel=\"noopener\">babel-minify</a> 获取更好的 treeshaking 效果（虽然 Webpack4 已经支持 ES6+ 代码压缩，但是目前 Roadhog 采用的是 Webpack3+）。</p>\n<p><a href=\"https://hackmd.io/YHK_yuRtT0ePPVLY0_kUzw\" target=\"_blank\" rel=\"noopener\">构建速度慢的解决方法@sorrycc</a></p>\n<p>体现特征：</p>\n<ul>\n<li>构建速度慢</li>\n<li>内存消耗高</li>\n</ul>\n<p>解决方法：</p>\n<ul>\n<li>减少依赖文件<ul>\n<li>优化 common 提取策略，让整体尺寸尽可能少</li>\n<li>externals 掉一些大的库，降低整体尺寸</li>\n<li>利用 webpack 的 TreeShaking + es module，排除掉一些没有用到的模块</li>\n</ul>\n</li>\n<li>减少需要压缩的文件</li>\n</ul>\n<h3 id=\"外部扩展\"><a href=\"#外部扩展\" class=\"headerlink\" title=\"外部扩展\"></a>外部扩展</h3><p>externals 是非常有效的一个方案，可以一下子减少大量需要编译、压缩的模块。将一些不常更新版本比较稳定的模块文件直接注入 HMTL 文件，当读取到该脚本时将自动加载，这不仅能加快构建速度，而且能够利用 CDN 进行资源缓存。</p>\n<p>但是会带来的问题是：</p>\n<ul>\n<li>无法利用 Webpack 的 Tree-Shaking</li>\n<li>多个库之间如果存在公共模块（比如 lodash），就无法复用</li>\n</ul>\n<p>使用 externals 需要在 HTML 里引用额外的 JS 文件，这里也有几个潜在的问题：</p>\n<ul>\n<li>如果你的 CDN 不支持 Combo，并且不是 http/2，那么速度会很慢</li>\n<li>你需要手动维护一份 CDN 文件列表，并且跟进他们的更新，也是件麻烦的事情</li>\n</ul>\n<p>这里主要将三个尺寸较大且比较少项目页面引用的模块 externals 掉。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">externals: &#123;</span><br><span class=\"line\">    <span class=\"string\">'ali-oss'</span>: <span class=\"string\">'window.OSS'</span>,</span><br><span class=\"line\">    <span class=\"string\">'react'</span>: <span class=\"string\">'window.react'</span>,</span><br><span class=\"line\">    <span class=\"string\">'react-dom'</span>: <span class=\"string\">'window.ReactDOM'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"项目样式文件减少\"><a href=\"#项目样式文件减少\" class=\"headerlink\" title=\"项目样式文件减少\"></a>项目样式文件减少</h3><p>ExtractTextPlugin 提取 CSS (antd + 业务)</p>\n<p>能用公共就用公共（因为大部分的页面的样式几乎一样），不然每个页面开一个 less 引用公共，会重复打包，造成冗余。</p>\n<h3 id=\"Gzip-传输压缩\"><a href=\"#Gzip-传输压缩\" class=\"headerlink\" title=\"Gzip 传输压缩\"></a>Gzip 传输压缩</h3><p>gzip 需要在服务器配置开启</p>\n<p>这里提供一种 Nginx 的配置。<a href=\"https://blog.csdn.net/qq_36030288/article/details/54576503\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<p><a href=\"https://www.cnblogs.com/zs-note/p/9556390.html\" target=\"_blank\" rel=\"noopener\">前端性能优化：gzip 压缩文件传输数据</a></p>\n<h2 id=\"优化效果分析\"><a href=\"#优化效果分析\" class=\"headerlink\" title=\"优化效果分析\"></a>优化效果分析</h2><p><img src=\"http://img.mrsingsing.com/roadhog-performance-optimizition-result.jpg\" alt=\"优化效果分析\"></p>\n<ul>\n<li>开发体验：70s =&gt; 20s 启动项目时间提升 71%</li>\n<li>构建速度：382s =&gt; 40s 项目构建速度提升 89%</li>\n<li>资源文件：88Mb（未开启 Gzip） =&gt; 25Mb（开启 Gzip） =&gt; 1Mb（优化后开启 Gzip） 资源文件尺寸大幅度降低</li>\n</ul>\n<h2 id=\"后续需要解决的问题\"><a href=\"#后续需要解决的问题\" class=\"headerlink\" title=\"后续需要解决的问题\"></a>后续需要解决的问题</h2><h3 id=\"单独打包的-AntDesign-尺寸过大\"><a href=\"#单独打包的-AntDesign-尺寸过大\" class=\"headerlink\" title=\"单独打包的 AntDesign 尺寸过大\"></a>单独打包的 AntDesign 尺寸过大</h3><ul>\n<li>可视化分析尺寸较大的文件包括 rc-editor-core / draft.js 等</li>\n<li>通过依赖找到根源是 rc-editor-mention =&gt; rc-editor-core =&gt; draft-js 来自 Mention 组件，但是项目中并没有使用到</li>\n<li>得出结果提取打包将整个组件库都打包进来了</li>\n</ul>\n<p>社区中有反应希望提取公共模块打包时将其中某些部分忽略不打包，而维护者似乎告知需要使用 <code>babel-plugin-import</code> 按需引用，并没提供提取公共模块的解决方案。 <a href=\"https://github.com/ant-design/ant-design/issues/10180\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/sorrycc/roadhog/issues/370\" target=\"_blank\" rel=\"noopener\">支持 vendor 的配置 Issue #370</a></li>\n<li><a href=\"https://github.com/sorrycc/roadhog/issues/577\" target=\"_blank\" rel=\"noopener\">roadhog2 如何成功提取 vendor · Issue #577</a></li>\n<li><a href=\"https://github.com/sorrycc/roadhog/issues/722\" target=\"_blank\" rel=\"noopener\">编译很慢 #722</a></li>\n<li><a href=\"https://github.com/liangxinwei/blog/blob/master/webpack/2.md\" target=\"_blank\" rel=\"noopener\">roadhog 1.3x 打包慢的解决办法</a></li>\n<li><a href=\"http://www.mamicode.com/info-detail-2413081.html\" target=\"_blank\" rel=\"noopener\">Roadhog 构建优化</a></li>\n<li><a href=\"https://www.itcodemonkey.com/article/12011.html\" target=\"_blank\" rel=\"noopener\">JS/CSS 体积减少了 67%，我们是如何做到的？</a></li>\n<li><a href=\"https://github.com/creeperyang/blog/issues/37\" target=\"_blank\" rel=\"noopener\">Webpack 日常使用与优化</a></li>\n</ul>"},{"title":"前端深耕落地页业务心得总结","date":"2020-06-07T00:00:00.000Z","_content":"\n在科技繁荣的今天，计算机给现代社会带来的是信息化的变革，本质上打破的是原有社会人们地理、语言、人种等各维度上的差异，通过互联网人们能通过便捷的方式足不出户口，就可以购买到全国乃至全球的商品货物、享受到各式各样的差异化服务。因此，对于一家互联网企业来说，用户无疑是最重要的资产，让更多的用户知道、了解甚至享受企业的产品，是企业立足的前提条件，毕竟有了用户方有盈利的可能性，企业才能可持续发展。\n\n对于国内很多大厂的来说，某种程度上在用户这个维度上会投入大量资源，诸如设立专门负责用户增长的组织单位。他们关注用户在产品终端的体验，相关从业人员需要懂得抓住用户心里，结合各种业务场景制定对应的营销策略，最终目的就是留住用户，让用户心甘情愿地消费。\n\n笔者就职于与某互联网金融企业，由于最近经常需要和产品、推广、运营打交道，多多少少会接触到很多庞杂的知识边界外的领域，所以打算系统整理这段时间来的业务分析方法论和实践心得。\n\n<!-- more -->\n\n## 落地页\n\n所谓的落地页（Landing Page）就是用于承接用户通过付费搜索渠道进入的推广页面。\n\n在如今广告横霸天下的互联网社会，我们用百度搜索结果出来后插在开头的结果，在腾讯视频看剧时突然蹦出来的小广告，刷知乎或者微信朋友圈穿插在信息流当中的「伪」信息，抑或是淘宝店家、保险公司、移动联通电信等隔三差五给你发的短信里的短链接，基本都可以归类为落地页的入口。通常由知名度不足的广告商付费购买推广位，利用知名度较高的渠道建立用户与自家产品的认知关系，而落地页就是关键的载体。\n\n其实落地页的类型能细分出很多种，主要分为营销活动页、信息收集页、应用推广页、唤醒找回页等，各有各的职责。\n\n### 营销活动页\n\n营销活动页的目的是为了让你的用户知道你的产品是什么、能提供什么服务、能解决用户什么需求。通过落地页能直接展示或跳转至 APP 内的核心业务，起到承接流量的作用。页面的内容通常比较简洁，会用到大量设计感高的图片和醒目的文案，为用户展示自己的活动和商品，通过类似优惠价格和赠品等手段引导用户点击，获取到用户信息后，后续再与客户联系，最终将这些潜在的用户转化为真正的用户。\n\n![营销活动页](http://img.mrsingsing.com/landing-page-marketing.jpg)\n\n### 信息搜集页\n\n信息搜集页适用于业务复杂或低频类的产品，当产品核心业务设计到大额交易、定制服务、响应周期长等特征的时候，落地页的任务更像是给用户一个承诺，许诺会有大量优惠的福利，留下个人信息以便平台后续专员的电访。回想起很多诸如职业培训的公司，是不是网页加载后都会弹窗让你填写个人信息，然后几天内就会接到他们电话向你推销课程。\n\n![信息搜集页](http://img.mrsingsing.com/landing-page-information.jpg)\n\n### 应用推广页\n\n应用推广页的目的很明确，就是引导用户下载应用、注册、登录等。\n\n![应用推广页](http://img.mrsingsing.com/landing-page-application-promotion.jpg)\n\n### 唤醒找回页\n\n日活月活是互联网应用很重要的活性指标，唤醒找回页的使命就是激活那些流失掉的用户，通过短信、邮件、消息通知等主动反馈的形式吸引老用户回归应用。\n\n![唤醒找回页](http://img.mrsingsing.com/landing-page-awaken.jpg)\n\n## 数据指标与转化率分析\n\n### 数据指标\n\n落地页的实际效果需要量化指标来衡量，下面从运营角度列出了一些落地页建设需要关注的指标。\n\n![落地页指标](http://img.mrsingsing.com/landing-page-pointer.jpg)\n\n- **页面浏览量**：指页面被用户浏览的次数，严格意义上指用户向网站发出并完成下载页面的请求\n- **点击率**：网页内某内容被点击次数与显示次数之比\n- **跳出率**：衡量落地页质量好坏的重要指标。页面跳出率的计算为该页面作为落地页跳出的访问次数占该页面作为落地页访问次数的百分比，全站跳出率则为跳出的访问次数除以总的访问次数。\n- **停留时长**：用于衡量用户与网站/APP 交互深度，一般有页面停留时长，会话时长以及平均停留时长等概念，其计算的核心原理在于记录下用户行为发生时的时间戳，后期再应用相应公式来计算\n- **交互深度**：指用户在一次浏览网页或 APP 过程中，访问了多少页面。用户在一次浏览中访问的页面越多，交互深度就越深。交互深度能够侧面反映网站或 APP 对于用户的吸引力。\n  可以通过 Session 来计算用户的平均交互深度。\n\n除此之外还有一些我们会经常听到的一些核心指标：\n\n- **DAU（Daily Activited Users）**：日活跃用户数量，统计单日内，登录或使用某个产品的用户数（去除重复登录的用户）\n- **MAU（Monthly Activited Users**）：月活跃用户数量，统计单月内，登录或使用某个产品的用户数（去除重复登录的用户）\n- **PV（Page View）**：页面浏览量和点击量，用户每次对网页进行访问被记录为一次\n- **UV（Unique View）**：独立访客，访问网站的一个终端为一个访客\n- **转化率**：一个统计周期内，完成转化行为的次数占推广信息总点击次数的比率。\n- **留存率**：某一统计时段内的新增用户数中经过一段时间后仍启动该应用的用户比例。\n\n### 漏斗模型\n\n衡量指标需要落实到具体的分析模型，而漏斗模型则是最常用的评判落地页转化效果的工具。漏斗模型的实现原理是在潜在用户从访问页面到最终转换成真正用户这个行为路径上的关键节点进行埋点收集行为数据，并根据不同关键节点的特性设定不同目标，最后通过各阶段的转化情况改善关键节点转化的流程设计，从而提升用户体验。\n\n以我最熟悉的引导流量的注册落地页为例，页面呈现仅有手机号输入框、短信验证码输入框、密码输入框和注册按钮等四个主要的可交互元素，理想的新用户注册流程大概是这样的：\n\n```\n访问页面 -> 输入手机号 -> 下发短信验证码 -> 输入验证码 -> 输入账号密码 -> 点击注册按钮 -> 服务端进行注册处理 -> 注册成功\n```\n\n转化漏斗可以添加多个交互步骤，比如当用户输入手机号后，前端自动检测输入值由正则校验有效后，则上报标记为 `输入手机号` 的埋点，在用户获取到短信验证码，同样地输入短信验证码并校验有效后，即上报 `输入验证码` 的埋点。通过添加两个关键节点的埋点，使用转化漏斗配合可视化视图，我们就能清晰地知道有多少用户完成了 `输入手机号` 到 `输入验证码` 这个步骤，而通过 `输入手机号` 的人数减去 `输入验证码` 的人数，我们就能获知该阶段流失的用户数。\n\n转化率需要 **对比**，不能在分析的时候发现某个环节的转化率太低，就认为一定是这个环节出现了问题。比如从 `输入手机号` 到 `注册成功` 这个环节转化率只有 40%（虚构数据），是所有环节中最低的，但我们可以用历史数据进行比较，从**趋势**的变化分析转化效果，上个月同期该环节的转化率页是 38%，行业同类产品均值是 36%，那么其实该环节做得还是不错的。我们看后面的环节，从 `注册成功` 到 `进入 APP 应用` 的环节的转化率是 62%（虚构数据），跟其他环节相比较起来，这个转化率是最高的，但是我们对比行业同类型产品会发现均值是 90%（虚构数据），对比上个月同期这个比率是 91%（虚构数据），那么我们可以发现当前这个月，落地页从注册成功到登录 APP 应用的转化率是做得非常不好的，其实这个就回到我们数据分析中的对比分析了，我们需要与自己的历史数据做对比，才能得出完整的结论，当然另外一点是不同的用户，对比在交互流程中的转化率是可以有很大的差异的，像客户来自不同的渠道、不同的区域、不同的生命周期、不同性别、不同年龄，他们在漏斗中的表现都是不一样的，所以我们在进行漏斗分析的时候，往往还需要进行细分的漏斗模型分析，\n\n如果转化率并不理想，我们可以通过 **细分维度** 对转化率进行拆解，比如我们可以通过操作系统维度（例如分为 Android 和 iOS）看到不同操作系统的阶段转化情况，也可以选择浏览器（Chrome、Safari、Firefox 和 微信内置浏览器等）看到不同浏览器的阶段转化情况，甚至可以选择设备的品牌来看到对应的阶段转化情况。如果某个转化率明显低于正常的转化率情况，那么我们可以合理怀疑页面这个操作系统、品牌或浏览器上，兼容性做得不够。\n\n综合以上，可以得出基于漏斗模型的分析方法有以下几种：\n\n- **趋势（Trend）**：从 `时间轴` 的变化情况进行分析，适用于对某一流程或其中某个步骤进行改进或优化的效果监控。\n- **比较（Compare）**：通过比较 `类似产品或服务间` 购买或使用流程的转化率，发现某些产品或应用中存在的问题。\n- **细分（Segment）**：细分来源或 `不同的客户类型` 在转化率上的表现，发现一些高质量的来源或客户，通常用于分析网站的广告或推广的效果及 ROI。\n\n### A/B 测试\n\nA/B 测试是为了 Web 或 App 界面或流程制作两个或多个版本，在相同时间维度，分别让组成成分相同（相似）的访客群组（目标人群）随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估初最好版本，正式采用。\n\n通过 A/B 测试可以有效减少基于假设前提的各种无谓争论。通过 A/B 测试可以看到用户面对不同落地页元素的真实反应、用户更容易点击落地页的哪些位置，从而得出修改页面元素的有力证据。\n\n因为经常需要在流量分配时有所权衡，一般有以下几个情况：\n\n- 不影响用户体验：如 UI 实验、文案类实验等，一般可以均匀分配流量实验，可以快速得到实验结论\n- 不确定性较强的实验：如产品新功能上线，一般需小流量实验，尽量减少用户体验影响，在允许的时间内得到结论\n- 希望收益最大化的实验：如运营活动等，尽可能将效果最大化，一般需要大流量实验，留出小部分对照组用于评估 ROI\n\n因为通常单个链接的落地页不具备 A/B test 的功能，需要配合专门用于 A/B test 页面分发的系统进行流量分配，实际上通过类似反向代理的原理，根据分配到不同的页面的比例将标识 A/B 不同页面返回给用户展示。\n\n由于我们的注册落地页是使用可视化页面搭建系统配置的，并不支持 A/B 测试，所以搭配另一套前端的集成系统和客户端的 CMS 系统，能够实现对页面的 A/B 测试。而在页面的埋点统计中，需要上报 A/B 的标识，以便后续业务数据的追踪和评估结果，进而得出测试结论并指导落地页改进。\n\n### 数据校验流程\n\n对于分析师来说，数据分析的结论正确的前提是数据来源的正确性，也就是技术人员需要确保数据采集的准确性。\n\n数据采集的正确性校验：\n\n1. 事件是否上报\n2. 事件属性是否上报，上报的属性值是否正确\n3. 公共属性是否上报，上报的公共属性值是否过正确\n4. 如果上传了用户属性，用户属性是否上报正确\n5. 事件属性和用户属性的属性值类型是否正确\n\n用户关联的正确性校验：\n\n1. 是否做了用户关联\n2. 登录 ID 是否上传正确\n3. 是否正确调用用户关联的接口\n\n如果使用漏斗模型进行分析时，上报埋点的时机要确保符合顺序，在用户端上报时间与统计平台的埋点入库时间也是需要注意的点。\n\n`埋点管理` -> `实时导入数据查询` -> `用户 ID` 查询用户关联的准确性\n\n---\n\n**参考资料：**\n\n- 产品设计\n  - [高转化率的 APP 推广落地页是怎样炼成的](http://www.woshipm.com/pd/3079851.html)\n  - [那些制作落地页的套路](https://www.jianshu.com/p/21db3a53b9e7)\n  - [如何提升落地页转化率](https://www.shujike.com/blog/77744)\n  - [什么是落地页](https://zhuanlan.zhihu.com/p/33882407)\n  - [你问我答 12 个流量和转化相关的实战问题解答](https://www.27sem.com/article/3634.html)\n  - [高转化的落地页长啥样](https://zhuanlan.zhihu.com/p/36165204)\n- 数据分析\n  - [产品运营的基本功 漏斗模型](https://www.yunyingpai.com/user/199.html)\n  - [案例分享 渠道落地页数据分析](https://www.sohu.com/a/345808493_165070)\n  - [网页转化率与漏斗模型](http://menvscode.com/detail/5bfc20d030be6232a69c5d94)\n  - [优秀产品人必懂的数据驱动增长模型](https://www.niaogebiji.com/article-26780-1.html)\n  - [使用 Sensors Analytics 进行 A/B Test](https://www.sensorsdata.cn/blog/shi-yong-sensors-analytics-jin-xing-a-b-test/)\n  - [深度 A/B 测试中的因果推断——潜在结果模型](https://juejin.im/post/585b7fc161ff4b0058032b84)\n  - [销售线索居低不上，你唯一要做的是落地页 A/B 测试](https://www.infoq.cn/article/PyOwiqA1zmuIcXqySb7V)\n- 扩展阅读\n  - [淘宝用户行为数据分析详解](https://www.jianshu.com/p/4f64d739fba2)\n  - [美团 DSP 广告策略实践](https://tech.meituan.com/2017/05/05/mt-dsp.html)\n  - [日志采集与用户行为链路分析](https://www.jianshu.com/p/ab04b1e3a512)\n","source":"_posts/business-experience-summary-of-lading-page.md","raw":"---\ntitle: 前端深耕落地页业务心得总结\ndate: '2020-06-07'\n---\n\n在科技繁荣的今天，计算机给现代社会带来的是信息化的变革，本质上打破的是原有社会人们地理、语言、人种等各维度上的差异，通过互联网人们能通过便捷的方式足不出户口，就可以购买到全国乃至全球的商品货物、享受到各式各样的差异化服务。因此，对于一家互联网企业来说，用户无疑是最重要的资产，让更多的用户知道、了解甚至享受企业的产品，是企业立足的前提条件，毕竟有了用户方有盈利的可能性，企业才能可持续发展。\n\n对于国内很多大厂的来说，某种程度上在用户这个维度上会投入大量资源，诸如设立专门负责用户增长的组织单位。他们关注用户在产品终端的体验，相关从业人员需要懂得抓住用户心里，结合各种业务场景制定对应的营销策略，最终目的就是留住用户，让用户心甘情愿地消费。\n\n笔者就职于与某互联网金融企业，由于最近经常需要和产品、推广、运营打交道，多多少少会接触到很多庞杂的知识边界外的领域，所以打算系统整理这段时间来的业务分析方法论和实践心得。\n\n<!-- more -->\n\n## 落地页\n\n所谓的落地页（Landing Page）就是用于承接用户通过付费搜索渠道进入的推广页面。\n\n在如今广告横霸天下的互联网社会，我们用百度搜索结果出来后插在开头的结果，在腾讯视频看剧时突然蹦出来的小广告，刷知乎或者微信朋友圈穿插在信息流当中的「伪」信息，抑或是淘宝店家、保险公司、移动联通电信等隔三差五给你发的短信里的短链接，基本都可以归类为落地页的入口。通常由知名度不足的广告商付费购买推广位，利用知名度较高的渠道建立用户与自家产品的认知关系，而落地页就是关键的载体。\n\n其实落地页的类型能细分出很多种，主要分为营销活动页、信息收集页、应用推广页、唤醒找回页等，各有各的职责。\n\n### 营销活动页\n\n营销活动页的目的是为了让你的用户知道你的产品是什么、能提供什么服务、能解决用户什么需求。通过落地页能直接展示或跳转至 APP 内的核心业务，起到承接流量的作用。页面的内容通常比较简洁，会用到大量设计感高的图片和醒目的文案，为用户展示自己的活动和商品，通过类似优惠价格和赠品等手段引导用户点击，获取到用户信息后，后续再与客户联系，最终将这些潜在的用户转化为真正的用户。\n\n![营销活动页](http://img.mrsingsing.com/landing-page-marketing.jpg)\n\n### 信息搜集页\n\n信息搜集页适用于业务复杂或低频类的产品，当产品核心业务设计到大额交易、定制服务、响应周期长等特征的时候，落地页的任务更像是给用户一个承诺，许诺会有大量优惠的福利，留下个人信息以便平台后续专员的电访。回想起很多诸如职业培训的公司，是不是网页加载后都会弹窗让你填写个人信息，然后几天内就会接到他们电话向你推销课程。\n\n![信息搜集页](http://img.mrsingsing.com/landing-page-information.jpg)\n\n### 应用推广页\n\n应用推广页的目的很明确，就是引导用户下载应用、注册、登录等。\n\n![应用推广页](http://img.mrsingsing.com/landing-page-application-promotion.jpg)\n\n### 唤醒找回页\n\n日活月活是互联网应用很重要的活性指标，唤醒找回页的使命就是激活那些流失掉的用户，通过短信、邮件、消息通知等主动反馈的形式吸引老用户回归应用。\n\n![唤醒找回页](http://img.mrsingsing.com/landing-page-awaken.jpg)\n\n## 数据指标与转化率分析\n\n### 数据指标\n\n落地页的实际效果需要量化指标来衡量，下面从运营角度列出了一些落地页建设需要关注的指标。\n\n![落地页指标](http://img.mrsingsing.com/landing-page-pointer.jpg)\n\n- **页面浏览量**：指页面被用户浏览的次数，严格意义上指用户向网站发出并完成下载页面的请求\n- **点击率**：网页内某内容被点击次数与显示次数之比\n- **跳出率**：衡量落地页质量好坏的重要指标。页面跳出率的计算为该页面作为落地页跳出的访问次数占该页面作为落地页访问次数的百分比，全站跳出率则为跳出的访问次数除以总的访问次数。\n- **停留时长**：用于衡量用户与网站/APP 交互深度，一般有页面停留时长，会话时长以及平均停留时长等概念，其计算的核心原理在于记录下用户行为发生时的时间戳，后期再应用相应公式来计算\n- **交互深度**：指用户在一次浏览网页或 APP 过程中，访问了多少页面。用户在一次浏览中访问的页面越多，交互深度就越深。交互深度能够侧面反映网站或 APP 对于用户的吸引力。\n  可以通过 Session 来计算用户的平均交互深度。\n\n除此之外还有一些我们会经常听到的一些核心指标：\n\n- **DAU（Daily Activited Users）**：日活跃用户数量，统计单日内，登录或使用某个产品的用户数（去除重复登录的用户）\n- **MAU（Monthly Activited Users**）：月活跃用户数量，统计单月内，登录或使用某个产品的用户数（去除重复登录的用户）\n- **PV（Page View）**：页面浏览量和点击量，用户每次对网页进行访问被记录为一次\n- **UV（Unique View）**：独立访客，访问网站的一个终端为一个访客\n- **转化率**：一个统计周期内，完成转化行为的次数占推广信息总点击次数的比率。\n- **留存率**：某一统计时段内的新增用户数中经过一段时间后仍启动该应用的用户比例。\n\n### 漏斗模型\n\n衡量指标需要落实到具体的分析模型，而漏斗模型则是最常用的评判落地页转化效果的工具。漏斗模型的实现原理是在潜在用户从访问页面到最终转换成真正用户这个行为路径上的关键节点进行埋点收集行为数据，并根据不同关键节点的特性设定不同目标，最后通过各阶段的转化情况改善关键节点转化的流程设计，从而提升用户体验。\n\n以我最熟悉的引导流量的注册落地页为例，页面呈现仅有手机号输入框、短信验证码输入框、密码输入框和注册按钮等四个主要的可交互元素，理想的新用户注册流程大概是这样的：\n\n```\n访问页面 -> 输入手机号 -> 下发短信验证码 -> 输入验证码 -> 输入账号密码 -> 点击注册按钮 -> 服务端进行注册处理 -> 注册成功\n```\n\n转化漏斗可以添加多个交互步骤，比如当用户输入手机号后，前端自动检测输入值由正则校验有效后，则上报标记为 `输入手机号` 的埋点，在用户获取到短信验证码，同样地输入短信验证码并校验有效后，即上报 `输入验证码` 的埋点。通过添加两个关键节点的埋点，使用转化漏斗配合可视化视图，我们就能清晰地知道有多少用户完成了 `输入手机号` 到 `输入验证码` 这个步骤，而通过 `输入手机号` 的人数减去 `输入验证码` 的人数，我们就能获知该阶段流失的用户数。\n\n转化率需要 **对比**，不能在分析的时候发现某个环节的转化率太低，就认为一定是这个环节出现了问题。比如从 `输入手机号` 到 `注册成功` 这个环节转化率只有 40%（虚构数据），是所有环节中最低的，但我们可以用历史数据进行比较，从**趋势**的变化分析转化效果，上个月同期该环节的转化率页是 38%，行业同类产品均值是 36%，那么其实该环节做得还是不错的。我们看后面的环节，从 `注册成功` 到 `进入 APP 应用` 的环节的转化率是 62%（虚构数据），跟其他环节相比较起来，这个转化率是最高的，但是我们对比行业同类型产品会发现均值是 90%（虚构数据），对比上个月同期这个比率是 91%（虚构数据），那么我们可以发现当前这个月，落地页从注册成功到登录 APP 应用的转化率是做得非常不好的，其实这个就回到我们数据分析中的对比分析了，我们需要与自己的历史数据做对比，才能得出完整的结论，当然另外一点是不同的用户，对比在交互流程中的转化率是可以有很大的差异的，像客户来自不同的渠道、不同的区域、不同的生命周期、不同性别、不同年龄，他们在漏斗中的表现都是不一样的，所以我们在进行漏斗分析的时候，往往还需要进行细分的漏斗模型分析，\n\n如果转化率并不理想，我们可以通过 **细分维度** 对转化率进行拆解，比如我们可以通过操作系统维度（例如分为 Android 和 iOS）看到不同操作系统的阶段转化情况，也可以选择浏览器（Chrome、Safari、Firefox 和 微信内置浏览器等）看到不同浏览器的阶段转化情况，甚至可以选择设备的品牌来看到对应的阶段转化情况。如果某个转化率明显低于正常的转化率情况，那么我们可以合理怀疑页面这个操作系统、品牌或浏览器上，兼容性做得不够。\n\n综合以上，可以得出基于漏斗模型的分析方法有以下几种：\n\n- **趋势（Trend）**：从 `时间轴` 的变化情况进行分析，适用于对某一流程或其中某个步骤进行改进或优化的效果监控。\n- **比较（Compare）**：通过比较 `类似产品或服务间` 购买或使用流程的转化率，发现某些产品或应用中存在的问题。\n- **细分（Segment）**：细分来源或 `不同的客户类型` 在转化率上的表现，发现一些高质量的来源或客户，通常用于分析网站的广告或推广的效果及 ROI。\n\n### A/B 测试\n\nA/B 测试是为了 Web 或 App 界面或流程制作两个或多个版本，在相同时间维度，分别让组成成分相同（相似）的访客群组（目标人群）随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估初最好版本，正式采用。\n\n通过 A/B 测试可以有效减少基于假设前提的各种无谓争论。通过 A/B 测试可以看到用户面对不同落地页元素的真实反应、用户更容易点击落地页的哪些位置，从而得出修改页面元素的有力证据。\n\n因为经常需要在流量分配时有所权衡，一般有以下几个情况：\n\n- 不影响用户体验：如 UI 实验、文案类实验等，一般可以均匀分配流量实验，可以快速得到实验结论\n- 不确定性较强的实验：如产品新功能上线，一般需小流量实验，尽量减少用户体验影响，在允许的时间内得到结论\n- 希望收益最大化的实验：如运营活动等，尽可能将效果最大化，一般需要大流量实验，留出小部分对照组用于评估 ROI\n\n因为通常单个链接的落地页不具备 A/B test 的功能，需要配合专门用于 A/B test 页面分发的系统进行流量分配，实际上通过类似反向代理的原理，根据分配到不同的页面的比例将标识 A/B 不同页面返回给用户展示。\n\n由于我们的注册落地页是使用可视化页面搭建系统配置的，并不支持 A/B 测试，所以搭配另一套前端的集成系统和客户端的 CMS 系统，能够实现对页面的 A/B 测试。而在页面的埋点统计中，需要上报 A/B 的标识，以便后续业务数据的追踪和评估结果，进而得出测试结论并指导落地页改进。\n\n### 数据校验流程\n\n对于分析师来说，数据分析的结论正确的前提是数据来源的正确性，也就是技术人员需要确保数据采集的准确性。\n\n数据采集的正确性校验：\n\n1. 事件是否上报\n2. 事件属性是否上报，上报的属性值是否正确\n3. 公共属性是否上报，上报的公共属性值是否过正确\n4. 如果上传了用户属性，用户属性是否上报正确\n5. 事件属性和用户属性的属性值类型是否正确\n\n用户关联的正确性校验：\n\n1. 是否做了用户关联\n2. 登录 ID 是否上传正确\n3. 是否正确调用用户关联的接口\n\n如果使用漏斗模型进行分析时，上报埋点的时机要确保符合顺序，在用户端上报时间与统计平台的埋点入库时间也是需要注意的点。\n\n`埋点管理` -> `实时导入数据查询` -> `用户 ID` 查询用户关联的准确性\n\n---\n\n**参考资料：**\n\n- 产品设计\n  - [高转化率的 APP 推广落地页是怎样炼成的](http://www.woshipm.com/pd/3079851.html)\n  - [那些制作落地页的套路](https://www.jianshu.com/p/21db3a53b9e7)\n  - [如何提升落地页转化率](https://www.shujike.com/blog/77744)\n  - [什么是落地页](https://zhuanlan.zhihu.com/p/33882407)\n  - [你问我答 12 个流量和转化相关的实战问题解答](https://www.27sem.com/article/3634.html)\n  - [高转化的落地页长啥样](https://zhuanlan.zhihu.com/p/36165204)\n- 数据分析\n  - [产品运营的基本功 漏斗模型](https://www.yunyingpai.com/user/199.html)\n  - [案例分享 渠道落地页数据分析](https://www.sohu.com/a/345808493_165070)\n  - [网页转化率与漏斗模型](http://menvscode.com/detail/5bfc20d030be6232a69c5d94)\n  - [优秀产品人必懂的数据驱动增长模型](https://www.niaogebiji.com/article-26780-1.html)\n  - [使用 Sensors Analytics 进行 A/B Test](https://www.sensorsdata.cn/blog/shi-yong-sensors-analytics-jin-xing-a-b-test/)\n  - [深度 A/B 测试中的因果推断——潜在结果模型](https://juejin.im/post/585b7fc161ff4b0058032b84)\n  - [销售线索居低不上，你唯一要做的是落地页 A/B 测试](https://www.infoq.cn/article/PyOwiqA1zmuIcXqySb7V)\n- 扩展阅读\n  - [淘宝用户行为数据分析详解](https://www.jianshu.com/p/4f64d739fba2)\n  - [美团 DSP 广告策略实践](https://tech.meituan.com/2017/05/05/mt-dsp.html)\n  - [日志采集与用户行为链路分析](https://www.jianshu.com/p/ab04b1e3a512)\n","slug":"business-experience-summary-of-lading-page","published":1,"updated":"2021-08-18T03:28:02.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99yt0005v31pieo7x0eh","content":"<p>在科技繁荣的今天，计算机给现代社会带来的是信息化的变革，本质上打破的是原有社会人们地理、语言、人种等各维度上的差异，通过互联网人们能通过便捷的方式足不出户口，就可以购买到全国乃至全球的商品货物、享受到各式各样的差异化服务。因此，对于一家互联网企业来说，用户无疑是最重要的资产，让更多的用户知道、了解甚至享受企业的产品，是企业立足的前提条件，毕竟有了用户方有盈利的可能性，企业才能可持续发展。</p>\n<p>对于国内很多大厂的来说，某种程度上在用户这个维度上会投入大量资源，诸如设立专门负责用户增长的组织单位。他们关注用户在产品终端的体验，相关从业人员需要懂得抓住用户心里，结合各种业务场景制定对应的营销策略，最终目的就是留住用户，让用户心甘情愿地消费。</p>\n<p>笔者就职于与某互联网金融企业，由于最近经常需要和产品、推广、运营打交道，多多少少会接触到很多庞杂的知识边界外的领域，所以打算系统整理这段时间来的业务分析方法论和实践心得。</p>\n<a id=\"more\"></a>\n<h2 id=\"落地页\"><a href=\"#落地页\" class=\"headerlink\" title=\"落地页\"></a>落地页</h2><p>所谓的落地页（Landing Page）就是用于承接用户通过付费搜索渠道进入的推广页面。</p>\n<p>在如今广告横霸天下的互联网社会，我们用百度搜索结果出来后插在开头的结果，在腾讯视频看剧时突然蹦出来的小广告，刷知乎或者微信朋友圈穿插在信息流当中的「伪」信息，抑或是淘宝店家、保险公司、移动联通电信等隔三差五给你发的短信里的短链接，基本都可以归类为落地页的入口。通常由知名度不足的广告商付费购买推广位，利用知名度较高的渠道建立用户与自家产品的认知关系，而落地页就是关键的载体。</p>\n<p>其实落地页的类型能细分出很多种，主要分为营销活动页、信息收集页、应用推广页、唤醒找回页等，各有各的职责。</p>\n<h3 id=\"营销活动页\"><a href=\"#营销活动页\" class=\"headerlink\" title=\"营销活动页\"></a>营销活动页</h3><p>营销活动页的目的是为了让你的用户知道你的产品是什么、能提供什么服务、能解决用户什么需求。通过落地页能直接展示或跳转至 APP 内的核心业务，起到承接流量的作用。页面的内容通常比较简洁，会用到大量设计感高的图片和醒目的文案，为用户展示自己的活动和商品，通过类似优惠价格和赠品等手段引导用户点击，获取到用户信息后，后续再与客户联系，最终将这些潜在的用户转化为真正的用户。</p>\n<p><img src=\"http://img.mrsingsing.com/landing-page-marketing.jpg\" alt=\"营销活动页\"></p>\n<h3 id=\"信息搜集页\"><a href=\"#信息搜集页\" class=\"headerlink\" title=\"信息搜集页\"></a>信息搜集页</h3><p>信息搜集页适用于业务复杂或低频类的产品，当产品核心业务设计到大额交易、定制服务、响应周期长等特征的时候，落地页的任务更像是给用户一个承诺，许诺会有大量优惠的福利，留下个人信息以便平台后续专员的电访。回想起很多诸如职业培训的公司，是不是网页加载后都会弹窗让你填写个人信息，然后几天内就会接到他们电话向你推销课程。</p>\n<p><img src=\"http://img.mrsingsing.com/landing-page-information.jpg\" alt=\"信息搜集页\"></p>\n<h3 id=\"应用推广页\"><a href=\"#应用推广页\" class=\"headerlink\" title=\"应用推广页\"></a>应用推广页</h3><p>应用推广页的目的很明确，就是引导用户下载应用、注册、登录等。</p>\n<p><img src=\"http://img.mrsingsing.com/landing-page-application-promotion.jpg\" alt=\"应用推广页\"></p>\n<h3 id=\"唤醒找回页\"><a href=\"#唤醒找回页\" class=\"headerlink\" title=\"唤醒找回页\"></a>唤醒找回页</h3><p>日活月活是互联网应用很重要的活性指标，唤醒找回页的使命就是激活那些流失掉的用户，通过短信、邮件、消息通知等主动反馈的形式吸引老用户回归应用。</p>\n<p><img src=\"http://img.mrsingsing.com/landing-page-awaken.jpg\" alt=\"唤醒找回页\"></p>\n<h2 id=\"数据指标与转化率分析\"><a href=\"#数据指标与转化率分析\" class=\"headerlink\" title=\"数据指标与转化率分析\"></a>数据指标与转化率分析</h2><h3 id=\"数据指标\"><a href=\"#数据指标\" class=\"headerlink\" title=\"数据指标\"></a>数据指标</h3><p>落地页的实际效果需要量化指标来衡量，下面从运营角度列出了一些落地页建设需要关注的指标。</p>\n<p><img src=\"http://img.mrsingsing.com/landing-page-pointer.jpg\" alt=\"落地页指标\"></p>\n<ul>\n<li><strong>页面浏览量</strong>：指页面被用户浏览的次数，严格意义上指用户向网站发出并完成下载页面的请求</li>\n<li><strong>点击率</strong>：网页内某内容被点击次数与显示次数之比</li>\n<li><strong>跳出率</strong>：衡量落地页质量好坏的重要指标。页面跳出率的计算为该页面作为落地页跳出的访问次数占该页面作为落地页访问次数的百分比，全站跳出率则为跳出的访问次数除以总的访问次数。</li>\n<li><strong>停留时长</strong>：用于衡量用户与网站/APP 交互深度，一般有页面停留时长，会话时长以及平均停留时长等概念，其计算的核心原理在于记录下用户行为发生时的时间戳，后期再应用相应公式来计算</li>\n<li><strong>交互深度</strong>：指用户在一次浏览网页或 APP 过程中，访问了多少页面。用户在一次浏览中访问的页面越多，交互深度就越深。交互深度能够侧面反映网站或 APP 对于用户的吸引力。<br>可以通过 Session 来计算用户的平均交互深度。</li>\n</ul>\n<p>除此之外还有一些我们会经常听到的一些核心指标：</p>\n<ul>\n<li><strong>DAU（Daily Activited Users）</strong>：日活跃用户数量，统计单日内，登录或使用某个产品的用户数（去除重复登录的用户）</li>\n<li><strong>MAU（Monthly Activited Users</strong>）：月活跃用户数量，统计单月内，登录或使用某个产品的用户数（去除重复登录的用户）</li>\n<li><strong>PV（Page View）</strong>：页面浏览量和点击量，用户每次对网页进行访问被记录为一次</li>\n<li><strong>UV（Unique View）</strong>：独立访客，访问网站的一个终端为一个访客</li>\n<li><strong>转化率</strong>：一个统计周期内，完成转化行为的次数占推广信息总点击次数的比率。</li>\n<li><strong>留存率</strong>：某一统计时段内的新增用户数中经过一段时间后仍启动该应用的用户比例。</li>\n</ul>\n<h3 id=\"漏斗模型\"><a href=\"#漏斗模型\" class=\"headerlink\" title=\"漏斗模型\"></a>漏斗模型</h3><p>衡量指标需要落实到具体的分析模型，而漏斗模型则是最常用的评判落地页转化效果的工具。漏斗模型的实现原理是在潜在用户从访问页面到最终转换成真正用户这个行为路径上的关键节点进行埋点收集行为数据，并根据不同关键节点的特性设定不同目标，最后通过各阶段的转化情况改善关键节点转化的流程设计，从而提升用户体验。</p>\n<p>以我最熟悉的引导流量的注册落地页为例，页面呈现仅有手机号输入框、短信验证码输入框、密码输入框和注册按钮等四个主要的可交互元素，理想的新用户注册流程大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">访问页面 -&gt; 输入手机号 -&gt; 下发短信验证码 -&gt; 输入验证码 -&gt; 输入账号密码 -&gt; 点击注册按钮 -&gt; 服务端进行注册处理 -&gt; 注册成功</span><br></pre></td></tr></table></figure>\n<p>转化漏斗可以添加多个交互步骤，比如当用户输入手机号后，前端自动检测输入值由正则校验有效后，则上报标记为 <code>输入手机号</code> 的埋点，在用户获取到短信验证码，同样地输入短信验证码并校验有效后，即上报 <code>输入验证码</code> 的埋点。通过添加两个关键节点的埋点，使用转化漏斗配合可视化视图，我们就能清晰地知道有多少用户完成了 <code>输入手机号</code> 到 <code>输入验证码</code> 这个步骤，而通过 <code>输入手机号</code> 的人数减去 <code>输入验证码</code> 的人数，我们就能获知该阶段流失的用户数。</p>\n<p>转化率需要 <strong>对比</strong>，不能在分析的时候发现某个环节的转化率太低，就认为一定是这个环节出现了问题。比如从 <code>输入手机号</code> 到 <code>注册成功</code> 这个环节转化率只有 40%（虚构数据），是所有环节中最低的，但我们可以用历史数据进行比较，从<strong>趋势</strong>的变化分析转化效果，上个月同期该环节的转化率页是 38%，行业同类产品均值是 36%，那么其实该环节做得还是不错的。我们看后面的环节，从 <code>注册成功</code> 到 <code>进入 APP 应用</code> 的环节的转化率是 62%（虚构数据），跟其他环节相比较起来，这个转化率是最高的，但是我们对比行业同类型产品会发现均值是 90%（虚构数据），对比上个月同期这个比率是 91%（虚构数据），那么我们可以发现当前这个月，落地页从注册成功到登录 APP 应用的转化率是做得非常不好的，其实这个就回到我们数据分析中的对比分析了，我们需要与自己的历史数据做对比，才能得出完整的结论，当然另外一点是不同的用户，对比在交互流程中的转化率是可以有很大的差异的，像客户来自不同的渠道、不同的区域、不同的生命周期、不同性别、不同年龄，他们在漏斗中的表现都是不一样的，所以我们在进行漏斗分析的时候，往往还需要进行细分的漏斗模型分析，</p>\n<p>如果转化率并不理想，我们可以通过 <strong>细分维度</strong> 对转化率进行拆解，比如我们可以通过操作系统维度（例如分为 Android 和 iOS）看到不同操作系统的阶段转化情况，也可以选择浏览器（Chrome、Safari、Firefox 和 微信内置浏览器等）看到不同浏览器的阶段转化情况，甚至可以选择设备的品牌来看到对应的阶段转化情况。如果某个转化率明显低于正常的转化率情况，那么我们可以合理怀疑页面这个操作系统、品牌或浏览器上，兼容性做得不够。</p>\n<p>综合以上，可以得出基于漏斗模型的分析方法有以下几种：</p>\n<ul>\n<li><strong>趋势（Trend）</strong>：从 <code>时间轴</code> 的变化情况进行分析，适用于对某一流程或其中某个步骤进行改进或优化的效果监控。</li>\n<li><strong>比较（Compare）</strong>：通过比较 <code>类似产品或服务间</code> 购买或使用流程的转化率，发现某些产品或应用中存在的问题。</li>\n<li><strong>细分（Segment）</strong>：细分来源或 <code>不同的客户类型</code> 在转化率上的表现，发现一些高质量的来源或客户，通常用于分析网站的广告或推广的效果及 ROI。</li>\n</ul>\n<h3 id=\"A-B-测试\"><a href=\"#A-B-测试\" class=\"headerlink\" title=\"A/B 测试\"></a>A/B 测试</h3><p>A/B 测试是为了 Web 或 App 界面或流程制作两个或多个版本，在相同时间维度，分别让组成成分相同（相似）的访客群组（目标人群）随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估初最好版本，正式采用。</p>\n<p>通过 A/B 测试可以有效减少基于假设前提的各种无谓争论。通过 A/B 测试可以看到用户面对不同落地页元素的真实反应、用户更容易点击落地页的哪些位置，从而得出修改页面元素的有力证据。</p>\n<p>因为经常需要在流量分配时有所权衡，一般有以下几个情况：</p>\n<ul>\n<li>不影响用户体验：如 UI 实验、文案类实验等，一般可以均匀分配流量实验，可以快速得到实验结论</li>\n<li>不确定性较强的实验：如产品新功能上线，一般需小流量实验，尽量减少用户体验影响，在允许的时间内得到结论</li>\n<li>希望收益最大化的实验：如运营活动等，尽可能将效果最大化，一般需要大流量实验，留出小部分对照组用于评估 ROI</li>\n</ul>\n<p>因为通常单个链接的落地页不具备 A/B test 的功能，需要配合专门用于 A/B test 页面分发的系统进行流量分配，实际上通过类似反向代理的原理，根据分配到不同的页面的比例将标识 A/B 不同页面返回给用户展示。</p>\n<p>由于我们的注册落地页是使用可视化页面搭建系统配置的，并不支持 A/B 测试，所以搭配另一套前端的集成系统和客户端的 CMS 系统，能够实现对页面的 A/B 测试。而在页面的埋点统计中，需要上报 A/B 的标识，以便后续业务数据的追踪和评估结果，进而得出测试结论并指导落地页改进。</p>\n<h3 id=\"数据校验流程\"><a href=\"#数据校验流程\" class=\"headerlink\" title=\"数据校验流程\"></a>数据校验流程</h3><p>对于分析师来说，数据分析的结论正确的前提是数据来源的正确性，也就是技术人员需要确保数据采集的准确性。</p>\n<p>数据采集的正确性校验：</p>\n<ol>\n<li>事件是否上报</li>\n<li>事件属性是否上报，上报的属性值是否正确</li>\n<li>公共属性是否上报，上报的公共属性值是否过正确</li>\n<li>如果上传了用户属性，用户属性是否上报正确</li>\n<li>事件属性和用户属性的属性值类型是否正确</li>\n</ol>\n<p>用户关联的正确性校验：</p>\n<ol>\n<li>是否做了用户关联</li>\n<li>登录 ID 是否上传正确</li>\n<li>是否正确调用用户关联的接口</li>\n</ol>\n<p>如果使用漏斗模型进行分析时，上报埋点的时机要确保符合顺序，在用户端上报时间与统计平台的埋点入库时间也是需要注意的点。</p>\n<p><code>埋点管理</code> -&gt; <code>实时导入数据查询</code> -&gt; <code>用户 ID</code> 查询用户关联的准确性</p>\n<hr>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li>产品设计<ul>\n<li><a href=\"http://www.woshipm.com/pd/3079851.html\" target=\"_blank\" rel=\"noopener\">高转化率的 APP 推广落地页是怎样炼成的</a></li>\n<li><a href=\"https://www.jianshu.com/p/21db3a53b9e7\" target=\"_blank\" rel=\"noopener\">那些制作落地页的套路</a></li>\n<li><a href=\"https://www.shujike.com/blog/77744\" target=\"_blank\" rel=\"noopener\">如何提升落地页转化率</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33882407\" target=\"_blank\" rel=\"noopener\">什么是落地页</a></li>\n<li><a href=\"https://www.27sem.com/article/3634.html\" target=\"_blank\" rel=\"noopener\">你问我答 12 个流量和转化相关的实战问题解答</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/36165204\" target=\"_blank\" rel=\"noopener\">高转化的落地页长啥样</a></li>\n</ul>\n</li>\n<li>数据分析<ul>\n<li><a href=\"https://www.yunyingpai.com/user/199.html\" target=\"_blank\" rel=\"noopener\">产品运营的基本功 漏斗模型</a></li>\n<li><a href=\"https://www.sohu.com/a/345808493_165070\" target=\"_blank\" rel=\"noopener\">案例分享 渠道落地页数据分析</a></li>\n<li><a href=\"http://menvscode.com/detail/5bfc20d030be6232a69c5d94\" target=\"_blank\" rel=\"noopener\">网页转化率与漏斗模型</a></li>\n<li><a href=\"https://www.niaogebiji.com/article-26780-1.html\" target=\"_blank\" rel=\"noopener\">优秀产品人必懂的数据驱动增长模型</a></li>\n<li><a href=\"https://www.sensorsdata.cn/blog/shi-yong-sensors-analytics-jin-xing-a-b-test/\" target=\"_blank\" rel=\"noopener\">使用 Sensors Analytics 进行 A/B Test</a></li>\n<li><a href=\"https://juejin.im/post/585b7fc161ff4b0058032b84\" target=\"_blank\" rel=\"noopener\">深度 A/B 测试中的因果推断——潜在结果模型</a></li>\n<li><a href=\"https://www.infoq.cn/article/PyOwiqA1zmuIcXqySb7V\" target=\"_blank\" rel=\"noopener\">销售线索居低不上，你唯一要做的是落地页 A/B 测试</a></li>\n</ul>\n</li>\n<li>扩展阅读<ul>\n<li><a href=\"https://www.jianshu.com/p/4f64d739fba2\" target=\"_blank\" rel=\"noopener\">淘宝用户行为数据分析详解</a></li>\n<li><a href=\"https://tech.meituan.com/2017/05/05/mt-dsp.html\" target=\"_blank\" rel=\"noopener\">美团 DSP 广告策略实践</a></li>\n<li><a href=\"https://www.jianshu.com/p/ab04b1e3a512\" target=\"_blank\" rel=\"noopener\">日志采集与用户行为链路分析</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在科技繁荣的今天，计算机给现代社会带来的是信息化的变革，本质上打破的是原有社会人们地理、语言、人种等各维度上的差异，通过互联网人们能通过便捷的方式足不出户口，就可以购买到全国乃至全球的商品货物、享受到各式各样的差异化服务。因此，对于一家互联网企业来说，用户无疑是最重要的资产，让更多的用户知道、了解甚至享受企业的产品，是企业立足的前提条件，毕竟有了用户方有盈利的可能性，企业才能可持续发展。</p>\n<p>对于国内很多大厂的来说，某种程度上在用户这个维度上会投入大量资源，诸如设立专门负责用户增长的组织单位。他们关注用户在产品终端的体验，相关从业人员需要懂得抓住用户心里，结合各种业务场景制定对应的营销策略，最终目的就是留住用户，让用户心甘情愿地消费。</p>\n<p>笔者就职于与某互联网金融企业，由于最近经常需要和产品、推广、运营打交道，多多少少会接触到很多庞杂的知识边界外的领域，所以打算系统整理这段时间来的业务分析方法论和实践心得。</p>","more":"<h2 id=\"落地页\"><a href=\"#落地页\" class=\"headerlink\" title=\"落地页\"></a>落地页</h2><p>所谓的落地页（Landing Page）就是用于承接用户通过付费搜索渠道进入的推广页面。</p>\n<p>在如今广告横霸天下的互联网社会，我们用百度搜索结果出来后插在开头的结果，在腾讯视频看剧时突然蹦出来的小广告，刷知乎或者微信朋友圈穿插在信息流当中的「伪」信息，抑或是淘宝店家、保险公司、移动联通电信等隔三差五给你发的短信里的短链接，基本都可以归类为落地页的入口。通常由知名度不足的广告商付费购买推广位，利用知名度较高的渠道建立用户与自家产品的认知关系，而落地页就是关键的载体。</p>\n<p>其实落地页的类型能细分出很多种，主要分为营销活动页、信息收集页、应用推广页、唤醒找回页等，各有各的职责。</p>\n<h3 id=\"营销活动页\"><a href=\"#营销活动页\" class=\"headerlink\" title=\"营销活动页\"></a>营销活动页</h3><p>营销活动页的目的是为了让你的用户知道你的产品是什么、能提供什么服务、能解决用户什么需求。通过落地页能直接展示或跳转至 APP 内的核心业务，起到承接流量的作用。页面的内容通常比较简洁，会用到大量设计感高的图片和醒目的文案，为用户展示自己的活动和商品，通过类似优惠价格和赠品等手段引导用户点击，获取到用户信息后，后续再与客户联系，最终将这些潜在的用户转化为真正的用户。</p>\n<p><img src=\"http://img.mrsingsing.com/landing-page-marketing.jpg\" alt=\"营销活动页\"></p>\n<h3 id=\"信息搜集页\"><a href=\"#信息搜集页\" class=\"headerlink\" title=\"信息搜集页\"></a>信息搜集页</h3><p>信息搜集页适用于业务复杂或低频类的产品，当产品核心业务设计到大额交易、定制服务、响应周期长等特征的时候，落地页的任务更像是给用户一个承诺，许诺会有大量优惠的福利，留下个人信息以便平台后续专员的电访。回想起很多诸如职业培训的公司，是不是网页加载后都会弹窗让你填写个人信息，然后几天内就会接到他们电话向你推销课程。</p>\n<p><img src=\"http://img.mrsingsing.com/landing-page-information.jpg\" alt=\"信息搜集页\"></p>\n<h3 id=\"应用推广页\"><a href=\"#应用推广页\" class=\"headerlink\" title=\"应用推广页\"></a>应用推广页</h3><p>应用推广页的目的很明确，就是引导用户下载应用、注册、登录等。</p>\n<p><img src=\"http://img.mrsingsing.com/landing-page-application-promotion.jpg\" alt=\"应用推广页\"></p>\n<h3 id=\"唤醒找回页\"><a href=\"#唤醒找回页\" class=\"headerlink\" title=\"唤醒找回页\"></a>唤醒找回页</h3><p>日活月活是互联网应用很重要的活性指标，唤醒找回页的使命就是激活那些流失掉的用户，通过短信、邮件、消息通知等主动反馈的形式吸引老用户回归应用。</p>\n<p><img src=\"http://img.mrsingsing.com/landing-page-awaken.jpg\" alt=\"唤醒找回页\"></p>\n<h2 id=\"数据指标与转化率分析\"><a href=\"#数据指标与转化率分析\" class=\"headerlink\" title=\"数据指标与转化率分析\"></a>数据指标与转化率分析</h2><h3 id=\"数据指标\"><a href=\"#数据指标\" class=\"headerlink\" title=\"数据指标\"></a>数据指标</h3><p>落地页的实际效果需要量化指标来衡量，下面从运营角度列出了一些落地页建设需要关注的指标。</p>\n<p><img src=\"http://img.mrsingsing.com/landing-page-pointer.jpg\" alt=\"落地页指标\"></p>\n<ul>\n<li><strong>页面浏览量</strong>：指页面被用户浏览的次数，严格意义上指用户向网站发出并完成下载页面的请求</li>\n<li><strong>点击率</strong>：网页内某内容被点击次数与显示次数之比</li>\n<li><strong>跳出率</strong>：衡量落地页质量好坏的重要指标。页面跳出率的计算为该页面作为落地页跳出的访问次数占该页面作为落地页访问次数的百分比，全站跳出率则为跳出的访问次数除以总的访问次数。</li>\n<li><strong>停留时长</strong>：用于衡量用户与网站/APP 交互深度，一般有页面停留时长，会话时长以及平均停留时长等概念，其计算的核心原理在于记录下用户行为发生时的时间戳，后期再应用相应公式来计算</li>\n<li><strong>交互深度</strong>：指用户在一次浏览网页或 APP 过程中，访问了多少页面。用户在一次浏览中访问的页面越多，交互深度就越深。交互深度能够侧面反映网站或 APP 对于用户的吸引力。<br>可以通过 Session 来计算用户的平均交互深度。</li>\n</ul>\n<p>除此之外还有一些我们会经常听到的一些核心指标：</p>\n<ul>\n<li><strong>DAU（Daily Activited Users）</strong>：日活跃用户数量，统计单日内，登录或使用某个产品的用户数（去除重复登录的用户）</li>\n<li><strong>MAU（Monthly Activited Users</strong>）：月活跃用户数量，统计单月内，登录或使用某个产品的用户数（去除重复登录的用户）</li>\n<li><strong>PV（Page View）</strong>：页面浏览量和点击量，用户每次对网页进行访问被记录为一次</li>\n<li><strong>UV（Unique View）</strong>：独立访客，访问网站的一个终端为一个访客</li>\n<li><strong>转化率</strong>：一个统计周期内，完成转化行为的次数占推广信息总点击次数的比率。</li>\n<li><strong>留存率</strong>：某一统计时段内的新增用户数中经过一段时间后仍启动该应用的用户比例。</li>\n</ul>\n<h3 id=\"漏斗模型\"><a href=\"#漏斗模型\" class=\"headerlink\" title=\"漏斗模型\"></a>漏斗模型</h3><p>衡量指标需要落实到具体的分析模型，而漏斗模型则是最常用的评判落地页转化效果的工具。漏斗模型的实现原理是在潜在用户从访问页面到最终转换成真正用户这个行为路径上的关键节点进行埋点收集行为数据，并根据不同关键节点的特性设定不同目标，最后通过各阶段的转化情况改善关键节点转化的流程设计，从而提升用户体验。</p>\n<p>以我最熟悉的引导流量的注册落地页为例，页面呈现仅有手机号输入框、短信验证码输入框、密码输入框和注册按钮等四个主要的可交互元素，理想的新用户注册流程大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">访问页面 -&gt; 输入手机号 -&gt; 下发短信验证码 -&gt; 输入验证码 -&gt; 输入账号密码 -&gt; 点击注册按钮 -&gt; 服务端进行注册处理 -&gt; 注册成功</span><br></pre></td></tr></table></figure>\n<p>转化漏斗可以添加多个交互步骤，比如当用户输入手机号后，前端自动检测输入值由正则校验有效后，则上报标记为 <code>输入手机号</code> 的埋点，在用户获取到短信验证码，同样地输入短信验证码并校验有效后，即上报 <code>输入验证码</code> 的埋点。通过添加两个关键节点的埋点，使用转化漏斗配合可视化视图，我们就能清晰地知道有多少用户完成了 <code>输入手机号</code> 到 <code>输入验证码</code> 这个步骤，而通过 <code>输入手机号</code> 的人数减去 <code>输入验证码</code> 的人数，我们就能获知该阶段流失的用户数。</p>\n<p>转化率需要 <strong>对比</strong>，不能在分析的时候发现某个环节的转化率太低，就认为一定是这个环节出现了问题。比如从 <code>输入手机号</code> 到 <code>注册成功</code> 这个环节转化率只有 40%（虚构数据），是所有环节中最低的，但我们可以用历史数据进行比较，从<strong>趋势</strong>的变化分析转化效果，上个月同期该环节的转化率页是 38%，行业同类产品均值是 36%，那么其实该环节做得还是不错的。我们看后面的环节，从 <code>注册成功</code> 到 <code>进入 APP 应用</code> 的环节的转化率是 62%（虚构数据），跟其他环节相比较起来，这个转化率是最高的，但是我们对比行业同类型产品会发现均值是 90%（虚构数据），对比上个月同期这个比率是 91%（虚构数据），那么我们可以发现当前这个月，落地页从注册成功到登录 APP 应用的转化率是做得非常不好的，其实这个就回到我们数据分析中的对比分析了，我们需要与自己的历史数据做对比，才能得出完整的结论，当然另外一点是不同的用户，对比在交互流程中的转化率是可以有很大的差异的，像客户来自不同的渠道、不同的区域、不同的生命周期、不同性别、不同年龄，他们在漏斗中的表现都是不一样的，所以我们在进行漏斗分析的时候，往往还需要进行细分的漏斗模型分析，</p>\n<p>如果转化率并不理想，我们可以通过 <strong>细分维度</strong> 对转化率进行拆解，比如我们可以通过操作系统维度（例如分为 Android 和 iOS）看到不同操作系统的阶段转化情况，也可以选择浏览器（Chrome、Safari、Firefox 和 微信内置浏览器等）看到不同浏览器的阶段转化情况，甚至可以选择设备的品牌来看到对应的阶段转化情况。如果某个转化率明显低于正常的转化率情况，那么我们可以合理怀疑页面这个操作系统、品牌或浏览器上，兼容性做得不够。</p>\n<p>综合以上，可以得出基于漏斗模型的分析方法有以下几种：</p>\n<ul>\n<li><strong>趋势（Trend）</strong>：从 <code>时间轴</code> 的变化情况进行分析，适用于对某一流程或其中某个步骤进行改进或优化的效果监控。</li>\n<li><strong>比较（Compare）</strong>：通过比较 <code>类似产品或服务间</code> 购买或使用流程的转化率，发现某些产品或应用中存在的问题。</li>\n<li><strong>细分（Segment）</strong>：细分来源或 <code>不同的客户类型</code> 在转化率上的表现，发现一些高质量的来源或客户，通常用于分析网站的广告或推广的效果及 ROI。</li>\n</ul>\n<h3 id=\"A-B-测试\"><a href=\"#A-B-测试\" class=\"headerlink\" title=\"A/B 测试\"></a>A/B 测试</h3><p>A/B 测试是为了 Web 或 App 界面或流程制作两个或多个版本，在相同时间维度，分别让组成成分相同（相似）的访客群组（目标人群）随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估初最好版本，正式采用。</p>\n<p>通过 A/B 测试可以有效减少基于假设前提的各种无谓争论。通过 A/B 测试可以看到用户面对不同落地页元素的真实反应、用户更容易点击落地页的哪些位置，从而得出修改页面元素的有力证据。</p>\n<p>因为经常需要在流量分配时有所权衡，一般有以下几个情况：</p>\n<ul>\n<li>不影响用户体验：如 UI 实验、文案类实验等，一般可以均匀分配流量实验，可以快速得到实验结论</li>\n<li>不确定性较强的实验：如产品新功能上线，一般需小流量实验，尽量减少用户体验影响，在允许的时间内得到结论</li>\n<li>希望收益最大化的实验：如运营活动等，尽可能将效果最大化，一般需要大流量实验，留出小部分对照组用于评估 ROI</li>\n</ul>\n<p>因为通常单个链接的落地页不具备 A/B test 的功能，需要配合专门用于 A/B test 页面分发的系统进行流量分配，实际上通过类似反向代理的原理，根据分配到不同的页面的比例将标识 A/B 不同页面返回给用户展示。</p>\n<p>由于我们的注册落地页是使用可视化页面搭建系统配置的，并不支持 A/B 测试，所以搭配另一套前端的集成系统和客户端的 CMS 系统，能够实现对页面的 A/B 测试。而在页面的埋点统计中，需要上报 A/B 的标识，以便后续业务数据的追踪和评估结果，进而得出测试结论并指导落地页改进。</p>\n<h3 id=\"数据校验流程\"><a href=\"#数据校验流程\" class=\"headerlink\" title=\"数据校验流程\"></a>数据校验流程</h3><p>对于分析师来说，数据分析的结论正确的前提是数据来源的正确性，也就是技术人员需要确保数据采集的准确性。</p>\n<p>数据采集的正确性校验：</p>\n<ol>\n<li>事件是否上报</li>\n<li>事件属性是否上报，上报的属性值是否正确</li>\n<li>公共属性是否上报，上报的公共属性值是否过正确</li>\n<li>如果上传了用户属性，用户属性是否上报正确</li>\n<li>事件属性和用户属性的属性值类型是否正确</li>\n</ol>\n<p>用户关联的正确性校验：</p>\n<ol>\n<li>是否做了用户关联</li>\n<li>登录 ID 是否上传正确</li>\n<li>是否正确调用用户关联的接口</li>\n</ol>\n<p>如果使用漏斗模型进行分析时，上报埋点的时机要确保符合顺序，在用户端上报时间与统计平台的埋点入库时间也是需要注意的点。</p>\n<p><code>埋点管理</code> -&gt; <code>实时导入数据查询</code> -&gt; <code>用户 ID</code> 查询用户关联的准确性</p>\n<hr>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li>产品设计<ul>\n<li><a href=\"http://www.woshipm.com/pd/3079851.html\" target=\"_blank\" rel=\"noopener\">高转化率的 APP 推广落地页是怎样炼成的</a></li>\n<li><a href=\"https://www.jianshu.com/p/21db3a53b9e7\" target=\"_blank\" rel=\"noopener\">那些制作落地页的套路</a></li>\n<li><a href=\"https://www.shujike.com/blog/77744\" target=\"_blank\" rel=\"noopener\">如何提升落地页转化率</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33882407\" target=\"_blank\" rel=\"noopener\">什么是落地页</a></li>\n<li><a href=\"https://www.27sem.com/article/3634.html\" target=\"_blank\" rel=\"noopener\">你问我答 12 个流量和转化相关的实战问题解答</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/36165204\" target=\"_blank\" rel=\"noopener\">高转化的落地页长啥样</a></li>\n</ul>\n</li>\n<li>数据分析<ul>\n<li><a href=\"https://www.yunyingpai.com/user/199.html\" target=\"_blank\" rel=\"noopener\">产品运营的基本功 漏斗模型</a></li>\n<li><a href=\"https://www.sohu.com/a/345808493_165070\" target=\"_blank\" rel=\"noopener\">案例分享 渠道落地页数据分析</a></li>\n<li><a href=\"http://menvscode.com/detail/5bfc20d030be6232a69c5d94\" target=\"_blank\" rel=\"noopener\">网页转化率与漏斗模型</a></li>\n<li><a href=\"https://www.niaogebiji.com/article-26780-1.html\" target=\"_blank\" rel=\"noopener\">优秀产品人必懂的数据驱动增长模型</a></li>\n<li><a href=\"https://www.sensorsdata.cn/blog/shi-yong-sensors-analytics-jin-xing-a-b-test/\" target=\"_blank\" rel=\"noopener\">使用 Sensors Analytics 进行 A/B Test</a></li>\n<li><a href=\"https://juejin.im/post/585b7fc161ff4b0058032b84\" target=\"_blank\" rel=\"noopener\">深度 A/B 测试中的因果推断——潜在结果模型</a></li>\n<li><a href=\"https://www.infoq.cn/article/PyOwiqA1zmuIcXqySb7V\" target=\"_blank\" rel=\"noopener\">销售线索居低不上，你唯一要做的是落地页 A/B 测试</a></li>\n</ul>\n</li>\n<li>扩展阅读<ul>\n<li><a href=\"https://www.jianshu.com/p/4f64d739fba2\" target=\"_blank\" rel=\"noopener\">淘宝用户行为数据分析详解</a></li>\n<li><a href=\"https://tech.meituan.com/2017/05/05/mt-dsp.html\" target=\"_blank\" rel=\"noopener\">美团 DSP 广告策略实践</a></li>\n<li><a href=\"https://www.jianshu.com/p/ab04b1e3a512\" target=\"_blank\" rel=\"noopener\">日志采集与用户行为链路分析</a></li>\n</ul>\n</li>\n</ul>"},{"title":"龙猫 X 基于事件链的自动化测试方案复盘","date":"2020-03-01T00:00:00.000Z","_content":"\n**大纲：**\n\n- 基于龙猫 X 事件机制生成事件链列表\n- 使用 Egg 和 Socket.IO 搭建自动化测试服务\n- 利用 Puppeteer 进行自动化测试\n- 测试用例的执行方案研讨\n\n龙猫 X 作为服务于产品、运营、开发的页面搭建平台，通过可视化的拖拽、配置生成业务所需的各种页面。在日常的开发中，大多数情况下都是由运营直接完成需求，或是运营产品直接提交工单后由开发进行完成，测试在评审阶段的参与率不高。这就导致测试在功能页面的测试中无法全方位地检测页面的功能效果，同时也由于龙猫 X 项目测试少有参与，测试参与的多是经由龙猫 X 生成的页面的功能测试，所以测试对于龙猫 X 页面的内在逻辑也缺乏了解。因此，为测试方提供能掌握龙猫 X 页面逻辑关系的工具对提升页面的运行质量具有重要意义。\n\n本文针对上述情况，团队开发出针对龙猫 X 的事件链自动化测试方案，由于与业务耦合度极高，可能对其他公司团队未必具有通用性，权当技术方案参考与交流。\n\n<!-- more -->\n\n开始前，直接抛出整个业务流程的模式图，以便对该功能有个全貌的认知。\n\n![自动化测试业务流程图](http://img.mrsingsing.com/automatation-test-workflow.jpg)\n\n简单阐述一下参与流程的几个服务，包括用户操作自动化测试的前端界面、获取页面数据的龙猫 X 服务、用于进行测试逻辑的服务以及连接测试服务的无头浏览器端。\n\n主流程就是通过获取页面数据生成事件链，测试人员配置测试用例后触发对应事件，由测试服务和无头浏览器自动完成对应链条的测试需求，最后前端页面显示测试覆盖率及成功率。\n\n## 基于龙猫 X 事件机制生成事件链列表\n\n在说明事件链的生成机制前，我们需要研究一下龙猫 X 的通讯机制。\n\n龙猫 X 的数据通讯机制由订阅发布模式机制组成，以下罗列了在实际业务中组件间通讯的流向示意图：\n\n```\nA 组件（A1 事件）-> 发布事件（主动事件） -> 订阅事件（被动事件） -> B 组件（B1 事件）\n\nB 组件（B2 事件）-> C 组件（C1 事件）\n\n立即注册（Button 组件）-> 显示弹窗（FixedContainer 组件）\n\n立即签到（Button 组件）-> 签到接口（Interface 组件）\n\n签到接口（Interface 组件）-> 签到成功（Interface 组件）\n```\n\n组件组织方式是扁平化的，事件关系具有零散化的特点。\n\n用户触发组件 A 的 A1 事件，经过发布订阅机制触达组件 B 的 B1 事件。如果 B1 事件是类似于显示/隐藏、改变样式等操作，那么属于一个数据流向的终点。\n\n如果 B1 事件是类似于发送请求等事件，请求响应成功即需要执行另一个回调命令，例如我们把 B2 看作请求的响应成功 `fetchSuccess` 事件，当请求响应成功后，自动执行后续连接的组件 C 的 C1 事件。\n\n从上述说明中，我们可以构建出龙猫 X 组件间事件流模型 `组件 A 事件 A1 -> 组件B事件B1`，`组件B事件B2 => 组件C事件C1`。\n\n由于订阅发布通讯机制的存在，发布事件（我们称为主动事件）天然地与订阅事件（我们称为被动事件）自动连接起来，但是关键的节点在于，仍以上述组件 B 的例子数名，组件 B 内存在两个定义的事件 B1 和 B2，它们通过组件内部的代码设定的回调联系起来，但是在我们的配置数据层面并未解决，所以我们需要一份清单总结所有龙猫 X 组件中存在的组件内被动和主动事件非用户触发连接的关系表，这个对于后续构成事件链是关键的一步。\n\n1. 将零散事件关系，以收集组件事件内联的关系表解决单个事件通讯间无法连结的问题，最终组织成事件链\n2. 通过某一事件，能自动触发后续事件（某些龙猫 X 定义为主动事件并非所有由用户触发，也能是组件内部触发）\n\n![事件链示意图](http://img.mrsingsing.com/automatation-test-events-chain.jpg)\n\n上述图片展示了实际业务中的事件链示例，该事件链以名为「立即注册」的 Button 按钮组件触发，后续经由 Input 输入框组件获取已前置输入的手机号数据，内部数据流获取数据后触发 Input 组件内的另一个取值的主动事件，然后取值会检验输入框输入数据的有效性，根据有效性分流取值成功与取值失败的被动事件。如果取值失败，则会弹出 Message 组件提示输入框输入数据无效的相关信息；如果取值成功，则会用获取到的手机号和其他相关参数请求接口验证，响应后根据后台返回结果分流为进而请求另一个请求短信验证码的接口还是需要进行鉴定用户为真实用户的图形验证码操作。这就构成一条完整的事件链，整个事件链中除了输入框额外的数据收入外，用户只需触发一次「立即注册」的按钮即可检验后续流程。\n\n在制定事件链形成方案后，那么摆在面前的仍有几个问题：\n\n- 如何启动执行单个事件链？\n- 如何知道一个事件链流程已经执行完毕？\n- 在什么时机对执行结果进行断言测试？\n\n经过分析现有龙猫组件的特点。事件链触发种类主要有以下几个类型：\n\n- 浏览器默认事件：页面容器加载完毕、相关 SDK 注册成功等\n- 用户交互触发：点击按钮、点击图片\n- 组件钩子（被动性质/间接的主动事件）：接口请求成功失败/收集值成功失败/表单项值改变时/及贷 SDK 的 Ready 事件\n\n如果对浏览器的的事件循环机制有过了解的，不难联想到这都与 JavaScript 异步事件相关：\n\n- 定时器 Timer\n- HTML Parsing\n- HTTP Request\n- I/O（Mouse、Event）\n- Promise。then\n\n总结：\n\n- JavaScript 宿主环境运行中的事件循环机制（定时器、UI Rendering、I/O、HTTP Request）\n- 用于存储状态的表单高阶组件的取值事件（其实是相当于取值后，在组件内部设定校验逻辑）\n\n根据上述生成事件链的机制，能将页面配置的事件链自动整理生成列表，后续需要通过测试服务进行自动化测试。\n\n## 利用 Puppeteer 进行自动化测试\n\n测试用的后端项目使用 Egg 的技术搭建，鉴于前后端信息交互可能会比较频繁的原因，搭配 Socket.IO 建立起前后端的通讯。\n\n这里需要注意的是，Socket.IO 前后端选用的具体库包具有差异：\n\n- 前端：`socket.io-client`\n- 后端：`egg-socket.io`\n\n```\nchat\n├── app\n│   ├── extend\n│   │   └── helper.js\n│   ├── io\n│   │   ├── controller\n│   │   │   └── default.js\n│   │   └── middleware\n│   │       ├── connection.js\n│   │       └── packet.js\n│   └── router.js\n├── config\n└── package.json\n```\n\nEgg 框架的好处是其生态提供了相关的插件，很好地与项目集成，开发起来体验很好。\n\n具体实现细节参考 [Egg - Socket.IO 教程](https://eggjs.org/zh-cn/tutorials/socketio.html)\n\n而另一方面，需要使用业内较为成熟的测试方法进行测试，我们经过对比研究后选择 Puppeteer 这款由 Google 出品的开源支持无头浏览器的框架。\n\nPuppeteer 基于 Chrome DevTool Protocol（简称 CDP），而 CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速通道。\n\n![Puppeteer 实现模型](http://img.mrsingsing.com/automatation-test-puppeteer-pyramid.png)\n\nPuppeteer 广泛应用于各大公司团队的实际业务场景：\n\n- 通用\n  - 生成页面的屏幕截图和 PDF\n  - 自动化提交表单、模拟键鼠输入、自动化单元测试\n  - 网站性能分析：可以抓取并跟踪网站的执行时间轴，帮助分析效率问题\n  - 抓取网页内容，也就是我们常说的爬虫\n- 业务实践\n  - 阿里：[阿里 99 大促模型识别背后的样本生成](https://yq.aliyun.com/articles/718188)\n  - 有赞：[使用 Puppeteer 搭建统一海报渲染服务](https://www.infoq.cn/article/dcSBL_9AzCwVPsaQ70dh)\n  - 其他：[基于 Puppeteer 打造前端巡检监控体系](https://www.jianshu.com/p/42585c78eeec)\n\n那么 Node 服务是如何与 Puppeteer 进行服务的呢？\n\nPuppeteer 提供一种方法 `page.exposeFunction` 将能在 Node 服务进程调用的函数方法名挂载在 Puppeteer 创建的测试页面的全局变量 `window` 上。\n\n当我们在触发事件链开端事件时，通过 Node 服务进而操作无头浏览器内的页面，并在专用于发布订阅模式事件关系传递中调用该挂载全局的函数，将相关参数结果返回到 Node 服务的相关服务中。\n\n![无头浏览器事件响应信息响应机制](http://img.mrsingsing.com/automatation-test-case.jpg)\n\n从上图可以看到，每当被动性质事件触发后，事件链中的被动事件会在触发时额外发送消息发送到 Node 服务，获得响应后跑过测试用例即将最终结果返回到前端。\n\n**那么同时多个 Node.js 进程会遭遇性能问题？**\n\n存在的问题：\n\n- 启动耗时长\n  - 复用浏览器实例和页面实例\n  - Puppeteer 的优化手段 => Chromium Command Line\n- 性能消耗高\n  - 定时重启无头浏览器实例的机制 => 定时器\n\n无头浏览器实例与测试页面 Tab 持久化\n\n- 通过请求 Headless Chrome 进程端口，获取无头浏览器实例的 WS URL，通过 `browser.connect` 重连\n- Radis 缓存\n- 存文件\n- 存在 Egg App Config 中（相当于全局变量）\n\n如此这般，就将整个流程都实现了闭环：\n\n1. 根据页面配置数据生成事件链（列表）\n2. 选择前置数据输入及测试用例\n3. 建立前后端通讯及测试服务和无头浏览器的通讯\n4. 触发用户交互事件\n5. 执行无头浏览器内页面对应事件\n6. 返回响应结果\n","source":"_posts/event-chain-based-automatic-test-scheme-of-totorox.md","raw":"---\ntitle: 龙猫 X 基于事件链的自动化测试方案复盘\ndate: '2020-03-01'\n---\n\n**大纲：**\n\n- 基于龙猫 X 事件机制生成事件链列表\n- 使用 Egg 和 Socket.IO 搭建自动化测试服务\n- 利用 Puppeteer 进行自动化测试\n- 测试用例的执行方案研讨\n\n龙猫 X 作为服务于产品、运营、开发的页面搭建平台，通过可视化的拖拽、配置生成业务所需的各种页面。在日常的开发中，大多数情况下都是由运营直接完成需求，或是运营产品直接提交工单后由开发进行完成，测试在评审阶段的参与率不高。这就导致测试在功能页面的测试中无法全方位地检测页面的功能效果，同时也由于龙猫 X 项目测试少有参与，测试参与的多是经由龙猫 X 生成的页面的功能测试，所以测试对于龙猫 X 页面的内在逻辑也缺乏了解。因此，为测试方提供能掌握龙猫 X 页面逻辑关系的工具对提升页面的运行质量具有重要意义。\n\n本文针对上述情况，团队开发出针对龙猫 X 的事件链自动化测试方案，由于与业务耦合度极高，可能对其他公司团队未必具有通用性，权当技术方案参考与交流。\n\n<!-- more -->\n\n开始前，直接抛出整个业务流程的模式图，以便对该功能有个全貌的认知。\n\n![自动化测试业务流程图](http://img.mrsingsing.com/automatation-test-workflow.jpg)\n\n简单阐述一下参与流程的几个服务，包括用户操作自动化测试的前端界面、获取页面数据的龙猫 X 服务、用于进行测试逻辑的服务以及连接测试服务的无头浏览器端。\n\n主流程就是通过获取页面数据生成事件链，测试人员配置测试用例后触发对应事件，由测试服务和无头浏览器自动完成对应链条的测试需求，最后前端页面显示测试覆盖率及成功率。\n\n## 基于龙猫 X 事件机制生成事件链列表\n\n在说明事件链的生成机制前，我们需要研究一下龙猫 X 的通讯机制。\n\n龙猫 X 的数据通讯机制由订阅发布模式机制组成，以下罗列了在实际业务中组件间通讯的流向示意图：\n\n```\nA 组件（A1 事件）-> 发布事件（主动事件） -> 订阅事件（被动事件） -> B 组件（B1 事件）\n\nB 组件（B2 事件）-> C 组件（C1 事件）\n\n立即注册（Button 组件）-> 显示弹窗（FixedContainer 组件）\n\n立即签到（Button 组件）-> 签到接口（Interface 组件）\n\n签到接口（Interface 组件）-> 签到成功（Interface 组件）\n```\n\n组件组织方式是扁平化的，事件关系具有零散化的特点。\n\n用户触发组件 A 的 A1 事件，经过发布订阅机制触达组件 B 的 B1 事件。如果 B1 事件是类似于显示/隐藏、改变样式等操作，那么属于一个数据流向的终点。\n\n如果 B1 事件是类似于发送请求等事件，请求响应成功即需要执行另一个回调命令，例如我们把 B2 看作请求的响应成功 `fetchSuccess` 事件，当请求响应成功后，自动执行后续连接的组件 C 的 C1 事件。\n\n从上述说明中，我们可以构建出龙猫 X 组件间事件流模型 `组件 A 事件 A1 -> 组件B事件B1`，`组件B事件B2 => 组件C事件C1`。\n\n由于订阅发布通讯机制的存在，发布事件（我们称为主动事件）天然地与订阅事件（我们称为被动事件）自动连接起来，但是关键的节点在于，仍以上述组件 B 的例子数名，组件 B 内存在两个定义的事件 B1 和 B2，它们通过组件内部的代码设定的回调联系起来，但是在我们的配置数据层面并未解决，所以我们需要一份清单总结所有龙猫 X 组件中存在的组件内被动和主动事件非用户触发连接的关系表，这个对于后续构成事件链是关键的一步。\n\n1. 将零散事件关系，以收集组件事件内联的关系表解决单个事件通讯间无法连结的问题，最终组织成事件链\n2. 通过某一事件，能自动触发后续事件（某些龙猫 X 定义为主动事件并非所有由用户触发，也能是组件内部触发）\n\n![事件链示意图](http://img.mrsingsing.com/automatation-test-events-chain.jpg)\n\n上述图片展示了实际业务中的事件链示例，该事件链以名为「立即注册」的 Button 按钮组件触发，后续经由 Input 输入框组件获取已前置输入的手机号数据，内部数据流获取数据后触发 Input 组件内的另一个取值的主动事件，然后取值会检验输入框输入数据的有效性，根据有效性分流取值成功与取值失败的被动事件。如果取值失败，则会弹出 Message 组件提示输入框输入数据无效的相关信息；如果取值成功，则会用获取到的手机号和其他相关参数请求接口验证，响应后根据后台返回结果分流为进而请求另一个请求短信验证码的接口还是需要进行鉴定用户为真实用户的图形验证码操作。这就构成一条完整的事件链，整个事件链中除了输入框额外的数据收入外，用户只需触发一次「立即注册」的按钮即可检验后续流程。\n\n在制定事件链形成方案后，那么摆在面前的仍有几个问题：\n\n- 如何启动执行单个事件链？\n- 如何知道一个事件链流程已经执行完毕？\n- 在什么时机对执行结果进行断言测试？\n\n经过分析现有龙猫组件的特点。事件链触发种类主要有以下几个类型：\n\n- 浏览器默认事件：页面容器加载完毕、相关 SDK 注册成功等\n- 用户交互触发：点击按钮、点击图片\n- 组件钩子（被动性质/间接的主动事件）：接口请求成功失败/收集值成功失败/表单项值改变时/及贷 SDK 的 Ready 事件\n\n如果对浏览器的的事件循环机制有过了解的，不难联想到这都与 JavaScript 异步事件相关：\n\n- 定时器 Timer\n- HTML Parsing\n- HTTP Request\n- I/O（Mouse、Event）\n- Promise。then\n\n总结：\n\n- JavaScript 宿主环境运行中的事件循环机制（定时器、UI Rendering、I/O、HTTP Request）\n- 用于存储状态的表单高阶组件的取值事件（其实是相当于取值后，在组件内部设定校验逻辑）\n\n根据上述生成事件链的机制，能将页面配置的事件链自动整理生成列表，后续需要通过测试服务进行自动化测试。\n\n## 利用 Puppeteer 进行自动化测试\n\n测试用的后端项目使用 Egg 的技术搭建，鉴于前后端信息交互可能会比较频繁的原因，搭配 Socket.IO 建立起前后端的通讯。\n\n这里需要注意的是，Socket.IO 前后端选用的具体库包具有差异：\n\n- 前端：`socket.io-client`\n- 后端：`egg-socket.io`\n\n```\nchat\n├── app\n│   ├── extend\n│   │   └── helper.js\n│   ├── io\n│   │   ├── controller\n│   │   │   └── default.js\n│   │   └── middleware\n│   │       ├── connection.js\n│   │       └── packet.js\n│   └── router.js\n├── config\n└── package.json\n```\n\nEgg 框架的好处是其生态提供了相关的插件，很好地与项目集成，开发起来体验很好。\n\n具体实现细节参考 [Egg - Socket.IO 教程](https://eggjs.org/zh-cn/tutorials/socketio.html)\n\n而另一方面，需要使用业内较为成熟的测试方法进行测试，我们经过对比研究后选择 Puppeteer 这款由 Google 出品的开源支持无头浏览器的框架。\n\nPuppeteer 基于 Chrome DevTool Protocol（简称 CDP），而 CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速通道。\n\n![Puppeteer 实现模型](http://img.mrsingsing.com/automatation-test-puppeteer-pyramid.png)\n\nPuppeteer 广泛应用于各大公司团队的实际业务场景：\n\n- 通用\n  - 生成页面的屏幕截图和 PDF\n  - 自动化提交表单、模拟键鼠输入、自动化单元测试\n  - 网站性能分析：可以抓取并跟踪网站的执行时间轴，帮助分析效率问题\n  - 抓取网页内容，也就是我们常说的爬虫\n- 业务实践\n  - 阿里：[阿里 99 大促模型识别背后的样本生成](https://yq.aliyun.com/articles/718188)\n  - 有赞：[使用 Puppeteer 搭建统一海报渲染服务](https://www.infoq.cn/article/dcSBL_9AzCwVPsaQ70dh)\n  - 其他：[基于 Puppeteer 打造前端巡检监控体系](https://www.jianshu.com/p/42585c78eeec)\n\n那么 Node 服务是如何与 Puppeteer 进行服务的呢？\n\nPuppeteer 提供一种方法 `page.exposeFunction` 将能在 Node 服务进程调用的函数方法名挂载在 Puppeteer 创建的测试页面的全局变量 `window` 上。\n\n当我们在触发事件链开端事件时，通过 Node 服务进而操作无头浏览器内的页面，并在专用于发布订阅模式事件关系传递中调用该挂载全局的函数，将相关参数结果返回到 Node 服务的相关服务中。\n\n![无头浏览器事件响应信息响应机制](http://img.mrsingsing.com/automatation-test-case.jpg)\n\n从上图可以看到，每当被动性质事件触发后，事件链中的被动事件会在触发时额外发送消息发送到 Node 服务，获得响应后跑过测试用例即将最终结果返回到前端。\n\n**那么同时多个 Node.js 进程会遭遇性能问题？**\n\n存在的问题：\n\n- 启动耗时长\n  - 复用浏览器实例和页面实例\n  - Puppeteer 的优化手段 => Chromium Command Line\n- 性能消耗高\n  - 定时重启无头浏览器实例的机制 => 定时器\n\n无头浏览器实例与测试页面 Tab 持久化\n\n- 通过请求 Headless Chrome 进程端口，获取无头浏览器实例的 WS URL，通过 `browser.connect` 重连\n- Radis 缓存\n- 存文件\n- 存在 Egg App Config 中（相当于全局变量）\n\n如此这般，就将整个流程都实现了闭环：\n\n1. 根据页面配置数据生成事件链（列表）\n2. 选择前置数据输入及测试用例\n3. 建立前后端通讯及测试服务和无头浏览器的通讯\n4. 触发用户交互事件\n5. 执行无头浏览器内页面对应事件\n6. 返回响应结果\n","slug":"event-chain-based-automatic-test-scheme-of-totorox","published":1,"updated":"2021-08-18T03:29:45.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99yu0006v31pmc3qrgqv","content":"<p><strong>大纲：</strong></p>\n<ul>\n<li>基于龙猫 X 事件机制生成事件链列表</li>\n<li>使用 Egg 和 Socket.IO 搭建自动化测试服务</li>\n<li>利用 Puppeteer 进行自动化测试</li>\n<li>测试用例的执行方案研讨</li>\n</ul>\n<p>龙猫 X 作为服务于产品、运营、开发的页面搭建平台，通过可视化的拖拽、配置生成业务所需的各种页面。在日常的开发中，大多数情况下都是由运营直接完成需求，或是运营产品直接提交工单后由开发进行完成，测试在评审阶段的参与率不高。这就导致测试在功能页面的测试中无法全方位地检测页面的功能效果，同时也由于龙猫 X 项目测试少有参与，测试参与的多是经由龙猫 X 生成的页面的功能测试，所以测试对于龙猫 X 页面的内在逻辑也缺乏了解。因此，为测试方提供能掌握龙猫 X 页面逻辑关系的工具对提升页面的运行质量具有重要意义。</p>\n<p>本文针对上述情况，团队开发出针对龙猫 X 的事件链自动化测试方案，由于与业务耦合度极高，可能对其他公司团队未必具有通用性，权当技术方案参考与交流。</p>\n<a id=\"more\"></a>\n<p>开始前，直接抛出整个业务流程的模式图，以便对该功能有个全貌的认知。</p>\n<p><img src=\"http://img.mrsingsing.com/automatation-test-workflow.jpg\" alt=\"自动化测试业务流程图\"></p>\n<p>简单阐述一下参与流程的几个服务，包括用户操作自动化测试的前端界面、获取页面数据的龙猫 X 服务、用于进行测试逻辑的服务以及连接测试服务的无头浏览器端。</p>\n<p>主流程就是通过获取页面数据生成事件链，测试人员配置测试用例后触发对应事件，由测试服务和无头浏览器自动完成对应链条的测试需求，最后前端页面显示测试覆盖率及成功率。</p>\n<h2 id=\"基于龙猫-X-事件机制生成事件链列表\"><a href=\"#基于龙猫-X-事件机制生成事件链列表\" class=\"headerlink\" title=\"基于龙猫 X 事件机制生成事件链列表\"></a>基于龙猫 X 事件机制生成事件链列表</h2><p>在说明事件链的生成机制前，我们需要研究一下龙猫 X 的通讯机制。</p>\n<p>龙猫 X 的数据通讯机制由订阅发布模式机制组成，以下罗列了在实际业务中组件间通讯的流向示意图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A 组件（A1 事件）-&gt; 发布事件（主动事件） -&gt; 订阅事件（被动事件） -&gt; B 组件（B1 事件）</span><br><span class=\"line\"></span><br><span class=\"line\">B 组件（B2 事件）-&gt; C 组件（C1 事件）</span><br><span class=\"line\"></span><br><span class=\"line\">立即注册（Button 组件）-&gt; 显示弹窗（FixedContainer 组件）</span><br><span class=\"line\"></span><br><span class=\"line\">立即签到（Button 组件）-&gt; 签到接口（Interface 组件）</span><br><span class=\"line\"></span><br><span class=\"line\">签到接口（Interface 组件）-&gt; 签到成功（Interface 组件）</span><br></pre></td></tr></table></figure>\n<p>组件组织方式是扁平化的，事件关系具有零散化的特点。</p>\n<p>用户触发组件 A 的 A1 事件，经过发布订阅机制触达组件 B 的 B1 事件。如果 B1 事件是类似于显示/隐藏、改变样式等操作，那么属于一个数据流向的终点。</p>\n<p>如果 B1 事件是类似于发送请求等事件，请求响应成功即需要执行另一个回调命令，例如我们把 B2 看作请求的响应成功 <code>fetchSuccess</code> 事件，当请求响应成功后，自动执行后续连接的组件 C 的 C1 事件。</p>\n<p>从上述说明中，我们可以构建出龙猫 X 组件间事件流模型 <code>组件 A 事件 A1 -&gt; 组件B事件B1</code>，<code>组件B事件B2 =&gt; 组件C事件C1</code>。</p>\n<p>由于订阅发布通讯机制的存在，发布事件（我们称为主动事件）天然地与订阅事件（我们称为被动事件）自动连接起来，但是关键的节点在于，仍以上述组件 B 的例子数名，组件 B 内存在两个定义的事件 B1 和 B2，它们通过组件内部的代码设定的回调联系起来，但是在我们的配置数据层面并未解决，所以我们需要一份清单总结所有龙猫 X 组件中存在的组件内被动和主动事件非用户触发连接的关系表，这个对于后续构成事件链是关键的一步。</p>\n<ol>\n<li>将零散事件关系，以收集组件事件内联的关系表解决单个事件通讯间无法连结的问题，最终组织成事件链</li>\n<li>通过某一事件，能自动触发后续事件（某些龙猫 X 定义为主动事件并非所有由用户触发，也能是组件内部触发）</li>\n</ol>\n<p><img src=\"http://img.mrsingsing.com/automatation-test-events-chain.jpg\" alt=\"事件链示意图\"></p>\n<p>上述图片展示了实际业务中的事件链示例，该事件链以名为「立即注册」的 Button 按钮组件触发，后续经由 Input 输入框组件获取已前置输入的手机号数据，内部数据流获取数据后触发 Input 组件内的另一个取值的主动事件，然后取值会检验输入框输入数据的有效性，根据有效性分流取值成功与取值失败的被动事件。如果取值失败，则会弹出 Message 组件提示输入框输入数据无效的相关信息；如果取值成功，则会用获取到的手机号和其他相关参数请求接口验证，响应后根据后台返回结果分流为进而请求另一个请求短信验证码的接口还是需要进行鉴定用户为真实用户的图形验证码操作。这就构成一条完整的事件链，整个事件链中除了输入框额外的数据收入外，用户只需触发一次「立即注册」的按钮即可检验后续流程。</p>\n<p>在制定事件链形成方案后，那么摆在面前的仍有几个问题：</p>\n<ul>\n<li>如何启动执行单个事件链？</li>\n<li>如何知道一个事件链流程已经执行完毕？</li>\n<li>在什么时机对执行结果进行断言测试？</li>\n</ul>\n<p>经过分析现有龙猫组件的特点。事件链触发种类主要有以下几个类型：</p>\n<ul>\n<li>浏览器默认事件：页面容器加载完毕、相关 SDK 注册成功等</li>\n<li>用户交互触发：点击按钮、点击图片</li>\n<li>组件钩子（被动性质/间接的主动事件）：接口请求成功失败/收集值成功失败/表单项值改变时/及贷 SDK 的 Ready 事件</li>\n</ul>\n<p>如果对浏览器的的事件循环机制有过了解的，不难联想到这都与 JavaScript 异步事件相关：</p>\n<ul>\n<li>定时器 Timer</li>\n<li>HTML Parsing</li>\n<li>HTTP Request</li>\n<li>I/O（Mouse、Event）</li>\n<li>Promise。then</li>\n</ul>\n<p>总结：</p>\n<ul>\n<li>JavaScript 宿主环境运行中的事件循环机制（定时器、UI Rendering、I/O、HTTP Request）</li>\n<li>用于存储状态的表单高阶组件的取值事件（其实是相当于取值后，在组件内部设定校验逻辑）</li>\n</ul>\n<p>根据上述生成事件链的机制，能将页面配置的事件链自动整理生成列表，后续需要通过测试服务进行自动化测试。</p>\n<h2 id=\"利用-Puppeteer-进行自动化测试\"><a href=\"#利用-Puppeteer-进行自动化测试\" class=\"headerlink\" title=\"利用 Puppeteer 进行自动化测试\"></a>利用 Puppeteer 进行自动化测试</h2><p>测试用的后端项目使用 Egg 的技术搭建，鉴于前后端信息交互可能会比较频繁的原因，搭配 Socket.IO 建立起前后端的通讯。</p>\n<p>这里需要注意的是，Socket.IO 前后端选用的具体库包具有差异：</p>\n<ul>\n<li>前端：<code>socket.io-client</code></li>\n<li>后端：<code>egg-socket.io</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chat</span><br><span class=\"line\">├── app</span><br><span class=\"line\">│   ├── extend</span><br><span class=\"line\">│   │   └── helper.js</span><br><span class=\"line\">│   ├── io</span><br><span class=\"line\">│   │   ├── controller</span><br><span class=\"line\">│   │   │   └── default.js</span><br><span class=\"line\">│   │   └── middleware</span><br><span class=\"line\">│   │       ├── connection.js</span><br><span class=\"line\">│   │       └── packet.js</span><br><span class=\"line\">│   └── router.js</span><br><span class=\"line\">├── config</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure>\n<p>Egg 框架的好处是其生态提供了相关的插件，很好地与项目集成，开发起来体验很好。</p>\n<p>具体实现细节参考 <a href=\"https://eggjs.org/zh-cn/tutorials/socketio.html\" target=\"_blank\" rel=\"noopener\">Egg - Socket.IO 教程</a></p>\n<p>而另一方面，需要使用业内较为成熟的测试方法进行测试，我们经过对比研究后选择 Puppeteer 这款由 Google 出品的开源支持无头浏览器的框架。</p>\n<p>Puppeteer 基于 Chrome DevTool Protocol（简称 CDP），而 CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速通道。</p>\n<p><img src=\"http://img.mrsingsing.com/automatation-test-puppeteer-pyramid.png\" alt=\"Puppeteer 实现模型\"></p>\n<p>Puppeteer 广泛应用于各大公司团队的实际业务场景：</p>\n<ul>\n<li>通用<ul>\n<li>生成页面的屏幕截图和 PDF</li>\n<li>自动化提交表单、模拟键鼠输入、自动化单元测试</li>\n<li>网站性能分析：可以抓取并跟踪网站的执行时间轴，帮助分析效率问题</li>\n<li>抓取网页内容，也就是我们常说的爬虫</li>\n</ul>\n</li>\n<li>业务实践<ul>\n<li>阿里：<a href=\"https://yq.aliyun.com/articles/718188\" target=\"_blank\" rel=\"noopener\">阿里 99 大促模型识别背后的样本生成</a></li>\n<li>有赞：<a href=\"https://www.infoq.cn/article/dcSBL_9AzCwVPsaQ70dh\" target=\"_blank\" rel=\"noopener\">使用 Puppeteer 搭建统一海报渲染服务</a></li>\n<li>其他：<a href=\"https://www.jianshu.com/p/42585c78eeec\" target=\"_blank\" rel=\"noopener\">基于 Puppeteer 打造前端巡检监控体系</a></li>\n</ul>\n</li>\n</ul>\n<p>那么 Node 服务是如何与 Puppeteer 进行服务的呢？</p>\n<p>Puppeteer 提供一种方法 <code>page.exposeFunction</code> 将能在 Node 服务进程调用的函数方法名挂载在 Puppeteer 创建的测试页面的全局变量 <code>window</code> 上。</p>\n<p>当我们在触发事件链开端事件时，通过 Node 服务进而操作无头浏览器内的页面，并在专用于发布订阅模式事件关系传递中调用该挂载全局的函数，将相关参数结果返回到 Node 服务的相关服务中。</p>\n<p><img src=\"http://img.mrsingsing.com/automatation-test-case.jpg\" alt=\"无头浏览器事件响应信息响应机制\"></p>\n<p>从上图可以看到，每当被动性质事件触发后，事件链中的被动事件会在触发时额外发送消息发送到 Node 服务，获得响应后跑过测试用例即将最终结果返回到前端。</p>\n<p><strong>那么同时多个 Node.js 进程会遭遇性能问题？</strong></p>\n<p>存在的问题：</p>\n<ul>\n<li>启动耗时长<ul>\n<li>复用浏览器实例和页面实例</li>\n<li>Puppeteer 的优化手段 =&gt; Chromium Command Line</li>\n</ul>\n</li>\n<li>性能消耗高<ul>\n<li>定时重启无头浏览器实例的机制 =&gt; 定时器</li>\n</ul>\n</li>\n</ul>\n<p>无头浏览器实例与测试页面 Tab 持久化</p>\n<ul>\n<li>通过请求 Headless Chrome 进程端口，获取无头浏览器实例的 WS URL，通过 <code>browser.connect</code> 重连</li>\n<li>Radis 缓存</li>\n<li>存文件</li>\n<li>存在 Egg App Config 中（相当于全局变量）</li>\n</ul>\n<p>如此这般，就将整个流程都实现了闭环：</p>\n<ol>\n<li>根据页面配置数据生成事件链（列表）</li>\n<li>选择前置数据输入及测试用例</li>\n<li>建立前后端通讯及测试服务和无头浏览器的通讯</li>\n<li>触发用户交互事件</li>\n<li>执行无头浏览器内页面对应事件</li>\n<li>返回响应结果</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><strong>大纲：</strong></p>\n<ul>\n<li>基于龙猫 X 事件机制生成事件链列表</li>\n<li>使用 Egg 和 Socket.IO 搭建自动化测试服务</li>\n<li>利用 Puppeteer 进行自动化测试</li>\n<li>测试用例的执行方案研讨</li>\n</ul>\n<p>龙猫 X 作为服务于产品、运营、开发的页面搭建平台，通过可视化的拖拽、配置生成业务所需的各种页面。在日常的开发中，大多数情况下都是由运营直接完成需求，或是运营产品直接提交工单后由开发进行完成，测试在评审阶段的参与率不高。这就导致测试在功能页面的测试中无法全方位地检测页面的功能效果，同时也由于龙猫 X 项目测试少有参与，测试参与的多是经由龙猫 X 生成的页面的功能测试，所以测试对于龙猫 X 页面的内在逻辑也缺乏了解。因此，为测试方提供能掌握龙猫 X 页面逻辑关系的工具对提升页面的运行质量具有重要意义。</p>\n<p>本文针对上述情况，团队开发出针对龙猫 X 的事件链自动化测试方案，由于与业务耦合度极高，可能对其他公司团队未必具有通用性，权当技术方案参考与交流。</p>","more":"<p>开始前，直接抛出整个业务流程的模式图，以便对该功能有个全貌的认知。</p>\n<p><img src=\"http://img.mrsingsing.com/automatation-test-workflow.jpg\" alt=\"自动化测试业务流程图\"></p>\n<p>简单阐述一下参与流程的几个服务，包括用户操作自动化测试的前端界面、获取页面数据的龙猫 X 服务、用于进行测试逻辑的服务以及连接测试服务的无头浏览器端。</p>\n<p>主流程就是通过获取页面数据生成事件链，测试人员配置测试用例后触发对应事件，由测试服务和无头浏览器自动完成对应链条的测试需求，最后前端页面显示测试覆盖率及成功率。</p>\n<h2 id=\"基于龙猫-X-事件机制生成事件链列表\"><a href=\"#基于龙猫-X-事件机制生成事件链列表\" class=\"headerlink\" title=\"基于龙猫 X 事件机制生成事件链列表\"></a>基于龙猫 X 事件机制生成事件链列表</h2><p>在说明事件链的生成机制前，我们需要研究一下龙猫 X 的通讯机制。</p>\n<p>龙猫 X 的数据通讯机制由订阅发布模式机制组成，以下罗列了在实际业务中组件间通讯的流向示意图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A 组件（A1 事件）-&gt; 发布事件（主动事件） -&gt; 订阅事件（被动事件） -&gt; B 组件（B1 事件）</span><br><span class=\"line\"></span><br><span class=\"line\">B 组件（B2 事件）-&gt; C 组件（C1 事件）</span><br><span class=\"line\"></span><br><span class=\"line\">立即注册（Button 组件）-&gt; 显示弹窗（FixedContainer 组件）</span><br><span class=\"line\"></span><br><span class=\"line\">立即签到（Button 组件）-&gt; 签到接口（Interface 组件）</span><br><span class=\"line\"></span><br><span class=\"line\">签到接口（Interface 组件）-&gt; 签到成功（Interface 组件）</span><br></pre></td></tr></table></figure>\n<p>组件组织方式是扁平化的，事件关系具有零散化的特点。</p>\n<p>用户触发组件 A 的 A1 事件，经过发布订阅机制触达组件 B 的 B1 事件。如果 B1 事件是类似于显示/隐藏、改变样式等操作，那么属于一个数据流向的终点。</p>\n<p>如果 B1 事件是类似于发送请求等事件，请求响应成功即需要执行另一个回调命令，例如我们把 B2 看作请求的响应成功 <code>fetchSuccess</code> 事件，当请求响应成功后，自动执行后续连接的组件 C 的 C1 事件。</p>\n<p>从上述说明中，我们可以构建出龙猫 X 组件间事件流模型 <code>组件 A 事件 A1 -&gt; 组件B事件B1</code>，<code>组件B事件B2 =&gt; 组件C事件C1</code>。</p>\n<p>由于订阅发布通讯机制的存在，发布事件（我们称为主动事件）天然地与订阅事件（我们称为被动事件）自动连接起来，但是关键的节点在于，仍以上述组件 B 的例子数名，组件 B 内存在两个定义的事件 B1 和 B2，它们通过组件内部的代码设定的回调联系起来，但是在我们的配置数据层面并未解决，所以我们需要一份清单总结所有龙猫 X 组件中存在的组件内被动和主动事件非用户触发连接的关系表，这个对于后续构成事件链是关键的一步。</p>\n<ol>\n<li>将零散事件关系，以收集组件事件内联的关系表解决单个事件通讯间无法连结的问题，最终组织成事件链</li>\n<li>通过某一事件，能自动触发后续事件（某些龙猫 X 定义为主动事件并非所有由用户触发，也能是组件内部触发）</li>\n</ol>\n<p><img src=\"http://img.mrsingsing.com/automatation-test-events-chain.jpg\" alt=\"事件链示意图\"></p>\n<p>上述图片展示了实际业务中的事件链示例，该事件链以名为「立即注册」的 Button 按钮组件触发，后续经由 Input 输入框组件获取已前置输入的手机号数据，内部数据流获取数据后触发 Input 组件内的另一个取值的主动事件，然后取值会检验输入框输入数据的有效性，根据有效性分流取值成功与取值失败的被动事件。如果取值失败，则会弹出 Message 组件提示输入框输入数据无效的相关信息；如果取值成功，则会用获取到的手机号和其他相关参数请求接口验证，响应后根据后台返回结果分流为进而请求另一个请求短信验证码的接口还是需要进行鉴定用户为真实用户的图形验证码操作。这就构成一条完整的事件链，整个事件链中除了输入框额外的数据收入外，用户只需触发一次「立即注册」的按钮即可检验后续流程。</p>\n<p>在制定事件链形成方案后，那么摆在面前的仍有几个问题：</p>\n<ul>\n<li>如何启动执行单个事件链？</li>\n<li>如何知道一个事件链流程已经执行完毕？</li>\n<li>在什么时机对执行结果进行断言测试？</li>\n</ul>\n<p>经过分析现有龙猫组件的特点。事件链触发种类主要有以下几个类型：</p>\n<ul>\n<li>浏览器默认事件：页面容器加载完毕、相关 SDK 注册成功等</li>\n<li>用户交互触发：点击按钮、点击图片</li>\n<li>组件钩子（被动性质/间接的主动事件）：接口请求成功失败/收集值成功失败/表单项值改变时/及贷 SDK 的 Ready 事件</li>\n</ul>\n<p>如果对浏览器的的事件循环机制有过了解的，不难联想到这都与 JavaScript 异步事件相关：</p>\n<ul>\n<li>定时器 Timer</li>\n<li>HTML Parsing</li>\n<li>HTTP Request</li>\n<li>I/O（Mouse、Event）</li>\n<li>Promise。then</li>\n</ul>\n<p>总结：</p>\n<ul>\n<li>JavaScript 宿主环境运行中的事件循环机制（定时器、UI Rendering、I/O、HTTP Request）</li>\n<li>用于存储状态的表单高阶组件的取值事件（其实是相当于取值后，在组件内部设定校验逻辑）</li>\n</ul>\n<p>根据上述生成事件链的机制，能将页面配置的事件链自动整理生成列表，后续需要通过测试服务进行自动化测试。</p>\n<h2 id=\"利用-Puppeteer-进行自动化测试\"><a href=\"#利用-Puppeteer-进行自动化测试\" class=\"headerlink\" title=\"利用 Puppeteer 进行自动化测试\"></a>利用 Puppeteer 进行自动化测试</h2><p>测试用的后端项目使用 Egg 的技术搭建，鉴于前后端信息交互可能会比较频繁的原因，搭配 Socket.IO 建立起前后端的通讯。</p>\n<p>这里需要注意的是，Socket.IO 前后端选用的具体库包具有差异：</p>\n<ul>\n<li>前端：<code>socket.io-client</code></li>\n<li>后端：<code>egg-socket.io</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chat</span><br><span class=\"line\">├── app</span><br><span class=\"line\">│   ├── extend</span><br><span class=\"line\">│   │   └── helper.js</span><br><span class=\"line\">│   ├── io</span><br><span class=\"line\">│   │   ├── controller</span><br><span class=\"line\">│   │   │   └── default.js</span><br><span class=\"line\">│   │   └── middleware</span><br><span class=\"line\">│   │       ├── connection.js</span><br><span class=\"line\">│   │       └── packet.js</span><br><span class=\"line\">│   └── router.js</span><br><span class=\"line\">├── config</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure>\n<p>Egg 框架的好处是其生态提供了相关的插件，很好地与项目集成，开发起来体验很好。</p>\n<p>具体实现细节参考 <a href=\"https://eggjs.org/zh-cn/tutorials/socketio.html\" target=\"_blank\" rel=\"noopener\">Egg - Socket.IO 教程</a></p>\n<p>而另一方面，需要使用业内较为成熟的测试方法进行测试，我们经过对比研究后选择 Puppeteer 这款由 Google 出品的开源支持无头浏览器的框架。</p>\n<p>Puppeteer 基于 Chrome DevTool Protocol（简称 CDP），而 CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速通道。</p>\n<p><img src=\"http://img.mrsingsing.com/automatation-test-puppeteer-pyramid.png\" alt=\"Puppeteer 实现模型\"></p>\n<p>Puppeteer 广泛应用于各大公司团队的实际业务场景：</p>\n<ul>\n<li>通用<ul>\n<li>生成页面的屏幕截图和 PDF</li>\n<li>自动化提交表单、模拟键鼠输入、自动化单元测试</li>\n<li>网站性能分析：可以抓取并跟踪网站的执行时间轴，帮助分析效率问题</li>\n<li>抓取网页内容，也就是我们常说的爬虫</li>\n</ul>\n</li>\n<li>业务实践<ul>\n<li>阿里：<a href=\"https://yq.aliyun.com/articles/718188\" target=\"_blank\" rel=\"noopener\">阿里 99 大促模型识别背后的样本生成</a></li>\n<li>有赞：<a href=\"https://www.infoq.cn/article/dcSBL_9AzCwVPsaQ70dh\" target=\"_blank\" rel=\"noopener\">使用 Puppeteer 搭建统一海报渲染服务</a></li>\n<li>其他：<a href=\"https://www.jianshu.com/p/42585c78eeec\" target=\"_blank\" rel=\"noopener\">基于 Puppeteer 打造前端巡检监控体系</a></li>\n</ul>\n</li>\n</ul>\n<p>那么 Node 服务是如何与 Puppeteer 进行服务的呢？</p>\n<p>Puppeteer 提供一种方法 <code>page.exposeFunction</code> 将能在 Node 服务进程调用的函数方法名挂载在 Puppeteer 创建的测试页面的全局变量 <code>window</code> 上。</p>\n<p>当我们在触发事件链开端事件时，通过 Node 服务进而操作无头浏览器内的页面，并在专用于发布订阅模式事件关系传递中调用该挂载全局的函数，将相关参数结果返回到 Node 服务的相关服务中。</p>\n<p><img src=\"http://img.mrsingsing.com/automatation-test-case.jpg\" alt=\"无头浏览器事件响应信息响应机制\"></p>\n<p>从上图可以看到，每当被动性质事件触发后，事件链中的被动事件会在触发时额外发送消息发送到 Node 服务，获得响应后跑过测试用例即将最终结果返回到前端。</p>\n<p><strong>那么同时多个 Node.js 进程会遭遇性能问题？</strong></p>\n<p>存在的问题：</p>\n<ul>\n<li>启动耗时长<ul>\n<li>复用浏览器实例和页面实例</li>\n<li>Puppeteer 的优化手段 =&gt; Chromium Command Line</li>\n</ul>\n</li>\n<li>性能消耗高<ul>\n<li>定时重启无头浏览器实例的机制 =&gt; 定时器</li>\n</ul>\n</li>\n</ul>\n<p>无头浏览器实例与测试页面 Tab 持久化</p>\n<ul>\n<li>通过请求 Headless Chrome 进程端口，获取无头浏览器实例的 WS URL，通过 <code>browser.connect</code> 重连</li>\n<li>Radis 缓存</li>\n<li>存文件</li>\n<li>存在 Egg App Config 中（相当于全局变量）</li>\n</ul>\n<p>如此这般，就将整个流程都实现了闭环：</p>\n<ol>\n<li>根据页面配置数据生成事件链（列表）</li>\n<li>选择前置数据输入及测试用例</li>\n<li>建立前后端通讯及测试服务和无头浏览器的通讯</li>\n<li>触发用户交互事件</li>\n<li>执行无头浏览器内页面对应事件</li>\n<li>返回响应结果</li>\n</ol>"},{"title":"AntDesign 组件化开发探索之表单业务设计实践总结","date":"2019-04-05T00:00:00.000Z","_content":"\n## 需求分析\n\n最近接到一块关于促销活动功能的需求，除了常规的数个日志类型和筛选统计类型展示的列表之外，还需要完成关于促销活动的创建与编辑页面的组件化设计。\n\n活动的创建页面与编辑页面是一个分步表单，分别为活动的基本信息、领取条件以及使用条件三个部分。\n\n按照往常的开发习惯，会把这单个页面的分步表单的三个部分都写在一个组件内，但是这样处理明显是不合理的，因为按照这几个部分的表单需求来看，至少也需要上千行的代码实现，无论从代码可读性或者后期维护的便利性来说，都是不可取的。所以如何合理地设计整个表单页对整个功能的实现以及后期需求迭代的便捷性至关重要。\n\n通过细分可能涉及到的逻辑难点做了以下分析：\n\n- 顶层组件主要负责各个步骤表单的渲染分发器，以及整个分步表单提交前相关数据处理，分发器通过设定标识变量控制用户可视部分表单渲染，数据处理则需要根据接口需求的数据结构进行转换\n- 可视表单在进入下一个步骤之前需要对当前步骤表单信息进行信息校验\n- 根据 antd 表单组件的设计原则封装复合表单项（单选+多选+时间选择输入框）\n  - 复合表单组件支持复用，并提供一键自动填充功能\n  - 动态增减输入框控件并支持控件间的严格规则校验\n- 兼容新建页面和编辑页面，主要区别在于编辑页面需要获取并设置表单默认值\n\n<!-- more -->\n\n## 分步表单实践分析\n\n### 分步表单组织结构\n\n整个分步表单页面从 UI 上划分大体上分为三个部分：步骤进度条、对应的表单项以及切换页面的按钮组。\n\n根据 `antd` 组件库的表单设计原则，如果需要 Form 组件自带的收集校验功能，需要使用 `Form.create()` 对自定义的组件进行包装，而且每个需要收集的值还需要 `getFieldDecorator` 进行注册。\n\n`Form.create()` 用于创建一个具有注册、收集、校验功能的实例。\n\n```jsx\nclass Basic extends React.Component {\n  render(){\n    <Form>\n      <Form.Item>\n        {\n          getFieldDecorator('expiration', {\n            initialValue: fields.expiration ? fields.expiration : undefined,\n            validateFirst: true,\n            rules: [\n              { required: true, message: '必填' }\n            ]\n          })(<SuffixInput unit=\"天\" placeholder=\"请输入整数\" />)\n        }\n      </Form.Item>\n    <Form>\n  }\n}\n\nForm.create()(Basic)\n```\n\n整个页面的数据储存方式决定了整个分步表单的组织结构，也决定了编写业务逻辑时对数据流的处理方法。因此我对两种功能方案进行了对比。\n\n### 数据存储方案\n\n**顶层组件**\n\n**隔层传送：** 如果在顶层组件包装，那么就需要把 Form 内部创建的实例以及一些修饰器 `getFieldDecorator`、校验表单值 `validateFields` 等方法通过 Props 再传递给各个步骤组件。\n\n**同步卸载：** 在对当前步骤表单填充完成并切换步骤后后，上个步骤的组件会从页面卸载，最终表单提交时候会无法获取之前已经填充的表单的值。因为这些步骤的组件卸载后存储表单值的实例也会同时卸载。\n\n**各个步骤组件**\n\n**需同步数据：** 如果在顶层组件下的各个步骤组件进行包装，那么就需要在切换下个步骤前对表单值进行验证，验证失败会进行拦截，而验证成功则会将数据映射到顶层组件的 State 中，该分步骤组件以及 Form 创建的表单数据存储实例均会一并卸载。若页面再切换到其他步骤的页面时，需要从 Props 获取该步骤页面的表单值，再通过 `initialValue` 映射到 Form 组件内部生成的实例中。\n\n**功能明确：** 这样设计的好处是将各个分步的表单分为单独的表单看待，功能分工更加明确，无论从功能实现还是后期维护上只需要对该组件内的业务逻辑进行修改即可，不用兼容顶层组件的逻辑。\n\n**兼容页面：** 更重要的是，顶层组件对各个步骤的表单域值进行分发，再通过 `initialValue` 设置表单默认值的方式在编辑页面的应用上会更加合理。因此最终采用对各个步骤组件进行封装的方法。\n\n### 同步数据的时机\n\n尽管已经决定在各个步骤组件中进行 Form 组件包装，但是另一方面需要考虑当用户填充功能表单时数据是在切换页面时统一校验再存储在上级组件，还是实时存储呢。\n\n如果是采用实时存储的方案的话，可以使用 AntDesign 提供的官方案例 [表单数据存储于上层组件](https://ant.design/components/form-cn/#components-form-demo-global-state) ，但是这时候会面临一个问题是，每次变更输入框内的值时都会触发上层组件的 Re-Render ，当分步组件中表单项比较多的时候，或者表单项嵌套的是一个复杂的需要频繁变更值的控件就很可能出现页面卡顿等的性能问题。\n\n如下图所示，即是实时更新表单域值的数据同步方案：\n\n- 通过 Form 组件内部监听函数 onFieldsChange 获取实时变化的表单值，并通过上层组件的 `handleFormChange` 存储在 State 中\n- 上层组件 State 发生变化，表单值通过 Props 传递给子组件，在传递给子组件之前会经过修饰子组件的 Form 组件，组件内部提供 `mapPropsToFields` 方法，这个方法的作用是把父组件的属性映射到表单项上，但是需要对返回值中的表单域数据用 `Form.createFormField` 标记\n\n![real-time-synchronization](http://img.mrsingsing.com/ant-form-real-time-synchronization.png)\n\n切换页面时进行数据验证并同步到上层组件的数据同步方案：\n\n- 当用户对表单进行填充时，表单值的变化会实时反映到 Form 组件内部构建的 FieldsStore 实例中，驱动 Child 组件 Re-Render\n- 当用户填充完毕并提交当前步骤的表单时，触发上层组件 handleFormChange 进行数据同步\n\n整个流程相比实时存储的方案会更加简洁，减少因数据同步导致上层组件 Re-Render。\n\n![verifying-synchronization](http://img.mrsingsing.com/ant-form-verifying-synchronization.png)\n\n### 异步请求处理方案\n\n表单编辑页在加载页面时，通过 Model 进行异步向服务器请求数据，而当服务器响应返回浏览器这段时间，页面的组件已经完成初始化阶段并挂载到浏览器 DOM 树中。\n\n如果按照新建页面根据顶层组件的状态向底层组件传递表单域值，并于各个表单项初始化时使用 `initialValue` 设置表单的初始值，该值会由于组件初始化与异步请求响应之间存在时间差而失效，因此需要提供一种方案等待异步请求响应后再对底层组件进行初始化渲染。\n\n既然底层组件需要对表单域值进行初始化，那么我们可以手动设置阻塞等待数据响应后才对底层组件渲染。\n\n**简易示例：**\n\n```jsx\nstatic getDerviedStateFromProps(nextProps, prevState){\n  if (\n    !isEmptyObject(dataDetail) &&\n    !isEmptyArray(dataList) &&\n    !prevState.isInitial\n  ){\n    // ...Logic Disposal\n\n    return {\n      basic, receipt, usage, isInitial: true\n    }\n  }\n  return null\n}\n```\n\n通过生命周期函数 `getDerivedStateFromProps` 根据 Model 传入的 Store 再转存到顶层组件的状态中，这里设置了状态 `isInitial` 用于判断是否为异步请求响应后的初次触发，目的是避免 Props 变化或者顶层组件的父组件重渲染导致该生命周期函数触发。\n\n除了在 `getDerivedStateFromProps` 对 State 赋值的操作进行拦截外，还需要在组件渲染控制器设定加载动效，以度过等待异步请求的时间，能有效缓解用户的焦虑。\n\n```jsx\ngetCurrentStepComponent(current) {\n  const canRendering = [basic, receipt, usage].every(item => !isEmptyObject(item));\n  if (!canRendering) {\n    return (\n      <div className={styles.spin}>\n        <Spin style={{ margin: 32 }}/>\n      </div>\n    );\n  }\n  // Return SubComponent to render\n}\n```\n\n## 复合表单项设计分析\n\n### 动态增减复合组件\n\n在领取条件的分步表单中需要设计一个复合组件用于设定促销优惠券使用的时间段。\n\n主要包含以下功能以及相关规则：\n\n- 基础组件组合\n  - 单项选择组件：用于控制其余基础组件隐藏与显示\n  - 多项选择组件：选择周一至周日的多选输入框\n  - 时间选择组件：每项为时分为元素的时间段选择输入框\n- 时间选择组件支持动态增减，至少存在一个，至多存在五个\n- 支持表单校验，时间范围选择必须合法，且多个时间范围间不能存在重叠情况\n\n根据 AntDesign 的文档提供的相关实现方法，这里有两种实现方案：\n\n- 一种是自定义表单控件，将多种类型的基础组件糅合在一起，多个字段综合为一个对象，存储在一个上层字段中（上层字段与其他表单项平级）\n\n```jsx\nconst data = {\n  name: 'Foo',\n  interval: {\n    type: 'ALL',\n    week: ['1', '2', '3']\n    interval: [\n      { startTime: '08:00', endTime: '10:00'},\n      { startTime: '12:00', endTime: '14: 00'}\n    ]\n  }\n}\n```\n\n- 一种是根据动态增减表单项，将多个类型的基础组件生成多个字段，与其他表单项平级。[官方示例实现](https://ant.design/components/form-cn/#components-form-demo-dynamic-form-item)\n\n从需求出发，无论出原型设计上还是前端组件设计上，都应该保持功能一致，也就是说这个组件应该封装成单独的组件，组件内部有控制开关，根据单项选择展示不同的次级表单项，而且动态增减的只是时间段输入框，而与单项选择和日期选择无关，因此将多个基础组件封装起来并通过 Ant Design 提供的自定义表单控件的组合模式能够更合理地实现此功能。\n\n![time-interval-exhibition](http://img.mrsingsing.com/ant-form-time-interval-exhibition.gif)\n\n## Form 组件使用总结\n\n- 使用 Radio / Checked 这些选择组件是不推荐使用 feedback #issue\n- input 在按 Tab 切换文本输入框时不获取焦点的方法：将 input 的 tabindex 设置为 -1\n- input 不被选中的方法：设置 readonly 只读属性\n- input 取消浏览器提供的自动填充 `autoComplete=off`\n- 由 getFieldDecorator 包裹的表单组件默认值为 `undefined` 而非 `null` 或者 `''`\n\n比如设置默认值可以这样设置\n\n```jsx\ngetFieldDecorator('name', {\n  initialValue: fields.name ? fields.name : undefined,\n  rules: [],\n})(<Input />);\n```\n\n- 多个校验规则在校验时反馈只单独显示一条规则，当该规则通过时再校验下条规则，可以设置 `validateFirst: true`\n- 如果触发事件需要在上层处理，而数据在当前组件存储，那么可以在当前组件做一层拦截，在当前组件事件触发 `props` 传入的事件。\n- 数组操作少用 `push` 直接在原数组中操作的方法，多使用 `concat` 、 `filter` 等返回新数组的方法（Immutable 的概念）\n\n## 总结思考\n\n- 应该减少需求功能实现的耗时，更应该关注用户的体验、组件设计的合理性和可扩展性、功能的可用性、功能的优化以及测试的覆盖性\n- 因为该项目的主要需求都是基于 antd 基础组件库进行业务组件的封装，因此适当地研究 antd 底层源代码可以更好地理解组件运行原理，而且能学习到很多 React 组件优秀的设计模式和代码书写方式\n- 类似的业务模块功能可能会经历多次迭代，功能可增可减，因此开发需求前对功能业务需要有适当地理解，这有助于前端开发对组件模块的设计，而设计的合理性不仅在出现问题时快速定位错误，而且能有效地减少后期维护的成本\n\n## 参考资料\n\n### 相关开源项目\n\n- [antd: ^3.12.0](https://github.com/ant-design/ant-design)\n  - [FormComponent](https://github.com/ant-design/ant-design/blob/master/components/form/index.en-US.md)\n  - [rc-form](https://github.com/react-component/form)\n  - [async-validator](https://github.com/yiminghe/async-validator)\n- [moment: ^2.22.1](https://github.com/moment/moment)\n\n### 分析\n\n- [表单实现原理](https://github.com/ant-design/ant-design/blob/master/components/form/docs/tutorial.md)\n- [10 分钟精通 Ant Design Form 表单](https://juejin.im/post/5c47ffff51882533e05ef4f9)\n- [antd 表单性能的改进实践](https://zhuanlan.zhihu.com/p/27740483?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com)\n- [Redux-sage API](https://redux-saga-in-chinese.js.org/docs/api/)\n","source":"_posts/form-business-design-pratice-in-antd.md","raw":"---\ntitle: AntDesign 组件化开发探索之表单业务设计实践总结\ndate: '2019-04-05'\n---\n\n## 需求分析\n\n最近接到一块关于促销活动功能的需求，除了常规的数个日志类型和筛选统计类型展示的列表之外，还需要完成关于促销活动的创建与编辑页面的组件化设计。\n\n活动的创建页面与编辑页面是一个分步表单，分别为活动的基本信息、领取条件以及使用条件三个部分。\n\n按照往常的开发习惯，会把这单个页面的分步表单的三个部分都写在一个组件内，但是这样处理明显是不合理的，因为按照这几个部分的表单需求来看，至少也需要上千行的代码实现，无论从代码可读性或者后期维护的便利性来说，都是不可取的。所以如何合理地设计整个表单页对整个功能的实现以及后期需求迭代的便捷性至关重要。\n\n通过细分可能涉及到的逻辑难点做了以下分析：\n\n- 顶层组件主要负责各个步骤表单的渲染分发器，以及整个分步表单提交前相关数据处理，分发器通过设定标识变量控制用户可视部分表单渲染，数据处理则需要根据接口需求的数据结构进行转换\n- 可视表单在进入下一个步骤之前需要对当前步骤表单信息进行信息校验\n- 根据 antd 表单组件的设计原则封装复合表单项（单选+多选+时间选择输入框）\n  - 复合表单组件支持复用，并提供一键自动填充功能\n  - 动态增减输入框控件并支持控件间的严格规则校验\n- 兼容新建页面和编辑页面，主要区别在于编辑页面需要获取并设置表单默认值\n\n<!-- more -->\n\n## 分步表单实践分析\n\n### 分步表单组织结构\n\n整个分步表单页面从 UI 上划分大体上分为三个部分：步骤进度条、对应的表单项以及切换页面的按钮组。\n\n根据 `antd` 组件库的表单设计原则，如果需要 Form 组件自带的收集校验功能，需要使用 `Form.create()` 对自定义的组件进行包装，而且每个需要收集的值还需要 `getFieldDecorator` 进行注册。\n\n`Form.create()` 用于创建一个具有注册、收集、校验功能的实例。\n\n```jsx\nclass Basic extends React.Component {\n  render(){\n    <Form>\n      <Form.Item>\n        {\n          getFieldDecorator('expiration', {\n            initialValue: fields.expiration ? fields.expiration : undefined,\n            validateFirst: true,\n            rules: [\n              { required: true, message: '必填' }\n            ]\n          })(<SuffixInput unit=\"天\" placeholder=\"请输入整数\" />)\n        }\n      </Form.Item>\n    <Form>\n  }\n}\n\nForm.create()(Basic)\n```\n\n整个页面的数据储存方式决定了整个分步表单的组织结构，也决定了编写业务逻辑时对数据流的处理方法。因此我对两种功能方案进行了对比。\n\n### 数据存储方案\n\n**顶层组件**\n\n**隔层传送：** 如果在顶层组件包装，那么就需要把 Form 内部创建的实例以及一些修饰器 `getFieldDecorator`、校验表单值 `validateFields` 等方法通过 Props 再传递给各个步骤组件。\n\n**同步卸载：** 在对当前步骤表单填充完成并切换步骤后后，上个步骤的组件会从页面卸载，最终表单提交时候会无法获取之前已经填充的表单的值。因为这些步骤的组件卸载后存储表单值的实例也会同时卸载。\n\n**各个步骤组件**\n\n**需同步数据：** 如果在顶层组件下的各个步骤组件进行包装，那么就需要在切换下个步骤前对表单值进行验证，验证失败会进行拦截，而验证成功则会将数据映射到顶层组件的 State 中，该分步骤组件以及 Form 创建的表单数据存储实例均会一并卸载。若页面再切换到其他步骤的页面时，需要从 Props 获取该步骤页面的表单值，再通过 `initialValue` 映射到 Form 组件内部生成的实例中。\n\n**功能明确：** 这样设计的好处是将各个分步的表单分为单独的表单看待，功能分工更加明确，无论从功能实现还是后期维护上只需要对该组件内的业务逻辑进行修改即可，不用兼容顶层组件的逻辑。\n\n**兼容页面：** 更重要的是，顶层组件对各个步骤的表单域值进行分发，再通过 `initialValue` 设置表单默认值的方式在编辑页面的应用上会更加合理。因此最终采用对各个步骤组件进行封装的方法。\n\n### 同步数据的时机\n\n尽管已经决定在各个步骤组件中进行 Form 组件包装，但是另一方面需要考虑当用户填充功能表单时数据是在切换页面时统一校验再存储在上级组件，还是实时存储呢。\n\n如果是采用实时存储的方案的话，可以使用 AntDesign 提供的官方案例 [表单数据存储于上层组件](https://ant.design/components/form-cn/#components-form-demo-global-state) ，但是这时候会面临一个问题是，每次变更输入框内的值时都会触发上层组件的 Re-Render ，当分步组件中表单项比较多的时候，或者表单项嵌套的是一个复杂的需要频繁变更值的控件就很可能出现页面卡顿等的性能问题。\n\n如下图所示，即是实时更新表单域值的数据同步方案：\n\n- 通过 Form 组件内部监听函数 onFieldsChange 获取实时变化的表单值，并通过上层组件的 `handleFormChange` 存储在 State 中\n- 上层组件 State 发生变化，表单值通过 Props 传递给子组件，在传递给子组件之前会经过修饰子组件的 Form 组件，组件内部提供 `mapPropsToFields` 方法，这个方法的作用是把父组件的属性映射到表单项上，但是需要对返回值中的表单域数据用 `Form.createFormField` 标记\n\n![real-time-synchronization](http://img.mrsingsing.com/ant-form-real-time-synchronization.png)\n\n切换页面时进行数据验证并同步到上层组件的数据同步方案：\n\n- 当用户对表单进行填充时，表单值的变化会实时反映到 Form 组件内部构建的 FieldsStore 实例中，驱动 Child 组件 Re-Render\n- 当用户填充完毕并提交当前步骤的表单时，触发上层组件 handleFormChange 进行数据同步\n\n整个流程相比实时存储的方案会更加简洁，减少因数据同步导致上层组件 Re-Render。\n\n![verifying-synchronization](http://img.mrsingsing.com/ant-form-verifying-synchronization.png)\n\n### 异步请求处理方案\n\n表单编辑页在加载页面时，通过 Model 进行异步向服务器请求数据，而当服务器响应返回浏览器这段时间，页面的组件已经完成初始化阶段并挂载到浏览器 DOM 树中。\n\n如果按照新建页面根据顶层组件的状态向底层组件传递表单域值，并于各个表单项初始化时使用 `initialValue` 设置表单的初始值，该值会由于组件初始化与异步请求响应之间存在时间差而失效，因此需要提供一种方案等待异步请求响应后再对底层组件进行初始化渲染。\n\n既然底层组件需要对表单域值进行初始化，那么我们可以手动设置阻塞等待数据响应后才对底层组件渲染。\n\n**简易示例：**\n\n```jsx\nstatic getDerviedStateFromProps(nextProps, prevState){\n  if (\n    !isEmptyObject(dataDetail) &&\n    !isEmptyArray(dataList) &&\n    !prevState.isInitial\n  ){\n    // ...Logic Disposal\n\n    return {\n      basic, receipt, usage, isInitial: true\n    }\n  }\n  return null\n}\n```\n\n通过生命周期函数 `getDerivedStateFromProps` 根据 Model 传入的 Store 再转存到顶层组件的状态中，这里设置了状态 `isInitial` 用于判断是否为异步请求响应后的初次触发，目的是避免 Props 变化或者顶层组件的父组件重渲染导致该生命周期函数触发。\n\n除了在 `getDerivedStateFromProps` 对 State 赋值的操作进行拦截外，还需要在组件渲染控制器设定加载动效，以度过等待异步请求的时间，能有效缓解用户的焦虑。\n\n```jsx\ngetCurrentStepComponent(current) {\n  const canRendering = [basic, receipt, usage].every(item => !isEmptyObject(item));\n  if (!canRendering) {\n    return (\n      <div className={styles.spin}>\n        <Spin style={{ margin: 32 }}/>\n      </div>\n    );\n  }\n  // Return SubComponent to render\n}\n```\n\n## 复合表单项设计分析\n\n### 动态增减复合组件\n\n在领取条件的分步表单中需要设计一个复合组件用于设定促销优惠券使用的时间段。\n\n主要包含以下功能以及相关规则：\n\n- 基础组件组合\n  - 单项选择组件：用于控制其余基础组件隐藏与显示\n  - 多项选择组件：选择周一至周日的多选输入框\n  - 时间选择组件：每项为时分为元素的时间段选择输入框\n- 时间选择组件支持动态增减，至少存在一个，至多存在五个\n- 支持表单校验，时间范围选择必须合法，且多个时间范围间不能存在重叠情况\n\n根据 AntDesign 的文档提供的相关实现方法，这里有两种实现方案：\n\n- 一种是自定义表单控件，将多种类型的基础组件糅合在一起，多个字段综合为一个对象，存储在一个上层字段中（上层字段与其他表单项平级）\n\n```jsx\nconst data = {\n  name: 'Foo',\n  interval: {\n    type: 'ALL',\n    week: ['1', '2', '3']\n    interval: [\n      { startTime: '08:00', endTime: '10:00'},\n      { startTime: '12:00', endTime: '14: 00'}\n    ]\n  }\n}\n```\n\n- 一种是根据动态增减表单项，将多个类型的基础组件生成多个字段，与其他表单项平级。[官方示例实现](https://ant.design/components/form-cn/#components-form-demo-dynamic-form-item)\n\n从需求出发，无论出原型设计上还是前端组件设计上，都应该保持功能一致，也就是说这个组件应该封装成单独的组件，组件内部有控制开关，根据单项选择展示不同的次级表单项，而且动态增减的只是时间段输入框，而与单项选择和日期选择无关，因此将多个基础组件封装起来并通过 Ant Design 提供的自定义表单控件的组合模式能够更合理地实现此功能。\n\n![time-interval-exhibition](http://img.mrsingsing.com/ant-form-time-interval-exhibition.gif)\n\n## Form 组件使用总结\n\n- 使用 Radio / Checked 这些选择组件是不推荐使用 feedback #issue\n- input 在按 Tab 切换文本输入框时不获取焦点的方法：将 input 的 tabindex 设置为 -1\n- input 不被选中的方法：设置 readonly 只读属性\n- input 取消浏览器提供的自动填充 `autoComplete=off`\n- 由 getFieldDecorator 包裹的表单组件默认值为 `undefined` 而非 `null` 或者 `''`\n\n比如设置默认值可以这样设置\n\n```jsx\ngetFieldDecorator('name', {\n  initialValue: fields.name ? fields.name : undefined,\n  rules: [],\n})(<Input />);\n```\n\n- 多个校验规则在校验时反馈只单独显示一条规则，当该规则通过时再校验下条规则，可以设置 `validateFirst: true`\n- 如果触发事件需要在上层处理，而数据在当前组件存储，那么可以在当前组件做一层拦截，在当前组件事件触发 `props` 传入的事件。\n- 数组操作少用 `push` 直接在原数组中操作的方法，多使用 `concat` 、 `filter` 等返回新数组的方法（Immutable 的概念）\n\n## 总结思考\n\n- 应该减少需求功能实现的耗时，更应该关注用户的体验、组件设计的合理性和可扩展性、功能的可用性、功能的优化以及测试的覆盖性\n- 因为该项目的主要需求都是基于 antd 基础组件库进行业务组件的封装，因此适当地研究 antd 底层源代码可以更好地理解组件运行原理，而且能学习到很多 React 组件优秀的设计模式和代码书写方式\n- 类似的业务模块功能可能会经历多次迭代，功能可增可减，因此开发需求前对功能业务需要有适当地理解，这有助于前端开发对组件模块的设计，而设计的合理性不仅在出现问题时快速定位错误，而且能有效地减少后期维护的成本\n\n## 参考资料\n\n### 相关开源项目\n\n- [antd: ^3.12.0](https://github.com/ant-design/ant-design)\n  - [FormComponent](https://github.com/ant-design/ant-design/blob/master/components/form/index.en-US.md)\n  - [rc-form](https://github.com/react-component/form)\n  - [async-validator](https://github.com/yiminghe/async-validator)\n- [moment: ^2.22.1](https://github.com/moment/moment)\n\n### 分析\n\n- [表单实现原理](https://github.com/ant-design/ant-design/blob/master/components/form/docs/tutorial.md)\n- [10 分钟精通 Ant Design Form 表单](https://juejin.im/post/5c47ffff51882533e05ef4f9)\n- [antd 表单性能的改进实践](https://zhuanlan.zhihu.com/p/27740483?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com)\n- [Redux-sage API](https://redux-saga-in-chinese.js.org/docs/api/)\n","slug":"form-business-design-pratice-in-antd","published":1,"updated":"2021-08-18T03:33:14.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99yv0007v31pxvnu7yu6","content":"<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><p>最近接到一块关于促销活动功能的需求，除了常规的数个日志类型和筛选统计类型展示的列表之外，还需要完成关于促销活动的创建与编辑页面的组件化设计。</p>\n<p>活动的创建页面与编辑页面是一个分步表单，分别为活动的基本信息、领取条件以及使用条件三个部分。</p>\n<p>按照往常的开发习惯，会把这单个页面的分步表单的三个部分都写在一个组件内，但是这样处理明显是不合理的，因为按照这几个部分的表单需求来看，至少也需要上千行的代码实现，无论从代码可读性或者后期维护的便利性来说，都是不可取的。所以如何合理地设计整个表单页对整个功能的实现以及后期需求迭代的便捷性至关重要。</p>\n<p>通过细分可能涉及到的逻辑难点做了以下分析：</p>\n<ul>\n<li>顶层组件主要负责各个步骤表单的渲染分发器，以及整个分步表单提交前相关数据处理，分发器通过设定标识变量控制用户可视部分表单渲染，数据处理则需要根据接口需求的数据结构进行转换</li>\n<li>可视表单在进入下一个步骤之前需要对当前步骤表单信息进行信息校验</li>\n<li>根据 antd 表单组件的设计原则封装复合表单项（单选+多选+时间选择输入框）<ul>\n<li>复合表单组件支持复用，并提供一键自动填充功能</li>\n<li>动态增减输入框控件并支持控件间的严格规则校验</li>\n</ul>\n</li>\n<li>兼容新建页面和编辑页面，主要区别在于编辑页面需要获取并设置表单默认值</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"分步表单实践分析\"><a href=\"#分步表单实践分析\" class=\"headerlink\" title=\"分步表单实践分析\"></a>分步表单实践分析</h2><h3 id=\"分步表单组织结构\"><a href=\"#分步表单组织结构\" class=\"headerlink\" title=\"分步表单组织结构\"></a>分步表单组织结构</h3><p>整个分步表单页面从 UI 上划分大体上分为三个部分：步骤进度条、对应的表单项以及切换页面的按钮组。</p>\n<p>根据 <code>antd</code> 组件库的表单设计原则，如果需要 Form 组件自带的收集校验功能，需要使用 <code>Form.create()</code> 对自定义的组件进行包装，而且每个需要收集的值还需要 <code>getFieldDecorator</code> 进行注册。</p>\n<p><code>Form.create()</code> 用于创建一个具有注册、收集、校验功能的实例。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Basic</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    &lt;Form&gt;</span><br><span class=\"line\">      &lt;Form.Item&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          getFieldDecorator(<span class=\"string\">'expiration'</span>, &#123;</span><br><span class=\"line\">            initialValue: fields.expiration ? fields.expiration : <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">            validateFirst: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            rules: [</span><br><span class=\"line\">              &#123; <span class=\"attr\">required</span>: <span class=\"literal\">true</span>, <span class=\"attr\">message</span>: <span class=\"string\">'必填'</span> &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">          &#125;)(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">SuffixInput</span> <span class=\"attr\">unit</span>=<span class=\"string\">\"天\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"请输入整数\"</span> /&gt;</span></span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/Form.Item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;Form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Form.create()(Basic)</span></span><br></pre></td></tr></table></figure>\n<p>整个页面的数据储存方式决定了整个分步表单的组织结构，也决定了编写业务逻辑时对数据流的处理方法。因此我对两种功能方案进行了对比。</p>\n<h3 id=\"数据存储方案\"><a href=\"#数据存储方案\" class=\"headerlink\" title=\"数据存储方案\"></a>数据存储方案</h3><p><strong>顶层组件</strong></p>\n<p><strong>隔层传送：</strong> 如果在顶层组件包装，那么就需要把 Form 内部创建的实例以及一些修饰器 <code>getFieldDecorator</code>、校验表单值 <code>validateFields</code> 等方法通过 Props 再传递给各个步骤组件。</p>\n<p><strong>同步卸载：</strong> 在对当前步骤表单填充完成并切换步骤后后，上个步骤的组件会从页面卸载，最终表单提交时候会无法获取之前已经填充的表单的值。因为这些步骤的组件卸载后存储表单值的实例也会同时卸载。</p>\n<p><strong>各个步骤组件</strong></p>\n<p><strong>需同步数据：</strong> 如果在顶层组件下的各个步骤组件进行包装，那么就需要在切换下个步骤前对表单值进行验证，验证失败会进行拦截，而验证成功则会将数据映射到顶层组件的 State 中，该分步骤组件以及 Form 创建的表单数据存储实例均会一并卸载。若页面再切换到其他步骤的页面时，需要从 Props 获取该步骤页面的表单值，再通过 <code>initialValue</code> 映射到 Form 组件内部生成的实例中。</p>\n<p><strong>功能明确：</strong> 这样设计的好处是将各个分步的表单分为单独的表单看待，功能分工更加明确，无论从功能实现还是后期维护上只需要对该组件内的业务逻辑进行修改即可，不用兼容顶层组件的逻辑。</p>\n<p><strong>兼容页面：</strong> 更重要的是，顶层组件对各个步骤的表单域值进行分发，再通过 <code>initialValue</code> 设置表单默认值的方式在编辑页面的应用上会更加合理。因此最终采用对各个步骤组件进行封装的方法。</p>\n<h3 id=\"同步数据的时机\"><a href=\"#同步数据的时机\" class=\"headerlink\" title=\"同步数据的时机\"></a>同步数据的时机</h3><p>尽管已经决定在各个步骤组件中进行 Form 组件包装，但是另一方面需要考虑当用户填充功能表单时数据是在切换页面时统一校验再存储在上级组件，还是实时存储呢。</p>\n<p>如果是采用实时存储的方案的话，可以使用 AntDesign 提供的官方案例 <a href=\"https://ant.design/components/form-cn/#components-form-demo-global-state\" target=\"_blank\" rel=\"noopener\">表单数据存储于上层组件</a> ，但是这时候会面临一个问题是，每次变更输入框内的值时都会触发上层组件的 Re-Render ，当分步组件中表单项比较多的时候，或者表单项嵌套的是一个复杂的需要频繁变更值的控件就很可能出现页面卡顿等的性能问题。</p>\n<p>如下图所示，即是实时更新表单域值的数据同步方案：</p>\n<ul>\n<li>通过 Form 组件内部监听函数 onFieldsChange 获取实时变化的表单值，并通过上层组件的 <code>handleFormChange</code> 存储在 State 中</li>\n<li>上层组件 State 发生变化，表单值通过 Props 传递给子组件，在传递给子组件之前会经过修饰子组件的 Form 组件，组件内部提供 <code>mapPropsToFields</code> 方法，这个方法的作用是把父组件的属性映射到表单项上，但是需要对返回值中的表单域数据用 <code>Form.createFormField</code> 标记</li>\n</ul>\n<p><img src=\"http://img.mrsingsing.com/ant-form-real-time-synchronization.png\" alt=\"real-time-synchronization\"></p>\n<p>切换页面时进行数据验证并同步到上层组件的数据同步方案：</p>\n<ul>\n<li>当用户对表单进行填充时，表单值的变化会实时反映到 Form 组件内部构建的 FieldsStore 实例中，驱动 Child 组件 Re-Render</li>\n<li>当用户填充完毕并提交当前步骤的表单时，触发上层组件 handleFormChange 进行数据同步</li>\n</ul>\n<p>整个流程相比实时存储的方案会更加简洁，减少因数据同步导致上层组件 Re-Render。</p>\n<p><img src=\"http://img.mrsingsing.com/ant-form-verifying-synchronization.png\" alt=\"verifying-synchronization\"></p>\n<h3 id=\"异步请求处理方案\"><a href=\"#异步请求处理方案\" class=\"headerlink\" title=\"异步请求处理方案\"></a>异步请求处理方案</h3><p>表单编辑页在加载页面时，通过 Model 进行异步向服务器请求数据，而当服务器响应返回浏览器这段时间，页面的组件已经完成初始化阶段并挂载到浏览器 DOM 树中。</p>\n<p>如果按照新建页面根据顶层组件的状态向底层组件传递表单域值，并于各个表单项初始化时使用 <code>initialValue</code> 设置表单的初始值，该值会由于组件初始化与异步请求响应之间存在时间差而失效，因此需要提供一种方案等待异步请求响应后再对底层组件进行初始化渲染。</p>\n<p>既然底层组件需要对表单域值进行初始化，那么我们可以手动设置阻塞等待数据响应后才对底层组件渲染。</p>\n<p><strong>简易示例：</strong></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> getDerviedStateFromProps(nextProps, prevState)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    !isEmptyObject(dataDetail) &amp;&amp;</span><br><span class=\"line\">    !isEmptyArray(dataList) &amp;&amp;</span><br><span class=\"line\">    !prevState.isInitial</span><br><span class=\"line\">  )&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...Logic Disposal</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      basic, receipt, usage, <span class=\"attr\">isInitial</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过生命周期函数 <code>getDerivedStateFromProps</code> 根据 Model 传入的 Store 再转存到顶层组件的状态中，这里设置了状态 <code>isInitial</code> 用于判断是否为异步请求响应后的初次触发，目的是避免 Props 变化或者顶层组件的父组件重渲染导致该生命周期函数触发。</p>\n<p>除了在 <code>getDerivedStateFromProps</code> 对 State 赋值的操作进行拦截外，还需要在组件渲染控制器设定加载动效，以度过等待异步请求的时间，能有效缓解用户的焦虑。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getCurrentStepComponent(current) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> canRendering = [basic, receipt, usage].every(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> !isEmptyObject(item));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!canRendering) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=&#123;styles.spin&#125;&gt;</span><br><span class=\"line\">        &lt;Spin style=&#123;&#123; <span class=\"attr\">margin</span>: <span class=\"number\">32</span> &#125;&#125;/&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ Return SubComponent to render</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"复合表单项设计分析\"><a href=\"#复合表单项设计分析\" class=\"headerlink\" title=\"复合表单项设计分析\"></a>复合表单项设计分析</h2><h3 id=\"动态增减复合组件\"><a href=\"#动态增减复合组件\" class=\"headerlink\" title=\"动态增减复合组件\"></a>动态增减复合组件</h3><p>在领取条件的分步表单中需要设计一个复合组件用于设定促销优惠券使用的时间段。</p>\n<p>主要包含以下功能以及相关规则：</p>\n<ul>\n<li>基础组件组合<ul>\n<li>单项选择组件：用于控制其余基础组件隐藏与显示</li>\n<li>多项选择组件：选择周一至周日的多选输入框</li>\n<li>时间选择组件：每项为时分为元素的时间段选择输入框</li>\n</ul>\n</li>\n<li>时间选择组件支持动态增减，至少存在一个，至多存在五个</li>\n<li>支持表单校验，时间范围选择必须合法，且多个时间范围间不能存在重叠情况</li>\n</ul>\n<p>根据 AntDesign 的文档提供的相关实现方法，这里有两种实现方案：</p>\n<ul>\n<li>一种是自定义表单控件，将多种类型的基础组件糅合在一起，多个字段综合为一个对象，存储在一个上层字段中（上层字段与其他表单项平级）</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Foo'</span>,</span><br><span class=\"line\">  interval: &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'ALL'</span>,</span><br><span class=\"line\">    week: [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>]</span><br><span class=\"line\">    interval: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">startTime</span>: <span class=\"string\">'08:00'</span>, <span class=\"attr\">endTime</span>: <span class=\"string\">'10:00'</span>&#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">startTime</span>: <span class=\"string\">'12:00'</span>, <span class=\"attr\">endTime</span>: <span class=\"string\">'14: 00'</span>&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一种是根据动态增减表单项，将多个类型的基础组件生成多个字段，与其他表单项平级。<a href=\"https://ant.design/components/form-cn/#components-form-demo-dynamic-form-item\" target=\"_blank\" rel=\"noopener\">官方示例实现</a></li>\n</ul>\n<p>从需求出发，无论出原型设计上还是前端组件设计上，都应该保持功能一致，也就是说这个组件应该封装成单独的组件，组件内部有控制开关，根据单项选择展示不同的次级表单项，而且动态增减的只是时间段输入框，而与单项选择和日期选择无关，因此将多个基础组件封装起来并通过 Ant Design 提供的自定义表单控件的组合模式能够更合理地实现此功能。</p>\n<p><img src=\"http://img.mrsingsing.com/ant-form-time-interval-exhibition.gif\" alt=\"time-interval-exhibition\"></p>\n<h2 id=\"Form-组件使用总结\"><a href=\"#Form-组件使用总结\" class=\"headerlink\" title=\"Form 组件使用总结\"></a>Form 组件使用总结</h2><ul>\n<li>使用 Radio / Checked 这些选择组件是不推荐使用 feedback #issue</li>\n<li>input 在按 Tab 切换文本输入框时不获取焦点的方法：将 input 的 tabindex 设置为 -1</li>\n<li>input 不被选中的方法：设置 readonly 只读属性</li>\n<li>input 取消浏览器提供的自动填充 <code>autoComplete=off</code></li>\n<li>由 getFieldDecorator 包裹的表单组件默认值为 <code>undefined</code> 而非 <code>null</code> 或者 <code>&#39;&#39;</code></li>\n</ul>\n<p>比如设置默认值可以这样设置</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getFieldDecorator(<span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">  initialValue: fields.name ? fields.name : <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">  rules: [],</span><br><span class=\"line\">&#125;)(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Input</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>多个校验规则在校验时反馈只单独显示一条规则，当该规则通过时再校验下条规则，可以设置 <code>validateFirst: true</code></li>\n<li>如果触发事件需要在上层处理，而数据在当前组件存储，那么可以在当前组件做一层拦截，在当前组件事件触发 <code>props</code> 传入的事件。</li>\n<li>数组操作少用 <code>push</code> 直接在原数组中操作的方法，多使用 <code>concat</code> 、 <code>filter</code> 等返回新数组的方法（Immutable 的概念）</li>\n</ul>\n<h2 id=\"总结思考\"><a href=\"#总结思考\" class=\"headerlink\" title=\"总结思考\"></a>总结思考</h2><ul>\n<li>应该减少需求功能实现的耗时，更应该关注用户的体验、组件设计的合理性和可扩展性、功能的可用性、功能的优化以及测试的覆盖性</li>\n<li>因为该项目的主要需求都是基于 antd 基础组件库进行业务组件的封装，因此适当地研究 antd 底层源代码可以更好地理解组件运行原理，而且能学习到很多 React 组件优秀的设计模式和代码书写方式</li>\n<li>类似的业务模块功能可能会经历多次迭代，功能可增可减，因此开发需求前对功能业务需要有适当地理解，这有助于前端开发对组件模块的设计，而设计的合理性不仅在出现问题时快速定位错误，而且能有效地减少后期维护的成本</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><h3 id=\"相关开源项目\"><a href=\"#相关开源项目\" class=\"headerlink\" title=\"相关开源项目\"></a>相关开源项目</h3><ul>\n<li><a href=\"https://github.com/ant-design/ant-design\" target=\"_blank\" rel=\"noopener\">antd: ^3.12.0</a><ul>\n<li><a href=\"https://github.com/ant-design/ant-design/blob/master/components/form/index.en-US.md\" target=\"_blank\" rel=\"noopener\">FormComponent</a></li>\n<li><a href=\"https://github.com/react-component/form\" target=\"_blank\" rel=\"noopener\">rc-form</a></li>\n<li><a href=\"https://github.com/yiminghe/async-validator\" target=\"_blank\" rel=\"noopener\">async-validator</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/moment/moment\" target=\"_blank\" rel=\"noopener\">moment: ^2.22.1</a></li>\n</ul>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><ul>\n<li><a href=\"https://github.com/ant-design/ant-design/blob/master/components/form/docs/tutorial.md\" target=\"_blank\" rel=\"noopener\">表单实现原理</a></li>\n<li><a href=\"https://juejin.im/post/5c47ffff51882533e05ef4f9\" target=\"_blank\" rel=\"noopener\">10 分钟精通 Ant Design Form 表单</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27740483?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com\" target=\"_blank\" rel=\"noopener\">antd 表单性能的改进实践</a></li>\n<li><a href=\"https://redux-saga-in-chinese.js.org/docs/api/\" target=\"_blank\" rel=\"noopener\">Redux-sage API</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><p>最近接到一块关于促销活动功能的需求，除了常规的数个日志类型和筛选统计类型展示的列表之外，还需要完成关于促销活动的创建与编辑页面的组件化设计。</p>\n<p>活动的创建页面与编辑页面是一个分步表单，分别为活动的基本信息、领取条件以及使用条件三个部分。</p>\n<p>按照往常的开发习惯，会把这单个页面的分步表单的三个部分都写在一个组件内，但是这样处理明显是不合理的，因为按照这几个部分的表单需求来看，至少也需要上千行的代码实现，无论从代码可读性或者后期维护的便利性来说，都是不可取的。所以如何合理地设计整个表单页对整个功能的实现以及后期需求迭代的便捷性至关重要。</p>\n<p>通过细分可能涉及到的逻辑难点做了以下分析：</p>\n<ul>\n<li>顶层组件主要负责各个步骤表单的渲染分发器，以及整个分步表单提交前相关数据处理，分发器通过设定标识变量控制用户可视部分表单渲染，数据处理则需要根据接口需求的数据结构进行转换</li>\n<li>可视表单在进入下一个步骤之前需要对当前步骤表单信息进行信息校验</li>\n<li>根据 antd 表单组件的设计原则封装复合表单项（单选+多选+时间选择输入框）<ul>\n<li>复合表单组件支持复用，并提供一键自动填充功能</li>\n<li>动态增减输入框控件并支持控件间的严格规则校验</li>\n</ul>\n</li>\n<li>兼容新建页面和编辑页面，主要区别在于编辑页面需要获取并设置表单默认值</li>\n</ul>","more":"<h2 id=\"分步表单实践分析\"><a href=\"#分步表单实践分析\" class=\"headerlink\" title=\"分步表单实践分析\"></a>分步表单实践分析</h2><h3 id=\"分步表单组织结构\"><a href=\"#分步表单组织结构\" class=\"headerlink\" title=\"分步表单组织结构\"></a>分步表单组织结构</h3><p>整个分步表单页面从 UI 上划分大体上分为三个部分：步骤进度条、对应的表单项以及切换页面的按钮组。</p>\n<p>根据 <code>antd</code> 组件库的表单设计原则，如果需要 Form 组件自带的收集校验功能，需要使用 <code>Form.create()</code> 对自定义的组件进行包装，而且每个需要收集的值还需要 <code>getFieldDecorator</code> 进行注册。</p>\n<p><code>Form.create()</code> 用于创建一个具有注册、收集、校验功能的实例。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Basic</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    &lt;Form&gt;</span><br><span class=\"line\">      &lt;Form.Item&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          getFieldDecorator(<span class=\"string\">'expiration'</span>, &#123;</span><br><span class=\"line\">            initialValue: fields.expiration ? fields.expiration : <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">            validateFirst: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            rules: [</span><br><span class=\"line\">              &#123; <span class=\"attr\">required</span>: <span class=\"literal\">true</span>, <span class=\"attr\">message</span>: <span class=\"string\">'必填'</span> &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">          &#125;)(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">SuffixInput</span> <span class=\"attr\">unit</span>=<span class=\"string\">\"天\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"请输入整数\"</span> /&gt;</span></span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/Form.Item&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;Form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">Form.create()(Basic)</span></span><br></pre></td></tr></table></figure>\n<p>整个页面的数据储存方式决定了整个分步表单的组织结构，也决定了编写业务逻辑时对数据流的处理方法。因此我对两种功能方案进行了对比。</p>\n<h3 id=\"数据存储方案\"><a href=\"#数据存储方案\" class=\"headerlink\" title=\"数据存储方案\"></a>数据存储方案</h3><p><strong>顶层组件</strong></p>\n<p><strong>隔层传送：</strong> 如果在顶层组件包装，那么就需要把 Form 内部创建的实例以及一些修饰器 <code>getFieldDecorator</code>、校验表单值 <code>validateFields</code> 等方法通过 Props 再传递给各个步骤组件。</p>\n<p><strong>同步卸载：</strong> 在对当前步骤表单填充完成并切换步骤后后，上个步骤的组件会从页面卸载，最终表单提交时候会无法获取之前已经填充的表单的值。因为这些步骤的组件卸载后存储表单值的实例也会同时卸载。</p>\n<p><strong>各个步骤组件</strong></p>\n<p><strong>需同步数据：</strong> 如果在顶层组件下的各个步骤组件进行包装，那么就需要在切换下个步骤前对表单值进行验证，验证失败会进行拦截，而验证成功则会将数据映射到顶层组件的 State 中，该分步骤组件以及 Form 创建的表单数据存储实例均会一并卸载。若页面再切换到其他步骤的页面时，需要从 Props 获取该步骤页面的表单值，再通过 <code>initialValue</code> 映射到 Form 组件内部生成的实例中。</p>\n<p><strong>功能明确：</strong> 这样设计的好处是将各个分步的表单分为单独的表单看待，功能分工更加明确，无论从功能实现还是后期维护上只需要对该组件内的业务逻辑进行修改即可，不用兼容顶层组件的逻辑。</p>\n<p><strong>兼容页面：</strong> 更重要的是，顶层组件对各个步骤的表单域值进行分发，再通过 <code>initialValue</code> 设置表单默认值的方式在编辑页面的应用上会更加合理。因此最终采用对各个步骤组件进行封装的方法。</p>\n<h3 id=\"同步数据的时机\"><a href=\"#同步数据的时机\" class=\"headerlink\" title=\"同步数据的时机\"></a>同步数据的时机</h3><p>尽管已经决定在各个步骤组件中进行 Form 组件包装，但是另一方面需要考虑当用户填充功能表单时数据是在切换页面时统一校验再存储在上级组件，还是实时存储呢。</p>\n<p>如果是采用实时存储的方案的话，可以使用 AntDesign 提供的官方案例 <a href=\"https://ant.design/components/form-cn/#components-form-demo-global-state\" target=\"_blank\" rel=\"noopener\">表单数据存储于上层组件</a> ，但是这时候会面临一个问题是，每次变更输入框内的值时都会触发上层组件的 Re-Render ，当分步组件中表单项比较多的时候，或者表单项嵌套的是一个复杂的需要频繁变更值的控件就很可能出现页面卡顿等的性能问题。</p>\n<p>如下图所示，即是实时更新表单域值的数据同步方案：</p>\n<ul>\n<li>通过 Form 组件内部监听函数 onFieldsChange 获取实时变化的表单值，并通过上层组件的 <code>handleFormChange</code> 存储在 State 中</li>\n<li>上层组件 State 发生变化，表单值通过 Props 传递给子组件，在传递给子组件之前会经过修饰子组件的 Form 组件，组件内部提供 <code>mapPropsToFields</code> 方法，这个方法的作用是把父组件的属性映射到表单项上，但是需要对返回值中的表单域数据用 <code>Form.createFormField</code> 标记</li>\n</ul>\n<p><img src=\"http://img.mrsingsing.com/ant-form-real-time-synchronization.png\" alt=\"real-time-synchronization\"></p>\n<p>切换页面时进行数据验证并同步到上层组件的数据同步方案：</p>\n<ul>\n<li>当用户对表单进行填充时，表单值的变化会实时反映到 Form 组件内部构建的 FieldsStore 实例中，驱动 Child 组件 Re-Render</li>\n<li>当用户填充完毕并提交当前步骤的表单时，触发上层组件 handleFormChange 进行数据同步</li>\n</ul>\n<p>整个流程相比实时存储的方案会更加简洁，减少因数据同步导致上层组件 Re-Render。</p>\n<p><img src=\"http://img.mrsingsing.com/ant-form-verifying-synchronization.png\" alt=\"verifying-synchronization\"></p>\n<h3 id=\"异步请求处理方案\"><a href=\"#异步请求处理方案\" class=\"headerlink\" title=\"异步请求处理方案\"></a>异步请求处理方案</h3><p>表单编辑页在加载页面时，通过 Model 进行异步向服务器请求数据，而当服务器响应返回浏览器这段时间，页面的组件已经完成初始化阶段并挂载到浏览器 DOM 树中。</p>\n<p>如果按照新建页面根据顶层组件的状态向底层组件传递表单域值，并于各个表单项初始化时使用 <code>initialValue</code> 设置表单的初始值，该值会由于组件初始化与异步请求响应之间存在时间差而失效，因此需要提供一种方案等待异步请求响应后再对底层组件进行初始化渲染。</p>\n<p>既然底层组件需要对表单域值进行初始化，那么我们可以手动设置阻塞等待数据响应后才对底层组件渲染。</p>\n<p><strong>简易示例：</strong></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> getDerviedStateFromProps(nextProps, prevState)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    !isEmptyObject(dataDetail) &amp;&amp;</span><br><span class=\"line\">    !isEmptyArray(dataList) &amp;&amp;</span><br><span class=\"line\">    !prevState.isInitial</span><br><span class=\"line\">  )&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...Logic Disposal</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      basic, receipt, usage, <span class=\"attr\">isInitial</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过生命周期函数 <code>getDerivedStateFromProps</code> 根据 Model 传入的 Store 再转存到顶层组件的状态中，这里设置了状态 <code>isInitial</code> 用于判断是否为异步请求响应后的初次触发，目的是避免 Props 变化或者顶层组件的父组件重渲染导致该生命周期函数触发。</p>\n<p>除了在 <code>getDerivedStateFromProps</code> 对 State 赋值的操作进行拦截外，还需要在组件渲染控制器设定加载动效，以度过等待异步请求的时间，能有效缓解用户的焦虑。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getCurrentStepComponent(current) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> canRendering = [basic, receipt, usage].every(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> !isEmptyObject(item));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!canRendering) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=&#123;styles.spin&#125;&gt;</span><br><span class=\"line\">        &lt;Spin style=&#123;&#123; <span class=\"attr\">margin</span>: <span class=\"number\">32</span> &#125;&#125;/&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/ Return SubComponent to render</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"复合表单项设计分析\"><a href=\"#复合表单项设计分析\" class=\"headerlink\" title=\"复合表单项设计分析\"></a>复合表单项设计分析</h2><h3 id=\"动态增减复合组件\"><a href=\"#动态增减复合组件\" class=\"headerlink\" title=\"动态增减复合组件\"></a>动态增减复合组件</h3><p>在领取条件的分步表单中需要设计一个复合组件用于设定促销优惠券使用的时间段。</p>\n<p>主要包含以下功能以及相关规则：</p>\n<ul>\n<li>基础组件组合<ul>\n<li>单项选择组件：用于控制其余基础组件隐藏与显示</li>\n<li>多项选择组件：选择周一至周日的多选输入框</li>\n<li>时间选择组件：每项为时分为元素的时间段选择输入框</li>\n</ul>\n</li>\n<li>时间选择组件支持动态增减，至少存在一个，至多存在五个</li>\n<li>支持表单校验，时间范围选择必须合法，且多个时间范围间不能存在重叠情况</li>\n</ul>\n<p>根据 AntDesign 的文档提供的相关实现方法，这里有两种实现方案：</p>\n<ul>\n<li>一种是自定义表单控件，将多种类型的基础组件糅合在一起，多个字段综合为一个对象，存储在一个上层字段中（上层字段与其他表单项平级）</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Foo'</span>,</span><br><span class=\"line\">  interval: &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'ALL'</span>,</span><br><span class=\"line\">    week: [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>]</span><br><span class=\"line\">    interval: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">startTime</span>: <span class=\"string\">'08:00'</span>, <span class=\"attr\">endTime</span>: <span class=\"string\">'10:00'</span>&#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">startTime</span>: <span class=\"string\">'12:00'</span>, <span class=\"attr\">endTime</span>: <span class=\"string\">'14: 00'</span>&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一种是根据动态增减表单项，将多个类型的基础组件生成多个字段，与其他表单项平级。<a href=\"https://ant.design/components/form-cn/#components-form-demo-dynamic-form-item\" target=\"_blank\" rel=\"noopener\">官方示例实现</a></li>\n</ul>\n<p>从需求出发，无论出原型设计上还是前端组件设计上，都应该保持功能一致，也就是说这个组件应该封装成单独的组件，组件内部有控制开关，根据单项选择展示不同的次级表单项，而且动态增减的只是时间段输入框，而与单项选择和日期选择无关，因此将多个基础组件封装起来并通过 Ant Design 提供的自定义表单控件的组合模式能够更合理地实现此功能。</p>\n<p><img src=\"http://img.mrsingsing.com/ant-form-time-interval-exhibition.gif\" alt=\"time-interval-exhibition\"></p>\n<h2 id=\"Form-组件使用总结\"><a href=\"#Form-组件使用总结\" class=\"headerlink\" title=\"Form 组件使用总结\"></a>Form 组件使用总结</h2><ul>\n<li>使用 Radio / Checked 这些选择组件是不推荐使用 feedback #issue</li>\n<li>input 在按 Tab 切换文本输入框时不获取焦点的方法：将 input 的 tabindex 设置为 -1</li>\n<li>input 不被选中的方法：设置 readonly 只读属性</li>\n<li>input 取消浏览器提供的自动填充 <code>autoComplete=off</code></li>\n<li>由 getFieldDecorator 包裹的表单组件默认值为 <code>undefined</code> 而非 <code>null</code> 或者 <code>&#39;&#39;</code></li>\n</ul>\n<p>比如设置默认值可以这样设置</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getFieldDecorator(<span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">  initialValue: fields.name ? fields.name : <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">  rules: [],</span><br><span class=\"line\">&#125;)(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Input</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>多个校验规则在校验时反馈只单独显示一条规则，当该规则通过时再校验下条规则，可以设置 <code>validateFirst: true</code></li>\n<li>如果触发事件需要在上层处理，而数据在当前组件存储，那么可以在当前组件做一层拦截，在当前组件事件触发 <code>props</code> 传入的事件。</li>\n<li>数组操作少用 <code>push</code> 直接在原数组中操作的方法，多使用 <code>concat</code> 、 <code>filter</code> 等返回新数组的方法（Immutable 的概念）</li>\n</ul>\n<h2 id=\"总结思考\"><a href=\"#总结思考\" class=\"headerlink\" title=\"总结思考\"></a>总结思考</h2><ul>\n<li>应该减少需求功能实现的耗时，更应该关注用户的体验、组件设计的合理性和可扩展性、功能的可用性、功能的优化以及测试的覆盖性</li>\n<li>因为该项目的主要需求都是基于 antd 基础组件库进行业务组件的封装，因此适当地研究 antd 底层源代码可以更好地理解组件运行原理，而且能学习到很多 React 组件优秀的设计模式和代码书写方式</li>\n<li>类似的业务模块功能可能会经历多次迭代，功能可增可减，因此开发需求前对功能业务需要有适当地理解，这有助于前端开发对组件模块的设计，而设计的合理性不仅在出现问题时快速定位错误，而且能有效地减少后期维护的成本</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><h3 id=\"相关开源项目\"><a href=\"#相关开源项目\" class=\"headerlink\" title=\"相关开源项目\"></a>相关开源项目</h3><ul>\n<li><a href=\"https://github.com/ant-design/ant-design\" target=\"_blank\" rel=\"noopener\">antd: ^3.12.0</a><ul>\n<li><a href=\"https://github.com/ant-design/ant-design/blob/master/components/form/index.en-US.md\" target=\"_blank\" rel=\"noopener\">FormComponent</a></li>\n<li><a href=\"https://github.com/react-component/form\" target=\"_blank\" rel=\"noopener\">rc-form</a></li>\n<li><a href=\"https://github.com/yiminghe/async-validator\" target=\"_blank\" rel=\"noopener\">async-validator</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/moment/moment\" target=\"_blank\" rel=\"noopener\">moment: ^2.22.1</a></li>\n</ul>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><ul>\n<li><a href=\"https://github.com/ant-design/ant-design/blob/master/components/form/docs/tutorial.md\" target=\"_blank\" rel=\"noopener\">表单实现原理</a></li>\n<li><a href=\"https://juejin.im/post/5c47ffff51882533e05ef4f9\" target=\"_blank\" rel=\"noopener\">10 分钟精通 Ant Design Form 表单</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27740483?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com\" target=\"_blank\" rel=\"noopener\">antd 表单性能的改进实践</a></li>\n<li><a href=\"https://redux-saga-in-chinese.js.org/docs/api/\" target=\"_blank\" rel=\"noopener\">Redux-sage API</a></li>\n</ul>"},{"title":"前端相关业务性能优化技术手段总结","date":"2019-05-19T00:00:00.000Z","_content":"\n技术社区中其实已经有较多的关于前端性能优化的相关文章，看了多篇之后总是觉得内容还有很多遗漏或写得不够完美，尽管还没接手过流量特别大的网站应用项目，但是本人认为日常项目中也需要尽可能地进行性能优化的工作，因为前端工程师的工作很大程度上可以描述为“用尽量少的代价为用户提供效率尽可能高、功能尽可能多、体验尽可能好的网页应用”，而性能优化很大程度上就是实现“尽可能少的代价”、“效率尽可能高”以及“体验尽可能好”。\n\n因此，此文会根据网络请求到网页呈现的完整流程，针对性地提出相关阶段供开发决策者考虑采取的优化方案，因此本文更像是性能优化方案的决策树，而非标准方案：\n\n- 网络链路层面\n- 服务端层面\n- 客户端渲染层面\n- 编码层面\n\n**网络请求到网页呈现的大致流程**\n\n```\n发送网络请求 => 网络链路 => 返回资源(服务端) => 渲染资源(客户端)\n```\n\n<!-- more -->\n\n# 关键渲染路径\n\n在提出各层次的优化方案之前，有必要了解一下性能优化方案实际上解决了哪些性能问题以及解决这些问题的核心归结点。\n\n以下部分关于优化关键渲染路径的建议摘录自 Google 开发者文档：\n[📖 Optimizing the Critical Rendering Path](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path)\n\n为了尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：\n\n- 关键资源的数量\n- 关键路径长度\n- 关键字节的数量\n\n关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。\n\n同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。\n\n最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。\n\n**优化关键渲染路径的常规步骤如下：**\n\n1. 对关键路径进行分析和特性描述：资源数、字节数、长度\n2. 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等\n3. 优化关键字节数以缩短下载时间（往返次数）\n4. 优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度\n\n# 网络链路层面\n\n网络链路作为网络资源和数据的传输通道，充分利用网络技术手段能有效地减少网页资源响应的速度、提升网页资源传输速度以及避免重复传输导致的资源浪费等问题。\n\n## 传输策略\n\n### DNS 查询\n\nDNS 域名解析协议简单来就说负责将域名 URL 转化为服务器主机 IP。了解更多 [DNS 域名解析协议](https://tsejx.github.io/JavaScript-Guidebook/computer-networks/dns.html)\n\nDNS 查询能从两方面进行优化：\n\n- **减少 DNS 查询次数**\n- **DNS 预解析**\n\n通过在文档中使用值为 `http-equiv` 的 `<meta>` 标签打开 DNS 预解析：\n\n```html\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\" />\n```\n\n通过 `rel` 属性值为 `dns-prefetch` 的 `<link>` 标签对特定域名进行预读取\n\n```html\n<link rel='dns-prefetch\" href=\"//host_name_to_prefetch.com\"/>\n```\n\n**相关链接：**\n\n- [MDN：X-DNS-Prefetch-Control](https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching)\n- [DNS Prefetching](https://dev.chromium.org/developers/design-documents/dns-prefetching)\n- [DNS Prefetching for Firefox](https://bitsup.blogspot.com/2008/11/dns-prefetching-for-firefox.html)\n\n### TCP 连接\n\n**持久化连接**：避免重复进行 TCP 的三次握手，HTTP/1.1 默认开启，HTTP/1.0 可以使用。\n\nKeep-Alive 不会永久保持连接，开发者可通过服务器配置限定时间。\n\n```http\nConnection: keep-alive\n```\n\n### HTTP 请求\n\n- **减少 HTTP 请求**\n  - 通过前端构建工具合并脚本和样式表\n  - CSS Sprites 精灵图\n  - 图片使用 Base64 编码嵌入网页，减少图片外部载入的请求数\n- **资源分布式部署至不同域名**\n  - **原因**：主流浏览器对相同域名的并发 HTTP 请求数限制在 4~8 个，当资源过多时，可以采用增加域名的方法增加 HTTP 请求的并发量\n  - **原理**：利用多个不同的域名可以保证这些域名能够同时加载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不同响应域名时间不一致\n- **避免重定向**\n  - URL 末尾应该添加 `/` 但未添加\n- **消除不必要的请求字节**\n- **Cookie**\n  - 压缩 Cookie 大小\n    - 去除不必要的 Cookie\n    - 注意设置 Cookie 的 domain 级别，如没必要，不要影响子域名\n    - 设置合适的过期时间\n  - 静态资源使用无 Cookie 域名\n- [HTTP/2](https://tsejx.github.io/JavaScript-Guidebook/computer-networks/http/http2.html)\n  - 二进制分帧\n  - 多路复用\n  - 服务器推送\n  - 头部压缩\n  - 了解更多 [HTTP/2]\n- [HTTP/3](https://zh.wikipedia.org/wiki/HTTP/3)\n\n**相关链接：**\n\n- [前端性能优化 - 资源预加载](http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/)\n- [HTTP/2 简介和基于 HTTP/2 的 Web 优化](https://github.com/creeperyang/blog/issues/23)\n\n## 缓存策略\n\n制定有效的缓存策略，很大程度上能实现资源的重复利用及传输路径的优化，减少客户端对服务端的网络请求压力，减轻宽度流量。\n\n- [HTTP 缓存](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html)\n  - [强缓存](<[https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%BC%BA%E7%BC%93%E5%AD%98](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#强缓存)>)\n    - Expires 绝对时间 `Expires: Thu, 21 Jan 2017 23:59:59 GMT` 服务器和客户端时间可能不一致\n    - Cache-Control 相对时间 `Cache-Control: max-age=3600`\n  - [协商缓存](<[https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#协商缓存)>)\n    - Last-Modified / If-Modified-Since 绝对时间 `Expires: Wed, 26 Jan 2017 00:35:11 GMT` 资源上次修改的时间\n    - Etag / If-None-Match 随机生成的乱码值\n  - 优先使用强缓存\n    - 当资源文件发生变化时，通过更新页面中引用的资源路径，让浏览器放弃缓存，加载新资源\n    - 通过 [数据摘要算法](https://link.zhihu.com/?target=http%3A//baike.baidu.com/view/10961371.htm) 精准到单个文件粒度的缓存控制\n- [CDN 缓存](https://tsejx.github.io/JavaScript-Guidebook/computer-networks/cdn.html)： 将静态资源和动态网页分集群部署\n  - HTML 部署在自身的服务器上\n  - 打包后的图片 / JavaScript 脚本文件 / CSS 样式文件等资源部署到 CDN 节点上，文件带上 Hash 值\n  - 由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制\n  - CDN 没有 Cookie，使用 CDN 可以减少 Cookie\n  - CDN 会自动合并脚本文件等，减少请求数量\n  - 但是，CDN 同时也增加了域名，增大了同时请求数量\n- **服务器缓存：**将不变的数据、页面缓存到**内存**或**远程存储**（如 Redis 等）上\n- **浏览器缓存**: 通过设置请求的过期时间，将各种不常变的数据进行缓存，合理运用浏览器缓存，缩短数据的获取时间\n  - [Cookie](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/cookie.html)\n  - [WebStorage](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/web-storage.html)\n    - LocalStorage\n    - SessionStorage\n  - IndexDB\n  - [ServiceWorker](https://tsejx.github.io/JavaScript-Guidebook/html5-scripting-programming/offline-and-storage/service-worker.html)\n  - AppCache：采用 mainfest 文件进行缓存\n\n**相关链接：**\n\n- [大公司里怎样开发和部署前端代码？](https://www.zhihu.com/question/20790576)\n- [使用 SRI 增强 LocalStorage 代码安全](https://link.juejin.im/?target=https%3A%2F%2Fimququ.com%2Fpost%2Fenhance-security-for-ls-code.html)\n\n# 服务端层面\n\n由于本文只涉及前端性能优化，但为求流程完整，简单罗列与服务端相关的优化方案的常见手段。\n\n- 多域名资源加载\n- 负载均衡\n- 数据缓存\n- 反向代理\n\n# 客户端层面\n\n- 资源渲染数量/大小\n- 资源渲染路径\n- 用户体验\n\n## 资源渲染数量/大小\n\n- **压缩静态资源，清除无用代码**\n  - Tree Shaking 无用代码移除\n  - UglifyJs 混淆 / 压缩代码\n  - Code Spliting 代码分割（资源按需加载或并行加载）\n- **开启 Gzip 压缩**\n  - 请求头 `Accept-Encoding: gzip, deflate`\n  - 响应头 `Content-Encoding: gzip`\n  - Gzip 能够压缩任何文本类型的响应，包括 HTMl、XML 和 JSON\n  - 已经压缩过的内容如图片、和 PDF 不要使用 Gzip，这些资源内容本身体积就小，再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且有增加文件体积的可能\n- **多份编译文件按条件引入**\n  - 针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件\n  - 可以利用 `<script type=\"module\"> / <script type=\"module\">`进行条件引入用\n- **动态 Polyfill**\n  - 只针对不支持的浏览器运行环境引入 Polyfill\n- **图片优化**\n  - 根据业务场景，与 UI 探讨选择 **合适质量，合适尺寸**\n  - 根据需求和平台，选择 **合适格式**，例如非透明时可用 jpg；非苹果端，使用 webp\n  - 小图片合成 **雪碧图 CSS Sprite**，低于 5K 的图片可以转换成 B**ase64** 内嵌\n  - 合适场景下，使用 I**confont** 或者 **SVG**\n  - 压缩 favicon.ico 并缓存\n  - 使用 Blob 异步加载\n  - 使用 [img-2](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FRevillWeb%2Fimg-2) 代替 img 标签\n  - 嵌入资源：Base64 嵌入资源（针对小的静态图片资源）\n- **字体优化**\n  - 浏览器为了避免 FOUT（Flash Of Unstyled Text），会尽量等待字体加载完成后，再显示应用了该字体的内容。带来了 FOIT（Flash Of Invisible Text 问题），导致空白\n  - 设置多字体，降级方法：使用默认字体\n  - 异步加载字体文件：通过异步加载 CSS，即可避免字体阻塞渲染，还是会空白\n- **多媒体优化**\n  - 音视频\n\n## 资源渲染路径\n\n- **优化加载顺序**\n  - CSS 样式文件放在文档 `<head>` 标签中引入\n    - 把样式表放在 `<head>` 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉\n  - JavaScript 脚本文件放在 `<body>` 标签底部引入\n    - **原因**：加载脚本文件会对后续资源渲染造成阻塞\n    - **方案**：制定合理的脚本文件加载策略\n      - 动态脚本加载（异步加载、延迟加载、按需加载）\n      - 添加 `defer` 属性的脚本文件是在 HTML 解析完之后才会执行。如果是多个，按照加载的顺序依次执行\n      - 添加 `async` 属性的脚本文件是在加载之后立即执行，如果 HTML 还没解析完，会阻塞 HTML 继续解析。如果是多个，执行顺序和加载顺序无关\n  - 影响首屏的，优先级很高的脚本文件也可以 `<head>` 或 `<body>` 首子节点引入，甚至利用 `style` 或 `script` 内联\n- **资源加载方式**\n\n  - 非关键性的文件尽可能的**异步加载和延迟加载**，避免阻塞首页渲染\n  - **资源提示指令**\n    - Preload\n    - Prefetch\n    - Preconnect\n    - Subresource\n  - **异步加载（预加载）**\n    - 利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应\n    - 预判用户的行为，提前加载所需要的资源，则可以快速地响应用户的操作，从而打造更好的用户体验。另一方面，通过提前发起网络请求，也可以减少由于网络过慢导致的用户等待时间。\n    - Preload 规范 W3CPreload\n      - rel 明确告知浏览器启用 preload 功能\n      - as 明确需要预加载资源的类型，包括 JavaScript、Images、CSS、Media 等\n  - **延迟加载（懒加载、按需加载）**\n    - 页面初始加载时将非绝对必须的资源延迟加载，从而提高页面的加载和响应速度\n      - 非首屏使用的数据、样式、脚本、图片等\n      - 用户交互时才会显示的内容\n    - **实现方式：**\n      - 虚拟代理技术：真正加载的对象事先提供一个代理或者说占位符。最常见的场景是在图片的懒加载中，先用一种 loading 的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。\n      - 惰性初始化技术：将代码初始化的时机推迟（特别是那些初始化消耗较大的资源）\n    - **选择时机：**\n      - 滚动条监听：大型图片流场景，通过对用户滚动结束区域进行计算，从而只加载目标区域的资源，这样可以实现节流的目的\n      - 事件回调：常用于需要用户交互的地方，如点击加载更多之类的，这些资源往往通过在用户交互的瞬间（如点击一个触发按钮），发起 AJAX 请求来获取资源。比较简单，在此不再赘述。\n    - 遵循渐进增强理念理念开发网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript\n    - 将首屏以外的 HTML 放在不渲染的元素中，如隐藏的 `<textarea>`，或者 `type` 属性为非执行脚本的 `<script>` 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。\n\n- **资源渲染**\n  - 避免重排，减少重绘，避免白屏，或者交互过程中的卡顿\n  - 通过 [CSS Trigger](https://csstriggers.com/) 查询哪些样式属性会触发重排与重绘\n  - **减少重排的方法**\n    - 页面初始化\n    - 减少对 DOM 元素内容改变（如：文本改变、图片被另一个同尺寸元素替代）\n    - 减少对 DOM 元素尺寸改变（因为边距、填充、边框宽度、宽度、高度等属性改变）\n    - 减少对 DOM 元素位置改变\n    - 减少对可见 DOM 元素的操作（如：增加、移动和删除）\n      - 多次 DOM 操作合并为一次处理\n      - 大量操作时，可将 DOM 脱离文档流或者隐藏，待操作完成后再重新恢复\n    - 减少旋转屏幕的操作\n    - 减少改变浏览器窗口尺寸的操作\n    - 减少设置元素 style 属性\n    - 减少设置元素 class 属性\n    - 通过延迟访问布局信息避免重排版\n      - 如 `offsetWidth`、`offsetHeight` 和 `getComputedStyle` 等\n      - 原因：浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用\n    - 减少在 HTML 中缩放图片\n    - 避免对大部分页面进行重排版\n      - 使用绝对坐标定位页面动画的元素，使它位于页面布局流之外\n      - 启动元素动画，当它扩大时，它临时覆盖部分页面\n      - 当动画结束时，重新定位，从而只一次下移文档其他元素的位置\n    - 开启 GPU 加速\n      - transform\n      - opacity\n      - filter\n\n**相关链接：**\n\n- [前端性能优化之加载技术](https://juejin.im/post/59b73ef75188253db70acdb5#heading-5)\n- [资源提示——什么是 Preload，Prefetch 和 Preconnect？](https://juejin.im/post/5b5984b851882561da216311)\n- [preload-webpack-plugin](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FGoogleChrome%2Fpreload-webpack-plugin)\n- [Preload 技术细节](https://link.juejin.im/?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2016%2F02%2Fpreload-what-is-it-good-for%2F)\n\n## 用户体验\n\n- 谨慎控制好 Web 字体，一个大字体包足够让你功亏一篑\n  - 控制字体包的加载时机\n  - 如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积\n- 分清轻重缓急\n  - 重要的元素优先渲染\n  - 视窗内的元素优先渲染\n- 服务端渲染（SSR）\n  - 减少首屏需要的数据量，剔除冗余数据和请求\n  - 控制好缓存，对数据/页面进行合理的缓存\n  - 页面的请求使用流的形式进行传递\n- 优化用户感知\n  - 利用一些动画 **过渡效果**，能有效减少用户对卡顿的感知\n  - 尽可能利用 **骨架屏（Skeleton）/ Loading** 等减少用户对白屏的感知\n  - 动画帧数尽量保证在 **30 帧** 以上，低帧数、卡顿的动画宁愿不要\n  - JavaScript 执行时间避免超过 100ms ，超过的话就需要做：\n    - 寻找可缓存的点\n    - 任务的分割异步或 web worker 执行\n\n# 编码层面\n\n编码优化，指的就是在代码编写时的，通过一些 **最佳实践**，提升代码的执行性能。通常这并不会带来非常大的收益，但这属于**程序员的自我修养**，而且这也是面试中经常被问到的一个方面，考察自我管理与细节的处理。\n\n## JavaScript 优化\n\n- **数据读取**\n  - 通过作用域链 / 原型链读取变量或方法时，需要更多的耗时，且越长越慢\n  - 对象嵌套越深，读取值也越慢\n  - 最佳实践：\n    - 尽量在局部作用域中进行 **变量缓存**\n    - 避免嵌套过深的数据结构，**数据扁平化** 有利于数据的读取和维护\n- **循环**：循环通常是编码性能的关键点\n  - 代码的性能问题会在循环中被指数倍放大\n  - 最佳实践:\n    - 尽可能 减少循环次数；\n      - 减少遍历的数据量\n      - 完成目的后马上结束循环\n    - 避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存\n    - JavaScript 中使用 **倒序循环** 会略微提升性能\n    - 尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环\n- **条件流程性能**：Map / Object > switch > if-else\n- **模块化**：尝试使用 `import()`\n\n## DOM 优化\n\n- 减少 DOM 的层级，可以减少渲染引擎工作过程中的计算量\n- 减少访问 DOM 的次数，如需多次，将 DOM 缓存于变量中\n- 使用事件委托，避免大量的事件绑定\n- 使用 `requestAnimationFrame` 来实现视觉变化：一般来说我们会使用 `setTimeout` 或 `setInterval` 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿\n\n## CSS 优化\n\n- **层级扁平**，避免过于多层级的选择器嵌套\n- **特定的选择器**：好过一层一层查找：`.xxx-child-text{}` 优于 `.xxx .child .text{}`\n- **减少使用通配符与属性选择器**\n  - 选择器越复杂，匹配用的时间越多\n- **减少不必要的多余属性**\n- 使用 **动画属性** 实现动画，动画时脱离文档流，开启硬件加速，优先使用 CSS 动画\n- 使用 `<link>` 替代原生 @import\n- 避免使用表达式，例如 `font-color: expression((new Date()).getHours()%3?\"#FFF\":\"#AAA\")` 这个表达式会持续地在页面上计算样式，影响页面性能\n\n## HTML 优化\n\n- 写对文档类型声明 `<!DOCTYPE html>` 这能确保浏览器按照最佳的相关规范进行渲染\n- **减少 DOM 数量**，避免不必要的节点或嵌套；\n- 避免空的 `src` 和 `href`：当 `src` 和 `href` 为空时，浏览器会默认填充链接，并将页面的内容加载进来作为它们的值，具体规则如下：\n  - IE 向**页面所在的目录**发送请求\n  - Safari、Chrome、Firefox 向页面本身 URL 发送请求\n  - Opera 不执行任何操作\n- 图片提前 **指定宽高** 或者 **脱离文档流**，能有效减少因图片加载导致的页面回流\n- **语义化标签** 有利于 SEO 与浏览器的解析时间\n- 减少使用 table 进行布局，避免使用 `<br/>` 与 `<hr/>`\n\n# 参考资料\n\n**性能优化方案清单**\n\n- 🧾 [2018 前端性能优化清单](https://juejin.im/post/5a966bd16fb9a0635172a50a)\n- 🧾 [嗨，送你一张 Web 性能优化地图](https://github.com/berwin/Blog/issues/23)\n- 🧾 [Web 性能优化总结](https://segmentfault.com/a/1190000018263418?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com&share_user=1030000000178452)\n- 🧾 [大前端性能总结](https://juejin.im/post/5b025d856fb9a07aa0484e54)\n- 🧾 [CSS 性能优化的 8 个技巧](https://juejin.im/post/5b6133a351882519d346853f)\n- 🧾 [精读 《高效 JavaScript》](https://juejin.im/post/5b7e1f81f265da436a075db4)\n- 🧾 [Web 性能优化清单](https://juejin.im/post/5c011e0c5188252ea66afdfa)\n- 🗃 [性能相关基础知识点研究](https://github.com/barretlee/performance-column/milestone/1)\n- 🗃 [前端性能优化资源列表](https://github.com/liangsenzhi/awesome-wpo-chinese)\n- 🗃 [awesome-wpo](https://github.com/davidsonfellipe/awesome-wpo)\n- 🗃 [A Frontend Checklist for Websites](https://github.com/drublic/checklist)\n\n**优化方向**\n\n- 🎡 [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\n- 🎡 [16 毫秒的优化](http://velocity.oreilly.com.cn/2013/ppts/16_ms_optimization--web_front-end_performance_optimization.pdf)\n- 🎡 [Optimize JavaScript Execution 优化 JavaScript 执行](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution)\n","source":"_posts/means-for-performance-optimization.md","raw":"---\ntitle: 前端相关业务性能优化技术手段总结\ndate: '2019-05-19'\n---\n\n技术社区中其实已经有较多的关于前端性能优化的相关文章，看了多篇之后总是觉得内容还有很多遗漏或写得不够完美，尽管还没接手过流量特别大的网站应用项目，但是本人认为日常项目中也需要尽可能地进行性能优化的工作，因为前端工程师的工作很大程度上可以描述为“用尽量少的代价为用户提供效率尽可能高、功能尽可能多、体验尽可能好的网页应用”，而性能优化很大程度上就是实现“尽可能少的代价”、“效率尽可能高”以及“体验尽可能好”。\n\n因此，此文会根据网络请求到网页呈现的完整流程，针对性地提出相关阶段供开发决策者考虑采取的优化方案，因此本文更像是性能优化方案的决策树，而非标准方案：\n\n- 网络链路层面\n- 服务端层面\n- 客户端渲染层面\n- 编码层面\n\n**网络请求到网页呈现的大致流程**\n\n```\n发送网络请求 => 网络链路 => 返回资源(服务端) => 渲染资源(客户端)\n```\n\n<!-- more -->\n\n# 关键渲染路径\n\n在提出各层次的优化方案之前，有必要了解一下性能优化方案实际上解决了哪些性能问题以及解决这些问题的核心归结点。\n\n以下部分关于优化关键渲染路径的建议摘录自 Google 开发者文档：\n[📖 Optimizing the Critical Rendering Path](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path)\n\n为了尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：\n\n- 关键资源的数量\n- 关键路径长度\n- 关键字节的数量\n\n关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。\n\n同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。\n\n最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。\n\n**优化关键渲染路径的常规步骤如下：**\n\n1. 对关键路径进行分析和特性描述：资源数、字节数、长度\n2. 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等\n3. 优化关键字节数以缩短下载时间（往返次数）\n4. 优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度\n\n# 网络链路层面\n\n网络链路作为网络资源和数据的传输通道，充分利用网络技术手段能有效地减少网页资源响应的速度、提升网页资源传输速度以及避免重复传输导致的资源浪费等问题。\n\n## 传输策略\n\n### DNS 查询\n\nDNS 域名解析协议简单来就说负责将域名 URL 转化为服务器主机 IP。了解更多 [DNS 域名解析协议](https://tsejx.github.io/JavaScript-Guidebook/computer-networks/dns.html)\n\nDNS 查询能从两方面进行优化：\n\n- **减少 DNS 查询次数**\n- **DNS 预解析**\n\n通过在文档中使用值为 `http-equiv` 的 `<meta>` 标签打开 DNS 预解析：\n\n```html\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"on\" />\n```\n\n通过 `rel` 属性值为 `dns-prefetch` 的 `<link>` 标签对特定域名进行预读取\n\n```html\n<link rel='dns-prefetch\" href=\"//host_name_to_prefetch.com\"/>\n```\n\n**相关链接：**\n\n- [MDN：X-DNS-Prefetch-Control](https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching)\n- [DNS Prefetching](https://dev.chromium.org/developers/design-documents/dns-prefetching)\n- [DNS Prefetching for Firefox](https://bitsup.blogspot.com/2008/11/dns-prefetching-for-firefox.html)\n\n### TCP 连接\n\n**持久化连接**：避免重复进行 TCP 的三次握手，HTTP/1.1 默认开启，HTTP/1.0 可以使用。\n\nKeep-Alive 不会永久保持连接，开发者可通过服务器配置限定时间。\n\n```http\nConnection: keep-alive\n```\n\n### HTTP 请求\n\n- **减少 HTTP 请求**\n  - 通过前端构建工具合并脚本和样式表\n  - CSS Sprites 精灵图\n  - 图片使用 Base64 编码嵌入网页，减少图片外部载入的请求数\n- **资源分布式部署至不同域名**\n  - **原因**：主流浏览器对相同域名的并发 HTTP 请求数限制在 4~8 个，当资源过多时，可以采用增加域名的方法增加 HTTP 请求的并发量\n  - **原理**：利用多个不同的域名可以保证这些域名能够同时加载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不同响应域名时间不一致\n- **避免重定向**\n  - URL 末尾应该添加 `/` 但未添加\n- **消除不必要的请求字节**\n- **Cookie**\n  - 压缩 Cookie 大小\n    - 去除不必要的 Cookie\n    - 注意设置 Cookie 的 domain 级别，如没必要，不要影响子域名\n    - 设置合适的过期时间\n  - 静态资源使用无 Cookie 域名\n- [HTTP/2](https://tsejx.github.io/JavaScript-Guidebook/computer-networks/http/http2.html)\n  - 二进制分帧\n  - 多路复用\n  - 服务器推送\n  - 头部压缩\n  - 了解更多 [HTTP/2]\n- [HTTP/3](https://zh.wikipedia.org/wiki/HTTP/3)\n\n**相关链接：**\n\n- [前端性能优化 - 资源预加载](http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/)\n- [HTTP/2 简介和基于 HTTP/2 的 Web 优化](https://github.com/creeperyang/blog/issues/23)\n\n## 缓存策略\n\n制定有效的缓存策略，很大程度上能实现资源的重复利用及传输路径的优化，减少客户端对服务端的网络请求压力，减轻宽度流量。\n\n- [HTTP 缓存](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html)\n  - [强缓存](<[https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%BC%BA%E7%BC%93%E5%AD%98](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#强缓存)>)\n    - Expires 绝对时间 `Expires: Thu, 21 Jan 2017 23:59:59 GMT` 服务器和客户端时间可能不一致\n    - Cache-Control 相对时间 `Cache-Control: max-age=3600`\n  - [协商缓存](<[https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#协商缓存)>)\n    - Last-Modified / If-Modified-Since 绝对时间 `Expires: Wed, 26 Jan 2017 00:35:11 GMT` 资源上次修改的时间\n    - Etag / If-None-Match 随机生成的乱码值\n  - 优先使用强缓存\n    - 当资源文件发生变化时，通过更新页面中引用的资源路径，让浏览器放弃缓存，加载新资源\n    - 通过 [数据摘要算法](https://link.zhihu.com/?target=http%3A//baike.baidu.com/view/10961371.htm) 精准到单个文件粒度的缓存控制\n- [CDN 缓存](https://tsejx.github.io/JavaScript-Guidebook/computer-networks/cdn.html)： 将静态资源和动态网页分集群部署\n  - HTML 部署在自身的服务器上\n  - 打包后的图片 / JavaScript 脚本文件 / CSS 样式文件等资源部署到 CDN 节点上，文件带上 Hash 值\n  - 由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制\n  - CDN 没有 Cookie，使用 CDN 可以减少 Cookie\n  - CDN 会自动合并脚本文件等，减少请求数量\n  - 但是，CDN 同时也增加了域名，增大了同时请求数量\n- **服务器缓存：**将不变的数据、页面缓存到**内存**或**远程存储**（如 Redis 等）上\n- **浏览器缓存**: 通过设置请求的过期时间，将各种不常变的数据进行缓存，合理运用浏览器缓存，缩短数据的获取时间\n  - [Cookie](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/cookie.html)\n  - [WebStorage](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/web-storage.html)\n    - LocalStorage\n    - SessionStorage\n  - IndexDB\n  - [ServiceWorker](https://tsejx.github.io/JavaScript-Guidebook/html5-scripting-programming/offline-and-storage/service-worker.html)\n  - AppCache：采用 mainfest 文件进行缓存\n\n**相关链接：**\n\n- [大公司里怎样开发和部署前端代码？](https://www.zhihu.com/question/20790576)\n- [使用 SRI 增强 LocalStorage 代码安全](https://link.juejin.im/?target=https%3A%2F%2Fimququ.com%2Fpost%2Fenhance-security-for-ls-code.html)\n\n# 服务端层面\n\n由于本文只涉及前端性能优化，但为求流程完整，简单罗列与服务端相关的优化方案的常见手段。\n\n- 多域名资源加载\n- 负载均衡\n- 数据缓存\n- 反向代理\n\n# 客户端层面\n\n- 资源渲染数量/大小\n- 资源渲染路径\n- 用户体验\n\n## 资源渲染数量/大小\n\n- **压缩静态资源，清除无用代码**\n  - Tree Shaking 无用代码移除\n  - UglifyJs 混淆 / 压缩代码\n  - Code Spliting 代码分割（资源按需加载或并行加载）\n- **开启 Gzip 压缩**\n  - 请求头 `Accept-Encoding: gzip, deflate`\n  - 响应头 `Content-Encoding: gzip`\n  - Gzip 能够压缩任何文本类型的响应，包括 HTMl、XML 和 JSON\n  - 已经压缩过的内容如图片、和 PDF 不要使用 Gzip，这些资源内容本身体积就小，再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且有增加文件体积的可能\n- **多份编译文件按条件引入**\n  - 针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件\n  - 可以利用 `<script type=\"module\"> / <script type=\"module\">`进行条件引入用\n- **动态 Polyfill**\n  - 只针对不支持的浏览器运行环境引入 Polyfill\n- **图片优化**\n  - 根据业务场景，与 UI 探讨选择 **合适质量，合适尺寸**\n  - 根据需求和平台，选择 **合适格式**，例如非透明时可用 jpg；非苹果端，使用 webp\n  - 小图片合成 **雪碧图 CSS Sprite**，低于 5K 的图片可以转换成 B**ase64** 内嵌\n  - 合适场景下，使用 I**confont** 或者 **SVG**\n  - 压缩 favicon.ico 并缓存\n  - 使用 Blob 异步加载\n  - 使用 [img-2](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FRevillWeb%2Fimg-2) 代替 img 标签\n  - 嵌入资源：Base64 嵌入资源（针对小的静态图片资源）\n- **字体优化**\n  - 浏览器为了避免 FOUT（Flash Of Unstyled Text），会尽量等待字体加载完成后，再显示应用了该字体的内容。带来了 FOIT（Flash Of Invisible Text 问题），导致空白\n  - 设置多字体，降级方法：使用默认字体\n  - 异步加载字体文件：通过异步加载 CSS，即可避免字体阻塞渲染，还是会空白\n- **多媒体优化**\n  - 音视频\n\n## 资源渲染路径\n\n- **优化加载顺序**\n  - CSS 样式文件放在文档 `<head>` 标签中引入\n    - 把样式表放在 `<head>` 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉\n  - JavaScript 脚本文件放在 `<body>` 标签底部引入\n    - **原因**：加载脚本文件会对后续资源渲染造成阻塞\n    - **方案**：制定合理的脚本文件加载策略\n      - 动态脚本加载（异步加载、延迟加载、按需加载）\n      - 添加 `defer` 属性的脚本文件是在 HTML 解析完之后才会执行。如果是多个，按照加载的顺序依次执行\n      - 添加 `async` 属性的脚本文件是在加载之后立即执行，如果 HTML 还没解析完，会阻塞 HTML 继续解析。如果是多个，执行顺序和加载顺序无关\n  - 影响首屏的，优先级很高的脚本文件也可以 `<head>` 或 `<body>` 首子节点引入，甚至利用 `style` 或 `script` 内联\n- **资源加载方式**\n\n  - 非关键性的文件尽可能的**异步加载和延迟加载**，避免阻塞首页渲染\n  - **资源提示指令**\n    - Preload\n    - Prefetch\n    - Preconnect\n    - Subresource\n  - **异步加载（预加载）**\n    - 利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应\n    - 预判用户的行为，提前加载所需要的资源，则可以快速地响应用户的操作，从而打造更好的用户体验。另一方面，通过提前发起网络请求，也可以减少由于网络过慢导致的用户等待时间。\n    - Preload 规范 W3CPreload\n      - rel 明确告知浏览器启用 preload 功能\n      - as 明确需要预加载资源的类型，包括 JavaScript、Images、CSS、Media 等\n  - **延迟加载（懒加载、按需加载）**\n    - 页面初始加载时将非绝对必须的资源延迟加载，从而提高页面的加载和响应速度\n      - 非首屏使用的数据、样式、脚本、图片等\n      - 用户交互时才会显示的内容\n    - **实现方式：**\n      - 虚拟代理技术：真正加载的对象事先提供一个代理或者说占位符。最常见的场景是在图片的懒加载中，先用一种 loading 的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。\n      - 惰性初始化技术：将代码初始化的时机推迟（特别是那些初始化消耗较大的资源）\n    - **选择时机：**\n      - 滚动条监听：大型图片流场景，通过对用户滚动结束区域进行计算，从而只加载目标区域的资源，这样可以实现节流的目的\n      - 事件回调：常用于需要用户交互的地方，如点击加载更多之类的，这些资源往往通过在用户交互的瞬间（如点击一个触发按钮），发起 AJAX 请求来获取资源。比较简单，在此不再赘述。\n    - 遵循渐进增强理念理念开发网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript\n    - 将首屏以外的 HTML 放在不渲染的元素中，如隐藏的 `<textarea>`，或者 `type` 属性为非执行脚本的 `<script>` 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。\n\n- **资源渲染**\n  - 避免重排，减少重绘，避免白屏，或者交互过程中的卡顿\n  - 通过 [CSS Trigger](https://csstriggers.com/) 查询哪些样式属性会触发重排与重绘\n  - **减少重排的方法**\n    - 页面初始化\n    - 减少对 DOM 元素内容改变（如：文本改变、图片被另一个同尺寸元素替代）\n    - 减少对 DOM 元素尺寸改变（因为边距、填充、边框宽度、宽度、高度等属性改变）\n    - 减少对 DOM 元素位置改变\n    - 减少对可见 DOM 元素的操作（如：增加、移动和删除）\n      - 多次 DOM 操作合并为一次处理\n      - 大量操作时，可将 DOM 脱离文档流或者隐藏，待操作完成后再重新恢复\n    - 减少旋转屏幕的操作\n    - 减少改变浏览器窗口尺寸的操作\n    - 减少设置元素 style 属性\n    - 减少设置元素 class 属性\n    - 通过延迟访问布局信息避免重排版\n      - 如 `offsetWidth`、`offsetHeight` 和 `getComputedStyle` 等\n      - 原因：浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用\n    - 减少在 HTML 中缩放图片\n    - 避免对大部分页面进行重排版\n      - 使用绝对坐标定位页面动画的元素，使它位于页面布局流之外\n      - 启动元素动画，当它扩大时，它临时覆盖部分页面\n      - 当动画结束时，重新定位，从而只一次下移文档其他元素的位置\n    - 开启 GPU 加速\n      - transform\n      - opacity\n      - filter\n\n**相关链接：**\n\n- [前端性能优化之加载技术](https://juejin.im/post/59b73ef75188253db70acdb5#heading-5)\n- [资源提示——什么是 Preload，Prefetch 和 Preconnect？](https://juejin.im/post/5b5984b851882561da216311)\n- [preload-webpack-plugin](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FGoogleChrome%2Fpreload-webpack-plugin)\n- [Preload 技术细节](https://link.juejin.im/?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2016%2F02%2Fpreload-what-is-it-good-for%2F)\n\n## 用户体验\n\n- 谨慎控制好 Web 字体，一个大字体包足够让你功亏一篑\n  - 控制字体包的加载时机\n  - 如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积\n- 分清轻重缓急\n  - 重要的元素优先渲染\n  - 视窗内的元素优先渲染\n- 服务端渲染（SSR）\n  - 减少首屏需要的数据量，剔除冗余数据和请求\n  - 控制好缓存，对数据/页面进行合理的缓存\n  - 页面的请求使用流的形式进行传递\n- 优化用户感知\n  - 利用一些动画 **过渡效果**，能有效减少用户对卡顿的感知\n  - 尽可能利用 **骨架屏（Skeleton）/ Loading** 等减少用户对白屏的感知\n  - 动画帧数尽量保证在 **30 帧** 以上，低帧数、卡顿的动画宁愿不要\n  - JavaScript 执行时间避免超过 100ms ，超过的话就需要做：\n    - 寻找可缓存的点\n    - 任务的分割异步或 web worker 执行\n\n# 编码层面\n\n编码优化，指的就是在代码编写时的，通过一些 **最佳实践**，提升代码的执行性能。通常这并不会带来非常大的收益，但这属于**程序员的自我修养**，而且这也是面试中经常被问到的一个方面，考察自我管理与细节的处理。\n\n## JavaScript 优化\n\n- **数据读取**\n  - 通过作用域链 / 原型链读取变量或方法时，需要更多的耗时，且越长越慢\n  - 对象嵌套越深，读取值也越慢\n  - 最佳实践：\n    - 尽量在局部作用域中进行 **变量缓存**\n    - 避免嵌套过深的数据结构，**数据扁平化** 有利于数据的读取和维护\n- **循环**：循环通常是编码性能的关键点\n  - 代码的性能问题会在循环中被指数倍放大\n  - 最佳实践:\n    - 尽可能 减少循环次数；\n      - 减少遍历的数据量\n      - 完成目的后马上结束循环\n    - 避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存\n    - JavaScript 中使用 **倒序循环** 会略微提升性能\n    - 尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环\n- **条件流程性能**：Map / Object > switch > if-else\n- **模块化**：尝试使用 `import()`\n\n## DOM 优化\n\n- 减少 DOM 的层级，可以减少渲染引擎工作过程中的计算量\n- 减少访问 DOM 的次数，如需多次，将 DOM 缓存于变量中\n- 使用事件委托，避免大量的事件绑定\n- 使用 `requestAnimationFrame` 来实现视觉变化：一般来说我们会使用 `setTimeout` 或 `setInterval` 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿\n\n## CSS 优化\n\n- **层级扁平**，避免过于多层级的选择器嵌套\n- **特定的选择器**：好过一层一层查找：`.xxx-child-text{}` 优于 `.xxx .child .text{}`\n- **减少使用通配符与属性选择器**\n  - 选择器越复杂，匹配用的时间越多\n- **减少不必要的多余属性**\n- 使用 **动画属性** 实现动画，动画时脱离文档流，开启硬件加速，优先使用 CSS 动画\n- 使用 `<link>` 替代原生 @import\n- 避免使用表达式，例如 `font-color: expression((new Date()).getHours()%3?\"#FFF\":\"#AAA\")` 这个表达式会持续地在页面上计算样式，影响页面性能\n\n## HTML 优化\n\n- 写对文档类型声明 `<!DOCTYPE html>` 这能确保浏览器按照最佳的相关规范进行渲染\n- **减少 DOM 数量**，避免不必要的节点或嵌套；\n- 避免空的 `src` 和 `href`：当 `src` 和 `href` 为空时，浏览器会默认填充链接，并将页面的内容加载进来作为它们的值，具体规则如下：\n  - IE 向**页面所在的目录**发送请求\n  - Safari、Chrome、Firefox 向页面本身 URL 发送请求\n  - Opera 不执行任何操作\n- 图片提前 **指定宽高** 或者 **脱离文档流**，能有效减少因图片加载导致的页面回流\n- **语义化标签** 有利于 SEO 与浏览器的解析时间\n- 减少使用 table 进行布局，避免使用 `<br/>` 与 `<hr/>`\n\n# 参考资料\n\n**性能优化方案清单**\n\n- 🧾 [2018 前端性能优化清单](https://juejin.im/post/5a966bd16fb9a0635172a50a)\n- 🧾 [嗨，送你一张 Web 性能优化地图](https://github.com/berwin/Blog/issues/23)\n- 🧾 [Web 性能优化总结](https://segmentfault.com/a/1190000018263418?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com&share_user=1030000000178452)\n- 🧾 [大前端性能总结](https://juejin.im/post/5b025d856fb9a07aa0484e54)\n- 🧾 [CSS 性能优化的 8 个技巧](https://juejin.im/post/5b6133a351882519d346853f)\n- 🧾 [精读 《高效 JavaScript》](https://juejin.im/post/5b7e1f81f265da436a075db4)\n- 🧾 [Web 性能优化清单](https://juejin.im/post/5c011e0c5188252ea66afdfa)\n- 🗃 [性能相关基础知识点研究](https://github.com/barretlee/performance-column/milestone/1)\n- 🗃 [前端性能优化资源列表](https://github.com/liangsenzhi/awesome-wpo-chinese)\n- 🗃 [awesome-wpo](https://github.com/davidsonfellipe/awesome-wpo)\n- 🗃 [A Frontend Checklist for Websites](https://github.com/drublic/checklist)\n\n**优化方向**\n\n- 🎡 [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\n- 🎡 [16 毫秒的优化](http://velocity.oreilly.com.cn/2013/ppts/16_ms_optimization--web_front-end_performance_optimization.pdf)\n- 🎡 [Optimize JavaScript Execution 优化 JavaScript 执行](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution)\n","slug":"means-for-performance-optimization","published":1,"updated":"2021-08-18T03:31:26.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99yw0008v31p980c7ska","content":"<p>技术社区中其实已经有较多的关于前端性能优化的相关文章，看了多篇之后总是觉得内容还有很多遗漏或写得不够完美，尽管还没接手过流量特别大的网站应用项目，但是本人认为日常项目中也需要尽可能地进行性能优化的工作，因为前端工程师的工作很大程度上可以描述为“用尽量少的代价为用户提供效率尽可能高、功能尽可能多、体验尽可能好的网页应用”，而性能优化很大程度上就是实现“尽可能少的代价”、“效率尽可能高”以及“体验尽可能好”。</p>\n<p>因此，此文会根据网络请求到网页呈现的完整流程，针对性地提出相关阶段供开发决策者考虑采取的优化方案，因此本文更像是性能优化方案的决策树，而非标准方案：</p>\n<ul>\n<li>网络链路层面</li>\n<li>服务端层面</li>\n<li>客户端渲染层面</li>\n<li>编码层面</li>\n</ul>\n<p><strong>网络请求到网页呈现的大致流程</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">发送网络请求 =&gt; 网络链路 =&gt; 返回资源(服务端) =&gt; 渲染资源(客户端)</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h1 id=\"关键渲染路径\"><a href=\"#关键渲染路径\" class=\"headerlink\" title=\"关键渲染路径\"></a>关键渲染路径</h1><p>在提出各层次的优化方案之前，有必要了解一下性能优化方案实际上解决了哪些性能问题以及解决这些问题的核心归结点。</p>\n<p>以下部分关于优化关键渲染路径的建议摘录自 Google 开发者文档：<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path\" target=\"_blank\" rel=\"noopener\">📖 Optimizing the Critical Rendering Path</a></p>\n<p>为了尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p>\n<ul>\n<li>关键资源的数量</li>\n<li>关键路径长度</li>\n<li>关键字节的数量</li>\n</ul>\n<p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。</p>\n<p>同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。</p>\n<p>最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>\n<p><strong>优化关键渲染路径的常规步骤如下：</strong></p>\n<ol>\n<li>对关键路径进行分析和特性描述：资源数、字节数、长度</li>\n<li>最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等</li>\n<li>优化关键字节数以缩短下载时间（往返次数）</li>\n<li>优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</li>\n</ol>\n<h1 id=\"网络链路层面\"><a href=\"#网络链路层面\" class=\"headerlink\" title=\"网络链路层面\"></a>网络链路层面</h1><p>网络链路作为网络资源和数据的传输通道，充分利用网络技术手段能有效地减少网页资源响应的速度、提升网页资源传输速度以及避免重复传输导致的资源浪费等问题。</p>\n<h2 id=\"传输策略\"><a href=\"#传输策略\" class=\"headerlink\" title=\"传输策略\"></a>传输策略</h2><h3 id=\"DNS-查询\"><a href=\"#DNS-查询\" class=\"headerlink\" title=\"DNS 查询\"></a>DNS 查询</h3><p>DNS 域名解析协议简单来就说负责将域名 URL 转化为服务器主机 IP。了解更多 <a href=\"https://tsejx.github.io/JavaScript-Guidebook/computer-networks/dns.html\">DNS 域名解析协议</a></p>\n<p>DNS 查询能从两方面进行优化：</p>\n<ul>\n<li><strong>减少 DNS 查询次数</strong></li>\n<li><strong>DNS 预解析</strong></li>\n</ul>\n<p>通过在文档中使用值为 <code>http-equiv</code> 的 <code>&lt;meta&gt;</code> 标签打开 DNS 预解析：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"x-dns-prefetch-control\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"on\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>通过 <code>rel</code> 属性值为 <code>dns-prefetch</code> 的 <code>&lt;link&gt;</code> 标签对特定域名进行预读取</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">'dns-prefetch\" href=\"//host_name_to_prefetch.com\"/&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>相关链接：</strong></p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching\" target=\"_blank\" rel=\"noopener\">MDN：X-DNS-Prefetch-Control</a></li>\n<li><a href=\"https://dev.chromium.org/developers/design-documents/dns-prefetching\" target=\"_blank\" rel=\"noopener\">DNS Prefetching</a></li>\n<li><a href=\"https://bitsup.blogspot.com/2008/11/dns-prefetching-for-firefox.html\" target=\"_blank\" rel=\"noopener\">DNS Prefetching for Firefox</a></li>\n</ul>\n<h3 id=\"TCP-连接\"><a href=\"#TCP-连接\" class=\"headerlink\" title=\"TCP 连接\"></a>TCP 连接</h3><p><strong>持久化连接</strong>：避免重复进行 TCP 的三次握手，HTTP/1.1 默认开启，HTTP/1.0 可以使用。</p>\n<p>Keep-Alive 不会永久保持连接，开发者可通过服务器配置限定时间。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure>\n<h3 id=\"HTTP-请求\"><a href=\"#HTTP-请求\" class=\"headerlink\" title=\"HTTP 请求\"></a>HTTP 请求</h3><ul>\n<li><strong>减少 HTTP 请求</strong><ul>\n<li>通过前端构建工具合并脚本和样式表</li>\n<li>CSS Sprites 精灵图</li>\n<li>图片使用 Base64 编码嵌入网页，减少图片外部载入的请求数</li>\n</ul>\n</li>\n<li><strong>资源分布式部署至不同域名</strong><ul>\n<li><strong>原因</strong>：主流浏览器对相同域名的并发 HTTP 请求数限制在 4~8 个，当资源过多时，可以采用增加域名的方法增加 HTTP 请求的并发量</li>\n<li><strong>原理</strong>：利用多个不同的域名可以保证这些域名能够同时加载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不同响应域名时间不一致</li>\n</ul>\n</li>\n<li><strong>避免重定向</strong><ul>\n<li>URL 末尾应该添加 <code>/</code> 但未添加</li>\n</ul>\n</li>\n<li><strong>消除不必要的请求字节</strong></li>\n<li><strong>Cookie</strong><ul>\n<li>压缩 Cookie 大小<ul>\n<li>去除不必要的 Cookie</li>\n<li>注意设置 Cookie 的 domain 级别，如没必要，不要影响子域名</li>\n<li>设置合适的过期时间</li>\n</ul>\n</li>\n<li>静态资源使用无 Cookie 域名</li>\n</ul>\n</li>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/computer-networks/http/http2.html\">HTTP/2</a><ul>\n<li>二进制分帧</li>\n<li>多路复用</li>\n<li>服务器推送</li>\n<li>头部压缩</li>\n<li>了解更多 [HTTP/2]</li>\n</ul>\n</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/HTTP/3\" target=\"_blank\" rel=\"noopener\">HTTP/3</a></li>\n</ul>\n<p><strong>相关链接：</strong></p>\n<ul>\n<li><a href=\"http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/\" target=\"_blank\" rel=\"noopener\">前端性能优化 - 资源预加载</a></li>\n<li><a href=\"https://github.com/creeperyang/blog/issues/23\" target=\"_blank\" rel=\"noopener\">HTTP/2 简介和基于 HTTP/2 的 Web 优化</a></li>\n</ul>\n<h2 id=\"缓存策略\"><a href=\"#缓存策略\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h2><p>制定有效的缓存策略，很大程度上能实现资源的重复利用及传输路径的优化，减少客户端对服务端的网络请求压力，减轻宽度流量。</p>\n<ul>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html\">HTTP 缓存</a><ul>\n<li><a href=\"[https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%BC%BA%E7%BC%93%E5%AD%98](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#强缓存\">强缓存</a>&gt;)<ul>\n<li>Expires 绝对时间 <code>Expires: Thu, 21 Jan 2017 23:59:59 GMT</code> 服务器和客户端时间可能不一致</li>\n<li>Cache-Control 相对时间 <code>Cache-Control: max-age=3600</code></li>\n</ul>\n</li>\n<li><a href=\"[https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#协商缓存\">协商缓存</a>&gt;)<ul>\n<li>Last-Modified / If-Modified-Since 绝对时间 <code>Expires: Wed, 26 Jan 2017 00:35:11 GMT</code> 资源上次修改的时间</li>\n<li>Etag / If-None-Match 随机生成的乱码值</li>\n</ul>\n</li>\n<li>优先使用强缓存<ul>\n<li>当资源文件发生变化时，通过更新页面中引用的资源路径，让浏览器放弃缓存，加载新资源</li>\n<li>通过 <a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/view/10961371.htm\" target=\"_blank\" rel=\"noopener\">数据摘要算法</a> 精准到单个文件粒度的缓存控制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/computer-networks/cdn.html\">CDN 缓存</a>： 将静态资源和动态网页分集群部署<ul>\n<li>HTML 部署在自身的服务器上</li>\n<li>打包后的图片 / JavaScript 脚本文件 / CSS 样式文件等资源部署到 CDN 节点上，文件带上 Hash 值</li>\n<li>由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制</li>\n<li>CDN 没有 Cookie，使用 CDN 可以减少 Cookie</li>\n<li>CDN 会自动合并脚本文件等，减少请求数量</li>\n<li>但是，CDN 同时也增加了域名，增大了同时请求数量</li>\n</ul>\n</li>\n<li><strong>服务器缓存：</strong>将不变的数据、页面缓存到<strong>内存</strong>或<strong>远程存储</strong>（如 Redis 等）上</li>\n<li><strong>浏览器缓存</strong>: 通过设置请求的过期时间，将各种不常变的数据进行缓存，合理运用浏览器缓存，缩短数据的获取时间<ul>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/cookie.html\">Cookie</a></li>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/web-storage.html\">WebStorage</a><ul>\n<li>LocalStorage</li>\n<li>SessionStorage</li>\n</ul>\n</li>\n<li>IndexDB</li>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/html5-scripting-programming/offline-and-storage/service-worker.html\">ServiceWorker</a></li>\n<li>AppCache：采用 mainfest 文件进行缓存</li>\n</ul>\n</li>\n</ul>\n<p><strong>相关链接：</strong></p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/20790576\" target=\"_blank\" rel=\"noopener\">大公司里怎样开发和部署前端代码？</a></li>\n<li><a href=\"https://link.juejin.im/?target=https%3A%2F%2Fimququ.com%2Fpost%2Fenhance-security-for-ls-code.html\" target=\"_blank\" rel=\"noopener\">使用 SRI 增强 LocalStorage 代码安全</a></li>\n</ul>\n<h1 id=\"服务端层面\"><a href=\"#服务端层面\" class=\"headerlink\" title=\"服务端层面\"></a>服务端层面</h1><p>由于本文只涉及前端性能优化，但为求流程完整，简单罗列与服务端相关的优化方案的常见手段。</p>\n<ul>\n<li>多域名资源加载</li>\n<li>负载均衡</li>\n<li>数据缓存</li>\n<li>反向代理</li>\n</ul>\n<h1 id=\"客户端层面\"><a href=\"#客户端层面\" class=\"headerlink\" title=\"客户端层面\"></a>客户端层面</h1><ul>\n<li>资源渲染数量/大小</li>\n<li>资源渲染路径</li>\n<li>用户体验</li>\n</ul>\n<h2 id=\"资源渲染数量-大小\"><a href=\"#资源渲染数量-大小\" class=\"headerlink\" title=\"资源渲染数量/大小\"></a>资源渲染数量/大小</h2><ul>\n<li><strong>压缩静态资源，清除无用代码</strong><ul>\n<li>Tree Shaking 无用代码移除</li>\n<li>UglifyJs 混淆 / 压缩代码</li>\n<li>Code Spliting 代码分割（资源按需加载或并行加载）</li>\n</ul>\n</li>\n<li><strong>开启 Gzip 压缩</strong><ul>\n<li>请求头 <code>Accept-Encoding: gzip, deflate</code></li>\n<li>响应头 <code>Content-Encoding: gzip</code></li>\n<li>Gzip 能够压缩任何文本类型的响应，包括 HTMl、XML 和 JSON</li>\n<li>已经压缩过的内容如图片、和 PDF 不要使用 Gzip，这些资源内容本身体积就小，再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且有增加文件体积的可能</li>\n</ul>\n</li>\n<li><strong>多份编译文件按条件引入</strong><ul>\n<li>针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件</li>\n<li>可以利用 <code>&lt;script type=&quot;module&quot;&gt; / &lt;script type=&quot;module&quot;&gt;</code>进行条件引入用</li>\n</ul>\n</li>\n<li><strong>动态 Polyfill</strong><ul>\n<li>只针对不支持的浏览器运行环境引入 Polyfill</li>\n</ul>\n</li>\n<li><strong>图片优化</strong><ul>\n<li>根据业务场景，与 UI 探讨选择 <strong>合适质量，合适尺寸</strong></li>\n<li>根据需求和平台，选择 <strong>合适格式</strong>，例如非透明时可用 jpg；非苹果端，使用 webp</li>\n<li>小图片合成 <strong>雪碧图 CSS Sprite</strong>，低于 5K 的图片可以转换成 B<strong>ase64</strong> 内嵌</li>\n<li>合适场景下，使用 I<strong>confont</strong> 或者 <strong>SVG</strong></li>\n<li>压缩 favicon.ico 并缓存</li>\n<li>使用 Blob 异步加载</li>\n<li>使用 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FRevillWeb%2Fimg-2\" target=\"_blank\" rel=\"noopener\">img-2</a> 代替 img 标签</li>\n<li>嵌入资源：Base64 嵌入资源（针对小的静态图片资源）</li>\n</ul>\n</li>\n<li><strong>字体优化</strong><ul>\n<li>浏览器为了避免 FOUT（Flash Of Unstyled Text），会尽量等待字体加载完成后，再显示应用了该字体的内容。带来了 FOIT（Flash Of Invisible Text 问题），导致空白</li>\n<li>设置多字体，降级方法：使用默认字体</li>\n<li>异步加载字体文件：通过异步加载 CSS，即可避免字体阻塞渲染，还是会空白</li>\n</ul>\n</li>\n<li><strong>多媒体优化</strong><ul>\n<li>音视频</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"资源渲染路径\"><a href=\"#资源渲染路径\" class=\"headerlink\" title=\"资源渲染路径\"></a>资源渲染路径</h2><ul>\n<li><strong>优化加载顺序</strong><ul>\n<li>CSS 样式文件放在文档 <code>&lt;head&gt;</code> 标签中引入<ul>\n<li>把样式表放在 <code>&lt;head&gt;</code> 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉</li>\n</ul>\n</li>\n<li>JavaScript 脚本文件放在 <code>&lt;body&gt;</code> 标签底部引入<ul>\n<li><strong>原因</strong>：加载脚本文件会对后续资源渲染造成阻塞</li>\n<li><strong>方案</strong>：制定合理的脚本文件加载策略<ul>\n<li>动态脚本加载（异步加载、延迟加载、按需加载）</li>\n<li>添加 <code>defer</code> 属性的脚本文件是在 HTML 解析完之后才会执行。如果是多个，按照加载的顺序依次执行</li>\n<li>添加 <code>async</code> 属性的脚本文件是在加载之后立即执行，如果 HTML 还没解析完，会阻塞 HTML 继续解析。如果是多个，执行顺序和加载顺序无关</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>影响首屏的，优先级很高的脚本文件也可以 <code>&lt;head&gt;</code> 或 <code>&lt;body&gt;</code> 首子节点引入，甚至利用 <code>style</code> 或 <code>script</code> 内联</li>\n</ul>\n</li>\n<li><p><strong>资源加载方式</strong></p>\n<ul>\n<li>非关键性的文件尽可能的<strong>异步加载和延迟加载</strong>，避免阻塞首页渲染</li>\n<li><strong>资源提示指令</strong><ul>\n<li>Preload</li>\n<li>Prefetch</li>\n<li>Preconnect</li>\n<li>Subresource</li>\n</ul>\n</li>\n<li><strong>异步加载（预加载）</strong><ul>\n<li>利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应</li>\n<li>预判用户的行为，提前加载所需要的资源，则可以快速地响应用户的操作，从而打造更好的用户体验。另一方面，通过提前发起网络请求，也可以减少由于网络过慢导致的用户等待时间。</li>\n<li>Preload 规范 W3CPreload<ul>\n<li>rel 明确告知浏览器启用 preload 功能</li>\n<li>as 明确需要预加载资源的类型，包括 JavaScript、Images、CSS、Media 等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>延迟加载（懒加载、按需加载）</strong><ul>\n<li>页面初始加载时将非绝对必须的资源延迟加载，从而提高页面的加载和响应速度<ul>\n<li>非首屏使用的数据、样式、脚本、图片等</li>\n<li>用户交互时才会显示的内容</li>\n</ul>\n</li>\n<li><strong>实现方式：</strong><ul>\n<li>虚拟代理技术：真正加载的对象事先提供一个代理或者说占位符。最常见的场景是在图片的懒加载中，先用一种 loading 的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。</li>\n<li>惰性初始化技术：将代码初始化的时机推迟（特别是那些初始化消耗较大的资源）</li>\n</ul>\n</li>\n<li><strong>选择时机：</strong><ul>\n<li>滚动条监听：大型图片流场景，通过对用户滚动结束区域进行计算，从而只加载目标区域的资源，这样可以实现节流的目的</li>\n<li>事件回调：常用于需要用户交互的地方，如点击加载更多之类的，这些资源往往通过在用户交互的瞬间（如点击一个触发按钮），发起 AJAX 请求来获取资源。比较简单，在此不再赘述。</li>\n</ul>\n</li>\n<li>遵循渐进增强理念理念开发网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript</li>\n<li>将首屏以外的 HTML 放在不渲染的元素中，如隐藏的 <code>&lt;textarea&gt;</code>，或者 <code>type</code> 属性为非执行脚本的 <code>&lt;script&gt;</code> 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>资源渲染</strong></p>\n<ul>\n<li>避免重排，减少重绘，避免白屏，或者交互过程中的卡顿</li>\n<li>通过 <a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"noopener\">CSS Trigger</a> 查询哪些样式属性会触发重排与重绘</li>\n<li><strong>减少重排的方法</strong><ul>\n<li>页面初始化</li>\n<li>减少对 DOM 元素内容改变（如：文本改变、图片被另一个同尺寸元素替代）</li>\n<li>减少对 DOM 元素尺寸改变（因为边距、填充、边框宽度、宽度、高度等属性改变）</li>\n<li>减少对 DOM 元素位置改变</li>\n<li>减少对可见 DOM 元素的操作（如：增加、移动和删除）<ul>\n<li>多次 DOM 操作合并为一次处理</li>\n<li>大量操作时，可将 DOM 脱离文档流或者隐藏，待操作完成后再重新恢复</li>\n</ul>\n</li>\n<li>减少旋转屏幕的操作</li>\n<li>减少改变浏览器窗口尺寸的操作</li>\n<li>减少设置元素 style 属性</li>\n<li>减少设置元素 class 属性</li>\n<li>通过延迟访问布局信息避免重排版<ul>\n<li>如 <code>offsetWidth</code>、<code>offsetHeight</code> 和 <code>getComputedStyle</code> 等</li>\n<li>原因：浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用</li>\n</ul>\n</li>\n<li>减少在 HTML 中缩放图片</li>\n<li>避免对大部分页面进行重排版<ul>\n<li>使用绝对坐标定位页面动画的元素，使它位于页面布局流之外</li>\n<li>启动元素动画，当它扩大时，它临时覆盖部分页面</li>\n<li>当动画结束时，重新定位，从而只一次下移文档其他元素的位置</li>\n</ul>\n</li>\n<li>开启 GPU 加速<ul>\n<li>transform</li>\n<li>opacity</li>\n<li>filter</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>相关链接：</strong></p>\n<ul>\n<li><a href=\"https://juejin.im/post/59b73ef75188253db70acdb5#heading-5\" target=\"_blank\" rel=\"noopener\">前端性能优化之加载技术</a></li>\n<li><a href=\"https://juejin.im/post/5b5984b851882561da216311\" target=\"_blank\" rel=\"noopener\">资源提示——什么是 Preload，Prefetch 和 Preconnect？</a></li>\n<li><a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FGoogleChrome%2Fpreload-webpack-plugin\" target=\"_blank\" rel=\"noopener\">preload-webpack-plugin</a></li>\n<li><a href=\"https://link.juejin.im/?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2016%2F02%2Fpreload-what-is-it-good-for%2F\" target=\"_blank\" rel=\"noopener\">Preload 技术细节</a></li>\n</ul>\n<h2 id=\"用户体验\"><a href=\"#用户体验\" class=\"headerlink\" title=\"用户体验\"></a>用户体验</h2><ul>\n<li>谨慎控制好 Web 字体，一个大字体包足够让你功亏一篑<ul>\n<li>控制字体包的加载时机</li>\n<li>如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积</li>\n</ul>\n</li>\n<li>分清轻重缓急<ul>\n<li>重要的元素优先渲染</li>\n<li>视窗内的元素优先渲染</li>\n</ul>\n</li>\n<li>服务端渲染（SSR）<ul>\n<li>减少首屏需要的数据量，剔除冗余数据和请求</li>\n<li>控制好缓存，对数据/页面进行合理的缓存</li>\n<li>页面的请求使用流的形式进行传递</li>\n</ul>\n</li>\n<li>优化用户感知<ul>\n<li>利用一些动画 <strong>过渡效果</strong>，能有效减少用户对卡顿的感知</li>\n<li>尽可能利用 <strong>骨架屏（Skeleton）/ Loading</strong> 等减少用户对白屏的感知</li>\n<li>动画帧数尽量保证在 <strong>30 帧</strong> 以上，低帧数、卡顿的动画宁愿不要</li>\n<li>JavaScript 执行时间避免超过 100ms ，超过的话就需要做：<ul>\n<li>寻找可缓存的点</li>\n<li>任务的分割异步或 web worker 执行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"编码层面\"><a href=\"#编码层面\" class=\"headerlink\" title=\"编码层面\"></a>编码层面</h1><p>编码优化，指的就是在代码编写时的，通过一些 <strong>最佳实践</strong>，提升代码的执行性能。通常这并不会带来非常大的收益，但这属于<strong>程序员的自我修养</strong>，而且这也是面试中经常被问到的一个方面，考察自我管理与细节的处理。</p>\n<h2 id=\"JavaScript-优化\"><a href=\"#JavaScript-优化\" class=\"headerlink\" title=\"JavaScript 优化\"></a>JavaScript 优化</h2><ul>\n<li><strong>数据读取</strong><ul>\n<li>通过作用域链 / 原型链读取变量或方法时，需要更多的耗时，且越长越慢</li>\n<li>对象嵌套越深，读取值也越慢</li>\n<li>最佳实践：<ul>\n<li>尽量在局部作用域中进行 <strong>变量缓存</strong></li>\n<li>避免嵌套过深的数据结构，<strong>数据扁平化</strong> 有利于数据的读取和维护</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>循环</strong>：循环通常是编码性能的关键点<ul>\n<li>代码的性能问题会在循环中被指数倍放大</li>\n<li>最佳实践:<ul>\n<li>尽可能 减少循环次数；<ul>\n<li>减少遍历的数据量</li>\n<li>完成目的后马上结束循环</li>\n</ul>\n</li>\n<li>避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存</li>\n<li>JavaScript 中使用 <strong>倒序循环</strong> 会略微提升性能</li>\n<li>尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>条件流程性能</strong>：Map / Object &gt; switch &gt; if-else</li>\n<li><strong>模块化</strong>：尝试使用 <code>import()</code></li>\n</ul>\n<h2 id=\"DOM-优化\"><a href=\"#DOM-优化\" class=\"headerlink\" title=\"DOM 优化\"></a>DOM 优化</h2><ul>\n<li>减少 DOM 的层级，可以减少渲染引擎工作过程中的计算量</li>\n<li>减少访问 DOM 的次数，如需多次，将 DOM 缓存于变量中</li>\n<li>使用事件委托，避免大量的事件绑定</li>\n<li>使用 <code>requestAnimationFrame</code> 来实现视觉变化：一般来说我们会使用 <code>setTimeout</code> 或 <code>setInterval</code> 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿</li>\n</ul>\n<h2 id=\"CSS-优化\"><a href=\"#CSS-优化\" class=\"headerlink\" title=\"CSS 优化\"></a>CSS 优化</h2><ul>\n<li><strong>层级扁平</strong>，避免过于多层级的选择器嵌套</li>\n<li><strong>特定的选择器</strong>：好过一层一层查找：<code>.xxx-child-text{}</code> 优于 <code>.xxx .child .text{}</code></li>\n<li><strong>减少使用通配符与属性选择器</strong><ul>\n<li>选择器越复杂，匹配用的时间越多</li>\n</ul>\n</li>\n<li><strong>减少不必要的多余属性</strong></li>\n<li>使用 <strong>动画属性</strong> 实现动画，动画时脱离文档流，开启硬件加速，优先使用 CSS 动画</li>\n<li>使用 <code>&lt;link&gt;</code> 替代原生 @import</li>\n<li>避免使用表达式，例如 <code>font-color: expression((new Date()).getHours()%3?&quot;#FFF&quot;:&quot;#AAA&quot;)</code> 这个表达式会持续地在页面上计算样式，影响页面性能</li>\n</ul>\n<h2 id=\"HTML-优化\"><a href=\"#HTML-优化\" class=\"headerlink\" title=\"HTML 优化\"></a>HTML 优化</h2><ul>\n<li>写对文档类型声明 <code>&lt;!DOCTYPE html&gt;</code> 这能确保浏览器按照最佳的相关规范进行渲染</li>\n<li><strong>减少 DOM 数量</strong>，避免不必要的节点或嵌套；</li>\n<li>避免空的 <code>src</code> 和 <code>href</code>：当 <code>src</code> 和 <code>href</code> 为空时，浏览器会默认填充链接，并将页面的内容加载进来作为它们的值，具体规则如下：<ul>\n<li>IE 向<strong>页面所在的目录</strong>发送请求</li>\n<li>Safari、Chrome、Firefox 向页面本身 URL 发送请求</li>\n<li>Opera 不执行任何操作</li>\n</ul>\n</li>\n<li>图片提前 <strong>指定宽高</strong> 或者 <strong>脱离文档流</strong>，能有效减少因图片加载导致的页面回流</li>\n<li><strong>语义化标签</strong> 有利于 SEO 与浏览器的解析时间</li>\n<li>减少使用 table 进行布局，避免使用 <code>&lt;br/&gt;</code> 与 <code>&lt;hr/&gt;</code></li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>性能优化方案清单</strong></p>\n<ul>\n<li>🧾 <a href=\"https://juejin.im/post/5a966bd16fb9a0635172a50a\" target=\"_blank\" rel=\"noopener\">2018 前端性能优化清单</a></li>\n<li>🧾 <a href=\"https://github.com/berwin/Blog/issues/23\" target=\"_blank\" rel=\"noopener\">嗨，送你一张 Web 性能优化地图</a></li>\n<li>🧾 <a href=\"https://segmentfault.com/a/1190000018263418?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com&amp;share_user=1030000000178452\" target=\"_blank\" rel=\"noopener\">Web 性能优化总结</a></li>\n<li>🧾 <a href=\"https://juejin.im/post/5b025d856fb9a07aa0484e54\" target=\"_blank\" rel=\"noopener\">大前端性能总结</a></li>\n<li>🧾 <a href=\"https://juejin.im/post/5b6133a351882519d346853f\" target=\"_blank\" rel=\"noopener\">CSS 性能优化的 8 个技巧</a></li>\n<li>🧾 <a href=\"https://juejin.im/post/5b7e1f81f265da436a075db4\" target=\"_blank\" rel=\"noopener\">精读 《高效 JavaScript》</a></li>\n<li>🧾 <a href=\"https://juejin.im/post/5c011e0c5188252ea66afdfa\" target=\"_blank\" rel=\"noopener\">Web 性能优化清单</a></li>\n<li>🗃 <a href=\"https://github.com/barretlee/performance-column/milestone/1\" target=\"_blank\" rel=\"noopener\">性能相关基础知识点研究</a></li>\n<li>🗃 <a href=\"https://github.com/liangsenzhi/awesome-wpo-chinese\" target=\"_blank\" rel=\"noopener\">前端性能优化资源列表</a></li>\n<li>🗃 <a href=\"https://github.com/davidsonfellipe/awesome-wpo\" target=\"_blank\" rel=\"noopener\">awesome-wpo</a></li>\n<li>🗃 <a href=\"https://github.com/drublic/checklist\" target=\"_blank\" rel=\"noopener\">A Frontend Checklist for Websites</a></li>\n</ul>\n<p><strong>优化方向</strong></p>\n<ul>\n<li>🎡 <a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\" target=\"_blank\" rel=\"noopener\">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>\n<li>🎡 <a href=\"http://velocity.oreilly.com.cn/2013/ppts/16_ms_optimization--web_front-end_performance_optimization.pdf\" target=\"_blank\" rel=\"noopener\">16 毫秒的优化</a></li>\n<li>🎡 <a href=\"https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution\" target=\"_blank\" rel=\"noopener\">Optimize JavaScript Execution 优化 JavaScript 执行</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>技术社区中其实已经有较多的关于前端性能优化的相关文章，看了多篇之后总是觉得内容还有很多遗漏或写得不够完美，尽管还没接手过流量特别大的网站应用项目，但是本人认为日常项目中也需要尽可能地进行性能优化的工作，因为前端工程师的工作很大程度上可以描述为“用尽量少的代价为用户提供效率尽可能高、功能尽可能多、体验尽可能好的网页应用”，而性能优化很大程度上就是实现“尽可能少的代价”、“效率尽可能高”以及“体验尽可能好”。</p>\n<p>因此，此文会根据网络请求到网页呈现的完整流程，针对性地提出相关阶段供开发决策者考虑采取的优化方案，因此本文更像是性能优化方案的决策树，而非标准方案：</p>\n<ul>\n<li>网络链路层面</li>\n<li>服务端层面</li>\n<li>客户端渲染层面</li>\n<li>编码层面</li>\n</ul>\n<p><strong>网络请求到网页呈现的大致流程</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">发送网络请求 =&gt; 网络链路 =&gt; 返回资源(服务端) =&gt; 渲染资源(客户端)</span><br></pre></td></tr></table></figure>","more":"<h1 id=\"关键渲染路径\"><a href=\"#关键渲染路径\" class=\"headerlink\" title=\"关键渲染路径\"></a>关键渲染路径</h1><p>在提出各层次的优化方案之前，有必要了解一下性能优化方案实际上解决了哪些性能问题以及解决这些问题的核心归结点。</p>\n<p>以下部分关于优化关键渲染路径的建议摘录自 Google 开发者文档：<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path\" target=\"_blank\" rel=\"noopener\">📖 Optimizing the Critical Rendering Path</a></p>\n<p>为了尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p>\n<ul>\n<li>关键资源的数量</li>\n<li>关键路径长度</li>\n<li>关键字节的数量</li>\n</ul>\n<p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。</p>\n<p>同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。</p>\n<p>最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>\n<p><strong>优化关键渲染路径的常规步骤如下：</strong></p>\n<ol>\n<li>对关键路径进行分析和特性描述：资源数、字节数、长度</li>\n<li>最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等</li>\n<li>优化关键字节数以缩短下载时间（往返次数）</li>\n<li>优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</li>\n</ol>\n<h1 id=\"网络链路层面\"><a href=\"#网络链路层面\" class=\"headerlink\" title=\"网络链路层面\"></a>网络链路层面</h1><p>网络链路作为网络资源和数据的传输通道，充分利用网络技术手段能有效地减少网页资源响应的速度、提升网页资源传输速度以及避免重复传输导致的资源浪费等问题。</p>\n<h2 id=\"传输策略\"><a href=\"#传输策略\" class=\"headerlink\" title=\"传输策略\"></a>传输策略</h2><h3 id=\"DNS-查询\"><a href=\"#DNS-查询\" class=\"headerlink\" title=\"DNS 查询\"></a>DNS 查询</h3><p>DNS 域名解析协议简单来就说负责将域名 URL 转化为服务器主机 IP。了解更多 <a href=\"https://tsejx.github.io/JavaScript-Guidebook/computer-networks/dns.html\">DNS 域名解析协议</a></p>\n<p>DNS 查询能从两方面进行优化：</p>\n<ul>\n<li><strong>减少 DNS 查询次数</strong></li>\n<li><strong>DNS 预解析</strong></li>\n</ul>\n<p>通过在文档中使用值为 <code>http-equiv</code> 的 <code>&lt;meta&gt;</code> 标签打开 DNS 预解析：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"x-dns-prefetch-control\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"on\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>通过 <code>rel</code> 属性值为 <code>dns-prefetch</code> 的 <code>&lt;link&gt;</code> 标签对特定域名进行预读取</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">'dns-prefetch\" href=\"//host_name_to_prefetch.com\"/&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>相关链接：</strong></p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching\" target=\"_blank\" rel=\"noopener\">MDN：X-DNS-Prefetch-Control</a></li>\n<li><a href=\"https://dev.chromium.org/developers/design-documents/dns-prefetching\" target=\"_blank\" rel=\"noopener\">DNS Prefetching</a></li>\n<li><a href=\"https://bitsup.blogspot.com/2008/11/dns-prefetching-for-firefox.html\" target=\"_blank\" rel=\"noopener\">DNS Prefetching for Firefox</a></li>\n</ul>\n<h3 id=\"TCP-连接\"><a href=\"#TCP-连接\" class=\"headerlink\" title=\"TCP 连接\"></a>TCP 连接</h3><p><strong>持久化连接</strong>：避免重复进行 TCP 的三次握手，HTTP/1.1 默认开启，HTTP/1.0 可以使用。</p>\n<p>Keep-Alive 不会永久保持连接，开发者可通过服务器配置限定时间。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure>\n<h3 id=\"HTTP-请求\"><a href=\"#HTTP-请求\" class=\"headerlink\" title=\"HTTP 请求\"></a>HTTP 请求</h3><ul>\n<li><strong>减少 HTTP 请求</strong><ul>\n<li>通过前端构建工具合并脚本和样式表</li>\n<li>CSS Sprites 精灵图</li>\n<li>图片使用 Base64 编码嵌入网页，减少图片外部载入的请求数</li>\n</ul>\n</li>\n<li><strong>资源分布式部署至不同域名</strong><ul>\n<li><strong>原因</strong>：主流浏览器对相同域名的并发 HTTP 请求数限制在 4~8 个，当资源过多时，可以采用增加域名的方法增加 HTTP 请求的并发量</li>\n<li><strong>原理</strong>：利用多个不同的域名可以保证这些域名能够同时加载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不同响应域名时间不一致</li>\n</ul>\n</li>\n<li><strong>避免重定向</strong><ul>\n<li>URL 末尾应该添加 <code>/</code> 但未添加</li>\n</ul>\n</li>\n<li><strong>消除不必要的请求字节</strong></li>\n<li><strong>Cookie</strong><ul>\n<li>压缩 Cookie 大小<ul>\n<li>去除不必要的 Cookie</li>\n<li>注意设置 Cookie 的 domain 级别，如没必要，不要影响子域名</li>\n<li>设置合适的过期时间</li>\n</ul>\n</li>\n<li>静态资源使用无 Cookie 域名</li>\n</ul>\n</li>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/computer-networks/http/http2.html\">HTTP/2</a><ul>\n<li>二进制分帧</li>\n<li>多路复用</li>\n<li>服务器推送</li>\n<li>头部压缩</li>\n<li>了解更多 [HTTP/2]</li>\n</ul>\n</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/HTTP/3\" target=\"_blank\" rel=\"noopener\">HTTP/3</a></li>\n</ul>\n<p><strong>相关链接：</strong></p>\n<ul>\n<li><a href=\"http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/\" target=\"_blank\" rel=\"noopener\">前端性能优化 - 资源预加载</a></li>\n<li><a href=\"https://github.com/creeperyang/blog/issues/23\" target=\"_blank\" rel=\"noopener\">HTTP/2 简介和基于 HTTP/2 的 Web 优化</a></li>\n</ul>\n<h2 id=\"缓存策略\"><a href=\"#缓存策略\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h2><p>制定有效的缓存策略，很大程度上能实现资源的重复利用及传输路径的优化，减少客户端对服务端的网络请求压力，减轻宽度流量。</p>\n<ul>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html\">HTTP 缓存</a><ul>\n<li><a href=\"[https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%BC%BA%E7%BC%93%E5%AD%98](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#强缓存\">强缓存</a>&gt;)<ul>\n<li>Expires 绝对时间 <code>Expires: Thu, 21 Jan 2017 23:59:59 GMT</code> 服务器和客户端时间可能不一致</li>\n<li>Cache-Control 相对时间 <code>Cache-Control: max-age=3600</code></li>\n</ul>\n</li>\n<li><a href=\"[https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98](https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/http-cache.html#协商缓存\">协商缓存</a>&gt;)<ul>\n<li>Last-Modified / If-Modified-Since 绝对时间 <code>Expires: Wed, 26 Jan 2017 00:35:11 GMT</code> 资源上次修改的时间</li>\n<li>Etag / If-None-Match 随机生成的乱码值</li>\n</ul>\n</li>\n<li>优先使用强缓存<ul>\n<li>当资源文件发生变化时，通过更新页面中引用的资源路径，让浏览器放弃缓存，加载新资源</li>\n<li>通过 <a href=\"https://link.zhihu.com/?target=http%3A//baike.baidu.com/view/10961371.htm\" target=\"_blank\" rel=\"noopener\">数据摘要算法</a> 精准到单个文件粒度的缓存控制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/computer-networks/cdn.html\">CDN 缓存</a>： 将静态资源和动态网页分集群部署<ul>\n<li>HTML 部署在自身的服务器上</li>\n<li>打包后的图片 / JavaScript 脚本文件 / CSS 样式文件等资源部署到 CDN 节点上，文件带上 Hash 值</li>\n<li>由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制</li>\n<li>CDN 没有 Cookie，使用 CDN 可以减少 Cookie</li>\n<li>CDN 会自动合并脚本文件等，减少请求数量</li>\n<li>但是，CDN 同时也增加了域名，增大了同时请求数量</li>\n</ul>\n</li>\n<li><strong>服务器缓存：</strong>将不变的数据、页面缓存到<strong>内存</strong>或<strong>远程存储</strong>（如 Redis 等）上</li>\n<li><strong>浏览器缓存</strong>: 通过设置请求的过期时间，将各种不常变的数据进行缓存，合理运用浏览器缓存，缩短数据的获取时间<ul>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/cookie.html\">Cookie</a></li>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/browser-object-model/browser-cache/web-storage.html\">WebStorage</a><ul>\n<li>LocalStorage</li>\n<li>SessionStorage</li>\n</ul>\n</li>\n<li>IndexDB</li>\n<li><a href=\"https://tsejx.github.io/JavaScript-Guidebook/html5-scripting-programming/offline-and-storage/service-worker.html\">ServiceWorker</a></li>\n<li>AppCache：采用 mainfest 文件进行缓存</li>\n</ul>\n</li>\n</ul>\n<p><strong>相关链接：</strong></p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/20790576\" target=\"_blank\" rel=\"noopener\">大公司里怎样开发和部署前端代码？</a></li>\n<li><a href=\"https://link.juejin.im/?target=https%3A%2F%2Fimququ.com%2Fpost%2Fenhance-security-for-ls-code.html\" target=\"_blank\" rel=\"noopener\">使用 SRI 增强 LocalStorage 代码安全</a></li>\n</ul>\n<h1 id=\"服务端层面\"><a href=\"#服务端层面\" class=\"headerlink\" title=\"服务端层面\"></a>服务端层面</h1><p>由于本文只涉及前端性能优化，但为求流程完整，简单罗列与服务端相关的优化方案的常见手段。</p>\n<ul>\n<li>多域名资源加载</li>\n<li>负载均衡</li>\n<li>数据缓存</li>\n<li>反向代理</li>\n</ul>\n<h1 id=\"客户端层面\"><a href=\"#客户端层面\" class=\"headerlink\" title=\"客户端层面\"></a>客户端层面</h1><ul>\n<li>资源渲染数量/大小</li>\n<li>资源渲染路径</li>\n<li>用户体验</li>\n</ul>\n<h2 id=\"资源渲染数量-大小\"><a href=\"#资源渲染数量-大小\" class=\"headerlink\" title=\"资源渲染数量/大小\"></a>资源渲染数量/大小</h2><ul>\n<li><strong>压缩静态资源，清除无用代码</strong><ul>\n<li>Tree Shaking 无用代码移除</li>\n<li>UglifyJs 混淆 / 压缩代码</li>\n<li>Code Spliting 代码分割（资源按需加载或并行加载）</li>\n</ul>\n</li>\n<li><strong>开启 Gzip 压缩</strong><ul>\n<li>请求头 <code>Accept-Encoding: gzip, deflate</code></li>\n<li>响应头 <code>Content-Encoding: gzip</code></li>\n<li>Gzip 能够压缩任何文本类型的响应，包括 HTMl、XML 和 JSON</li>\n<li>已经压缩过的内容如图片、和 PDF 不要使用 Gzip，这些资源内容本身体积就小，再使用 Gzip 反而会增加资源下载时间，浪费 CPU 资源，而且有增加文件体积的可能</li>\n</ul>\n</li>\n<li><strong>多份编译文件按条件引入</strong><ul>\n<li>针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件</li>\n<li>可以利用 <code>&lt;script type=&quot;module&quot;&gt; / &lt;script type=&quot;module&quot;&gt;</code>进行条件引入用</li>\n</ul>\n</li>\n<li><strong>动态 Polyfill</strong><ul>\n<li>只针对不支持的浏览器运行环境引入 Polyfill</li>\n</ul>\n</li>\n<li><strong>图片优化</strong><ul>\n<li>根据业务场景，与 UI 探讨选择 <strong>合适质量，合适尺寸</strong></li>\n<li>根据需求和平台，选择 <strong>合适格式</strong>，例如非透明时可用 jpg；非苹果端，使用 webp</li>\n<li>小图片合成 <strong>雪碧图 CSS Sprite</strong>，低于 5K 的图片可以转换成 B<strong>ase64</strong> 内嵌</li>\n<li>合适场景下，使用 I<strong>confont</strong> 或者 <strong>SVG</strong></li>\n<li>压缩 favicon.ico 并缓存</li>\n<li>使用 Blob 异步加载</li>\n<li>使用 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FRevillWeb%2Fimg-2\" target=\"_blank\" rel=\"noopener\">img-2</a> 代替 img 标签</li>\n<li>嵌入资源：Base64 嵌入资源（针对小的静态图片资源）</li>\n</ul>\n</li>\n<li><strong>字体优化</strong><ul>\n<li>浏览器为了避免 FOUT（Flash Of Unstyled Text），会尽量等待字体加载完成后，再显示应用了该字体的内容。带来了 FOIT（Flash Of Invisible Text 问题），导致空白</li>\n<li>设置多字体，降级方法：使用默认字体</li>\n<li>异步加载字体文件：通过异步加载 CSS，即可避免字体阻塞渲染，还是会空白</li>\n</ul>\n</li>\n<li><strong>多媒体优化</strong><ul>\n<li>音视频</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"资源渲染路径\"><a href=\"#资源渲染路径\" class=\"headerlink\" title=\"资源渲染路径\"></a>资源渲染路径</h2><ul>\n<li><strong>优化加载顺序</strong><ul>\n<li>CSS 样式文件放在文档 <code>&lt;head&gt;</code> 标签中引入<ul>\n<li>把样式表放在 <code>&lt;head&gt;</code> 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉</li>\n</ul>\n</li>\n<li>JavaScript 脚本文件放在 <code>&lt;body&gt;</code> 标签底部引入<ul>\n<li><strong>原因</strong>：加载脚本文件会对后续资源渲染造成阻塞</li>\n<li><strong>方案</strong>：制定合理的脚本文件加载策略<ul>\n<li>动态脚本加载（异步加载、延迟加载、按需加载）</li>\n<li>添加 <code>defer</code> 属性的脚本文件是在 HTML 解析完之后才会执行。如果是多个，按照加载的顺序依次执行</li>\n<li>添加 <code>async</code> 属性的脚本文件是在加载之后立即执行，如果 HTML 还没解析完，会阻塞 HTML 继续解析。如果是多个，执行顺序和加载顺序无关</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>影响首屏的，优先级很高的脚本文件也可以 <code>&lt;head&gt;</code> 或 <code>&lt;body&gt;</code> 首子节点引入，甚至利用 <code>style</code> 或 <code>script</code> 内联</li>\n</ul>\n</li>\n<li><p><strong>资源加载方式</strong></p>\n<ul>\n<li>非关键性的文件尽可能的<strong>异步加载和延迟加载</strong>，避免阻塞首页渲染</li>\n<li><strong>资源提示指令</strong><ul>\n<li>Preload</li>\n<li>Prefetch</li>\n<li>Preconnect</li>\n<li>Subresource</li>\n</ul>\n</li>\n<li><strong>异步加载（预加载）</strong><ul>\n<li>利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应</li>\n<li>预判用户的行为，提前加载所需要的资源，则可以快速地响应用户的操作，从而打造更好的用户体验。另一方面，通过提前发起网络请求，也可以减少由于网络过慢导致的用户等待时间。</li>\n<li>Preload 规范 W3CPreload<ul>\n<li>rel 明确告知浏览器启用 preload 功能</li>\n<li>as 明确需要预加载资源的类型，包括 JavaScript、Images、CSS、Media 等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>延迟加载（懒加载、按需加载）</strong><ul>\n<li>页面初始加载时将非绝对必须的资源延迟加载，从而提高页面的加载和响应速度<ul>\n<li>非首屏使用的数据、样式、脚本、图片等</li>\n<li>用户交互时才会显示的内容</li>\n</ul>\n</li>\n<li><strong>实现方式：</strong><ul>\n<li>虚拟代理技术：真正加载的对象事先提供一个代理或者说占位符。最常见的场景是在图片的懒加载中，先用一种 loading 的图片占位，然后再用异步的方式加载图片。等真正图片加载完成后就填充进图片节点中去。</li>\n<li>惰性初始化技术：将代码初始化的时机推迟（特别是那些初始化消耗较大的资源）</li>\n</ul>\n</li>\n<li><strong>选择时机：</strong><ul>\n<li>滚动条监听：大型图片流场景，通过对用户滚动结束区域进行计算，从而只加载目标区域的资源，这样可以实现节流的目的</li>\n<li>事件回调：常用于需要用户交互的地方，如点击加载更多之类的，这些资源往往通过在用户交互的瞬间（如点击一个触发按钮），发起 AJAX 请求来获取资源。比较简单，在此不再赘述。</li>\n</ul>\n</li>\n<li>遵循渐进增强理念理念开发网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript</li>\n<li>将首屏以外的 HTML 放在不渲染的元素中，如隐藏的 <code>&lt;textarea&gt;</code>，或者 <code>type</code> 属性为非执行脚本的 <code>&lt;script&gt;</code> 标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>资源渲染</strong></p>\n<ul>\n<li>避免重排，减少重绘，避免白屏，或者交互过程中的卡顿</li>\n<li>通过 <a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"noopener\">CSS Trigger</a> 查询哪些样式属性会触发重排与重绘</li>\n<li><strong>减少重排的方法</strong><ul>\n<li>页面初始化</li>\n<li>减少对 DOM 元素内容改变（如：文本改变、图片被另一个同尺寸元素替代）</li>\n<li>减少对 DOM 元素尺寸改变（因为边距、填充、边框宽度、宽度、高度等属性改变）</li>\n<li>减少对 DOM 元素位置改变</li>\n<li>减少对可见 DOM 元素的操作（如：增加、移动和删除）<ul>\n<li>多次 DOM 操作合并为一次处理</li>\n<li>大量操作时，可将 DOM 脱离文档流或者隐藏，待操作完成后再重新恢复</li>\n</ul>\n</li>\n<li>减少旋转屏幕的操作</li>\n<li>减少改变浏览器窗口尺寸的操作</li>\n<li>减少设置元素 style 属性</li>\n<li>减少设置元素 class 属性</li>\n<li>通过延迟访问布局信息避免重排版<ul>\n<li>如 <code>offsetWidth</code>、<code>offsetHeight</code> 和 <code>getComputedStyle</code> 等</li>\n<li>原因：浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用</li>\n</ul>\n</li>\n<li>减少在 HTML 中缩放图片</li>\n<li>避免对大部分页面进行重排版<ul>\n<li>使用绝对坐标定位页面动画的元素，使它位于页面布局流之外</li>\n<li>启动元素动画，当它扩大时，它临时覆盖部分页面</li>\n<li>当动画结束时，重新定位，从而只一次下移文档其他元素的位置</li>\n</ul>\n</li>\n<li>开启 GPU 加速<ul>\n<li>transform</li>\n<li>opacity</li>\n<li>filter</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>相关链接：</strong></p>\n<ul>\n<li><a href=\"https://juejin.im/post/59b73ef75188253db70acdb5#heading-5\" target=\"_blank\" rel=\"noopener\">前端性能优化之加载技术</a></li>\n<li><a href=\"https://juejin.im/post/5b5984b851882561da216311\" target=\"_blank\" rel=\"noopener\">资源提示——什么是 Preload，Prefetch 和 Preconnect？</a></li>\n<li><a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FGoogleChrome%2Fpreload-webpack-plugin\" target=\"_blank\" rel=\"noopener\">preload-webpack-plugin</a></li>\n<li><a href=\"https://link.juejin.im/?target=https%3A%2F%2Fwww.smashingmagazine.com%2F2016%2F02%2Fpreload-what-is-it-good-for%2F\" target=\"_blank\" rel=\"noopener\">Preload 技术细节</a></li>\n</ul>\n<h2 id=\"用户体验\"><a href=\"#用户体验\" class=\"headerlink\" title=\"用户体验\"></a>用户体验</h2><ul>\n<li>谨慎控制好 Web 字体，一个大字体包足够让你功亏一篑<ul>\n<li>控制字体包的加载时机</li>\n<li>如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积</li>\n</ul>\n</li>\n<li>分清轻重缓急<ul>\n<li>重要的元素优先渲染</li>\n<li>视窗内的元素优先渲染</li>\n</ul>\n</li>\n<li>服务端渲染（SSR）<ul>\n<li>减少首屏需要的数据量，剔除冗余数据和请求</li>\n<li>控制好缓存，对数据/页面进行合理的缓存</li>\n<li>页面的请求使用流的形式进行传递</li>\n</ul>\n</li>\n<li>优化用户感知<ul>\n<li>利用一些动画 <strong>过渡效果</strong>，能有效减少用户对卡顿的感知</li>\n<li>尽可能利用 <strong>骨架屏（Skeleton）/ Loading</strong> 等减少用户对白屏的感知</li>\n<li>动画帧数尽量保证在 <strong>30 帧</strong> 以上，低帧数、卡顿的动画宁愿不要</li>\n<li>JavaScript 执行时间避免超过 100ms ，超过的话就需要做：<ul>\n<li>寻找可缓存的点</li>\n<li>任务的分割异步或 web worker 执行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"编码层面\"><a href=\"#编码层面\" class=\"headerlink\" title=\"编码层面\"></a>编码层面</h1><p>编码优化，指的就是在代码编写时的，通过一些 <strong>最佳实践</strong>，提升代码的执行性能。通常这并不会带来非常大的收益，但这属于<strong>程序员的自我修养</strong>，而且这也是面试中经常被问到的一个方面，考察自我管理与细节的处理。</p>\n<h2 id=\"JavaScript-优化\"><a href=\"#JavaScript-优化\" class=\"headerlink\" title=\"JavaScript 优化\"></a>JavaScript 优化</h2><ul>\n<li><strong>数据读取</strong><ul>\n<li>通过作用域链 / 原型链读取变量或方法时，需要更多的耗时，且越长越慢</li>\n<li>对象嵌套越深，读取值也越慢</li>\n<li>最佳实践：<ul>\n<li>尽量在局部作用域中进行 <strong>变量缓存</strong></li>\n<li>避免嵌套过深的数据结构，<strong>数据扁平化</strong> 有利于数据的读取和维护</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>循环</strong>：循环通常是编码性能的关键点<ul>\n<li>代码的性能问题会在循环中被指数倍放大</li>\n<li>最佳实践:<ul>\n<li>尽可能 减少循环次数；<ul>\n<li>减少遍历的数据量</li>\n<li>完成目的后马上结束循环</li>\n</ul>\n</li>\n<li>避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存</li>\n<li>JavaScript 中使用 <strong>倒序循环</strong> 会略微提升性能</li>\n<li>尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>条件流程性能</strong>：Map / Object &gt; switch &gt; if-else</li>\n<li><strong>模块化</strong>：尝试使用 <code>import()</code></li>\n</ul>\n<h2 id=\"DOM-优化\"><a href=\"#DOM-优化\" class=\"headerlink\" title=\"DOM 优化\"></a>DOM 优化</h2><ul>\n<li>减少 DOM 的层级，可以减少渲染引擎工作过程中的计算量</li>\n<li>减少访问 DOM 的次数，如需多次，将 DOM 缓存于变量中</li>\n<li>使用事件委托，避免大量的事件绑定</li>\n<li>使用 <code>requestAnimationFrame</code> 来实现视觉变化：一般来说我们会使用 <code>setTimeout</code> 或 <code>setInterval</code> 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿</li>\n</ul>\n<h2 id=\"CSS-优化\"><a href=\"#CSS-优化\" class=\"headerlink\" title=\"CSS 优化\"></a>CSS 优化</h2><ul>\n<li><strong>层级扁平</strong>，避免过于多层级的选择器嵌套</li>\n<li><strong>特定的选择器</strong>：好过一层一层查找：<code>.xxx-child-text{}</code> 优于 <code>.xxx .child .text{}</code></li>\n<li><strong>减少使用通配符与属性选择器</strong><ul>\n<li>选择器越复杂，匹配用的时间越多</li>\n</ul>\n</li>\n<li><strong>减少不必要的多余属性</strong></li>\n<li>使用 <strong>动画属性</strong> 实现动画，动画时脱离文档流，开启硬件加速，优先使用 CSS 动画</li>\n<li>使用 <code>&lt;link&gt;</code> 替代原生 @import</li>\n<li>避免使用表达式，例如 <code>font-color: expression((new Date()).getHours()%3?&quot;#FFF&quot;:&quot;#AAA&quot;)</code> 这个表达式会持续地在页面上计算样式，影响页面性能</li>\n</ul>\n<h2 id=\"HTML-优化\"><a href=\"#HTML-优化\" class=\"headerlink\" title=\"HTML 优化\"></a>HTML 优化</h2><ul>\n<li>写对文档类型声明 <code>&lt;!DOCTYPE html&gt;</code> 这能确保浏览器按照最佳的相关规范进行渲染</li>\n<li><strong>减少 DOM 数量</strong>，避免不必要的节点或嵌套；</li>\n<li>避免空的 <code>src</code> 和 <code>href</code>：当 <code>src</code> 和 <code>href</code> 为空时，浏览器会默认填充链接，并将页面的内容加载进来作为它们的值，具体规则如下：<ul>\n<li>IE 向<strong>页面所在的目录</strong>发送请求</li>\n<li>Safari、Chrome、Firefox 向页面本身 URL 发送请求</li>\n<li>Opera 不执行任何操作</li>\n</ul>\n</li>\n<li>图片提前 <strong>指定宽高</strong> 或者 <strong>脱离文档流</strong>，能有效减少因图片加载导致的页面回流</li>\n<li><strong>语义化标签</strong> 有利于 SEO 与浏览器的解析时间</li>\n<li>减少使用 table 进行布局，避免使用 <code>&lt;br/&gt;</code> 与 <code>&lt;hr/&gt;</code></li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>性能优化方案清单</strong></p>\n<ul>\n<li>🧾 <a href=\"https://juejin.im/post/5a966bd16fb9a0635172a50a\" target=\"_blank\" rel=\"noopener\">2018 前端性能优化清单</a></li>\n<li>🧾 <a href=\"https://github.com/berwin/Blog/issues/23\" target=\"_blank\" rel=\"noopener\">嗨，送你一张 Web 性能优化地图</a></li>\n<li>🧾 <a href=\"https://segmentfault.com/a/1190000018263418?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com&amp;share_user=1030000000178452\" target=\"_blank\" rel=\"noopener\">Web 性能优化总结</a></li>\n<li>🧾 <a href=\"https://juejin.im/post/5b025d856fb9a07aa0484e54\" target=\"_blank\" rel=\"noopener\">大前端性能总结</a></li>\n<li>🧾 <a href=\"https://juejin.im/post/5b6133a351882519d346853f\" target=\"_blank\" rel=\"noopener\">CSS 性能优化的 8 个技巧</a></li>\n<li>🧾 <a href=\"https://juejin.im/post/5b7e1f81f265da436a075db4\" target=\"_blank\" rel=\"noopener\">精读 《高效 JavaScript》</a></li>\n<li>🧾 <a href=\"https://juejin.im/post/5c011e0c5188252ea66afdfa\" target=\"_blank\" rel=\"noopener\">Web 性能优化清单</a></li>\n<li>🗃 <a href=\"https://github.com/barretlee/performance-column/milestone/1\" target=\"_blank\" rel=\"noopener\">性能相关基础知识点研究</a></li>\n<li>🗃 <a href=\"https://github.com/liangsenzhi/awesome-wpo-chinese\" target=\"_blank\" rel=\"noopener\">前端性能优化资源列表</a></li>\n<li>🗃 <a href=\"https://github.com/davidsonfellipe/awesome-wpo\" target=\"_blank\" rel=\"noopener\">awesome-wpo</a></li>\n<li>🗃 <a href=\"https://github.com/drublic/checklist\" target=\"_blank\" rel=\"noopener\">A Frontend Checklist for Websites</a></li>\n</ul>\n<p><strong>优化方向</strong></p>\n<ul>\n<li>🎡 <a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\" target=\"_blank\" rel=\"noopener\">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>\n<li>🎡 <a href=\"http://velocity.oreilly.com.cn/2013/ppts/16_ms_optimization--web_front-end_performance_optimization.pdf\" target=\"_blank\" rel=\"noopener\">16 毫秒的优化</a></li>\n<li>🎡 <a href=\"https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution\" target=\"_blank\" rel=\"noopener\">Optimize JavaScript Execution 优化 JavaScript 执行</a></li>\n</ul>"},{"title":"Web 前后端应用 Docker 容器化独立部署实践","date":"2020-04-20T00:00:00.000Z","_content":"\n在人类社会大分工越来越精细的大背景下，各式各样的软件技术公司层出不穷，为各行各业提供着或大众化或具有特色的软件服务，大部分软件服务是公有性质的，也就是这些服务提供商内部单独的运营软件平台，使用者获取软件使用权后在其平台生产内容，并由服务商提供数据存储服务，这种性质的平台对于软件开发商来说需要考虑数据的隔离，对于使用者来说则减少了维护成本，但是数据并非私自存储无法确保安全性。而相对于公有性软件服务的就是私有化软件服务，这类型产品提供可部署至客户私自的服务器上的版本，数据由客户自身存储，某种程度上保证的了数据的安全性。\n\n在 PPmoney 内部，龙猫 X 配置平台提供给理财及借贷两个技术团队使用，对于页面、模版、组件、素材都需要在公共空间进行共享存储，而现有的人员权限机制无法对这些要素进行筛选区分，无可避免出现管理混乱的局面。而根据不同的团队、不同的部署环境进行系统部署也是需求的关注点。考虑到对数据的隔离，以及未来龙猫 X 作为软件服务对外提供商业性质的服务，为龙猫 X 增强可独立部署的功能的事宜即提上开发的日程。\n\n在对龙猫 X 的独立部署的技术选型上我们选择了 Docker 容器化技术。之所以选择 Docker 是因为容器技术对进程进行封装隔离，能够高效地在利用服务器资源以及便捷地在多平台间进行迁移。\n\n在这篇文章中我尝试把容器化改造过程中遇到的坑位记录下来为后人提供借鉴，也是对整个坎坷的过程的记录。\n\n<!-- more -->\n\n## 容器化技术\n\n容器技术对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此称为容器。\n\n![服务器中的容器](http://img.mrsingsing.com/docker-in-server.png)\n\nDocker 容器化技术关键核心只需要掌握三个概念：\n\n- 镜像 Image\n- 容器 Container\n- 仓库 Repository\n\n从小白的角度理解的话可以把 **镜像** 和 **容器** 类比为面向对象编程中的类和实例，镜像是静态的定义，而容器则是镜像运行时的形态。我们可以把容器想像成包装盒，包装盒里装载着一个微型操作系统，其内部运行着我们的应用程序。\n\n仓库则是存放镜像的地方，可以为镜像打 tag（标签），就好像我们为 git commit 打版本号的 tag 一样，使用者可以根据需要选择版本部署，程序故障时也能立马根据版本进行回滚。\n\nDocker Hub 是 Docker 官方的公开的仓库，私有仓库则有 Harbor，商业化的容器服务提供商有阿里云、Dao Cloud 等。我们公司采用的是内部自建的 Harbor 仓库。\n\n因为本篇文章非科普性质，所以对于 Docker 的介绍就不过于深入叙述，有兴趣可以搜索相关文章进行研究，当然首推还是把 [官方文档](https://docs.docker.com/) 看一遍，毕竟第一手资料才是最具参考价值的。\n\n## 镜像制作\n\n对龙猫 X 进行容器化改造需要部署四个子项目，分别是 React 全家桶的客户端项目、Koa 服务端项目、页面爬虫项目以及 MongoDB 数据库。\n\n在 Docker 中，镜像是根据配置文件 Dockerfile 构建的。通过以下命令可以执行构建的工作：\n\n```bash\n# docker build -t <镜像名称> <构建目录>\n$ docker build -t totorox-admin .\n```\n\n`-t` 表示将镜像命名为 `totorox-admin`。\n\n### 前端项目\n\n如下图所示为前端项目镜像的配置文件：\n\n![Dockerfile in Frontend Project](http://img.mrsingsing.com/frontend-dockerfile.png)\n\n在 Dockerfile 中 `FROM` 指令是必然存在的并且作为构建的开头，该指令初始化一个新的构建阶段（也就是有多少个 `FROM` 指令就有多少个镜像构建阶段）并为后续指令设置基础映像。\n\n`COPY` 指令表示拷贝资源至镜像内部，这里有个优化的小技巧，就是在项目根目录添加 `.dockerignore` 文件，与 `.gitignore` 或 `.npmignore` 类似，添加到该文件下的目录 Docker 构建镜像时将忽略其中的文件。我们可以把只用于代码开发阶段或者规范性的文件排除在构建之外，例如 `.vscode`、`.eslint`、`dist` 等。\n\n接下来就是常规的安装依赖、项目构建打包的指令，`npm install` 可以指定为淘宝镜像，在国内的话下载速度相对有保障，能够缩减镜像的构建时间。\n\n类似地，由于我们的项目中使用到了 Sass 预编译，Webpack 打包需要用到 `node-sass` 插件，每次都必须下载 `win32-x64-57_binding.node` 文件，所以要不需要漫长的等待（因为从国外源仓库下载），要不下载失败报一系列的错。幸好它提供了人性化的配置，可以通过环境变量改变下载的地址。我们在 `.npmrc` 中将一些依赖包中需要额外下载的文件的链接地址的环境变量指定为国内的镜像地址。当然啦并非所有依赖包都支持这样做，有些写死了下载地址是无法通过这样的方法优化的。除了上面提到的 `node-sass`，其余可以在 [淘宝镜像](https://developer.aliyun.com/mirror/NPM?from=tnpm) 找到对应的镜像地址，后面会提到的页面爬虫项目中使用的 `phantomjs` 也是通过这种方式大幅度压缩了构建时间。\n\n![.npmrc配置文件](http://img.mrsingsing.com/npmrc.jpg)\n\n第二阶段我们从镜像仓库获取 Nginx 镜像。一般地，前端项目构建打包后生成静态资源文件，需要 Web 代理服务器进行请求转发，我们这里用的是 Nginx，当然也可以用 Express 实现一个 Web 服务作为代理转发。\n\nNginx 配置和使用相对来说比较简单，通过简单的配置即可拥有高性能和高可用性，下面是 Nginx 的示例配置：\n\n![Nginx配置](http://img.mrsingsing.com/nginx-conf.png)\n\n在该阶段中，主要是将第一阶段生成的产物转移到第二阶段，这是因为镜像最终的启动指令 `CMD` 是在第二阶段，而且分阶段的镜像构建能够使得最终容器内只需放置打包后的静态资源文件即可，不用包含源代码文件，镜像的体积也会因此而大幅度缩减，在某种程度也确保了源代码的不对外泄漏。\n\n最终 `CMD` 命令是容器运行时在内部执行的指令。考虑到不同使用者的 API 服务器域名是不同的是动态变化的，在源代码中把 API 域名写死显然是个不明智的做法。因此，我们通过在运行容器时的环境变量植入写好的 Shell 脚本，通过 Shell 脚本生成包含域名等信息的 JavaScript 文件，HTML 文档通过写好的外链该脚本文件实现加载，这样即可满足动态域名变更的需求。\n\n在镜像构建过程中，如果细心观察打印的日志，会发现有这么一句：\n\n![移除中间容器](http://img.mrsingsing.com/removeing-intermediate-container.jpg)\n\n其实从构建的日志中可以看到，实质上镜像构建的每个指令都会生成一个临时的中间容器，每层中间容器都是以前面一层中间容器为基础的。当对应的指令执行完毕后，对应层级就不会再发生改变，会移除该临时创建的中间容器，然后再进行下一个指令操作。\n\n构建成功后，在命令行中输入 `docker images` 即可查看当前宿主机的 Docker 镜像列表：\n\n![容器镜像](http://img.mrsingsing.com/docker-images.jpg)\n\n由于我们的项目所需要的镜像在公司内部有私有仓库，所以构建时速度有一定的保障，如果是个人开发者在自己的服务器上构建镜像可能需要从公有仓库例如 Docker Hub 拉取所需要的镜像，这里提供一个优化的手段，可以通过修改 Docker Daemon 配置 `/etc/docker/daemon.json` 的镜像地址，实现镜像的加速，Docker 官方和国内很多云服务器平台都提供了国内的加速服务。\n\n🌰 **示例：**\n\n这里提供的镜像地址仅供参考，可以到对应的云服务商找到对应的镜像加速地址。\n\n![镜像加速](http://img.mrsingsing.com/docker-image-acceleration.png)\n\n除此之外，在使用 Docker 构建部署应用前最好确认好 Docker 的版本，例如 CentOS 7 系统默认的 Docker 版本是 13，而 `FROM AS` 的语法则需要 Docker 版本 17 以上才支持，这个时候需要先对宿主机的 Docker 进行版本更新。\n\n安装最新版本的 Docker 可以参考：\n\n[CentOS 安装最新版本的 Docker](https://www.jianshu.com/p/2e208721aa39)\n\n升级 Docker 后重启容器出现错误 `Unknown runtime specified docker runc` 的解决方案：\n\n```bash\n$ grep -rl 'docker-runc' /var/lib/docker/containers/ | xargs sed -i 's/docker-runc/runc/g'\n\n$ systemctl stop docker\n\n$ systemctl start docker\n```\n\n### 服务端项目\n\n接下来我们看看用 Koa 搭建的服务端项目如何部署，类似操作指令就不再重复赘述了，主要谈谈需要注意的地方。\n\n![服务端Dockerfile](http://img.mrsingsing.com/backend-dockerfile.png)\n\n因为项目中通过开启子进程的方式执行 Webpack 命令进行页面的生成，因此我们需要在容器内全局安装 Webpack。\n\n我们看到这里为一个名为 `wait-for-it.sh` 的提供了可执行的权限，而且在后续的 `CMD` 指令中先执行了该脚本文件。应用容器化后，Docker 容器启动时，默认使用非 root 用户执行命令，所以应用内的脚本文件无法正常执行，这时候就需要执行 `chmod a+x` 为脚本文件提供可执行的权限。至于这个脚本的存在意义我们在后面容器通讯的部分再详细说明，暂且跳过。\n\n下面我们谈谈 Dockerfile 中的输入参数 `ARG`、环境变量 `ENV` 以及如何将 Dockerfile 中的环境变量/传入参数在 `CMD` 指令中的使用。\n\n指令 `ARG` 定义一个变量，用户可以在使用 `docker build` 命令使用 `--build-arg <varname>=<value>` 标志，在构建时将其传递给构建器。\n\n```dockerfile\nARG env\n\n# 指定默认值\nARG env=local\n```\n\n如果 `ARG` 对应的值有缺省值，并且如果在构建时没有传递值，则构建器使用缺省值。\n\nDockerfile 的 `ENV` 指令有两种书写方式：\n\n```dockerfile\nENV <key> <value>\n\n# 这种写法键/值与等号之间不能存在空格\nENV <key>=<value>\n\n# 通过斜杠 \\ 换行一次性声明多个环境变量\nENV API_URL=example.com \\\n    NODE_ENV=production \\\n    COMMAND=dev\n```\n\n与 `ARG` 指令对比，`ENV` 始终存在于镜像当中，而 `ARG` 仅在执行时存在。\n\n关于 dockerfile 中的环境变量替换可以阅读官方文档中有关 [环境变量替换](https://docs.docker.com/engine/reference/builder/#environment-replacement) 的相关章节。\n\n`CMD` 指令有三种书写方式：\n\n```dockerfile\n# 使用 exec 执行，这类格式在解析时会被解析成 JSON 数组，因此一定要使用双引号\nCMD [\"command\", \"instructions\", \"options\"]\n\n# 使用 /bin/sh 中执行，提供给需要交互的应用\n# 实际命令会被包装为 sh -c 的参数形式进行执行\nCMD command param1 param2\n```\n\n指定启动容器时执行命令，每个 Dockerfile 只能有一个 `CMD` 指令。如果指定了多条命令，则只有最后一条会被执行。如果用户启动容器时指定了运行的命令，则会覆盖掉 `CMD` 指定的命令。\n\n在我们的项目中，除了前面谈过的前端项目需要将 API 域名等在 Docker 运行初期动态植入外，服务端项目也需要传入数据库相关的信息。经过实验发现，`exec` 形式的 `CMD` 是通过 Docker 来运行命令的，并不支持参数替换。而 `shell` 形式的 `CMD` 则是通过 Docker 来运行 `sh`，`sh` 再运行我们写的命令，而 `sh` 是支持参数替换的。\n\n所以如果想将 Dockerfile 中的环境变量 `ENV` 或参数 `ARG` 在 `CMD` 指令中使用，就需要采用 `shell` 的形式书写启动命令。\n\n```dockerfile\n# docker run 后添加的参数传入\nARG env=production\n\n# 从执行 shell 命令的执行环境中读取 ENV 变量作为 dockerfile 中的 env 变量值\nENV env=${ENV}\n\n# 启动命令是执行脚本 /scripts/setup.sh\n# 该脚本需要传入环境变量 env，也就是 dockerfile 中定义的变量\nCMD /scripts/setup.sh ${env}\n```\n\n### 爬虫项目\n\n接着我们谈谈页面爬虫项目的镜像构建。\n\n由于龙猫 X 主要用于移动端营销活动，页面的加载体验对用户转化率起到至关重要的作用，因此发布页面都经由无头浏览器爬取发布页面的首屏渲染的 HTML 文档以缩减页面的白屏时间。\n\n在 Linux 系统中使用 PhantomJS 需要从源代码仓库中拉取整包，下载速度因众所周知的原因非常慢，所以这里改用阿里国内的镜像作为下载地址，后续经过一系列解压缩、移动文件、建立软链接等，在容器内能够直接通过命令行执行 PhantomJS 的相关命令。\n\n前面提及每个指令都是新的构建层，所以这里也是通过管道连接的方式实现一连串的操作，这种方式是很好的压缩镜像体积的方法。\n\n![爬虫项目 Dockerfile](http://img.mrsingsing.com/spider-dockerfile.png)\n\n### 数据库项目\n\n下面需要对 MongoDB 数据库实现容器化管理。先给大家看看 MongoDB 数据库的 Dockerfile 文件：\n\n![](http://img.mrsingsing.com/mongodb-dockerfile.png)\n\n由于独立部署版本的龙猫 X 在初始化时需要导入默认的数据，例如组件数据、组件类型数据、标签数据、页面类型数据等。我们从已有的项目中导出数据并进行适当修正后，将数据文件保存到项目指定默认数据的目录下，在 Dockerfile 中指定 `RUN` 通过下面的 shell 脚本对数据库进行初始化，并向数据库中导入数据。\n\n![MongoDB 初始化脚本](http://img.mrsingsing.com/docker-entrypoint-initdb.png)\n\n为了提高数据库的扩展性，数据库的用户名、密码、名称可以通过环境变量的方式进行设置，方便不同的团队根据自身需求修改。\n\n我们将四个项目分别通过 `docker build` 命令构建独立的镜像后，通过命令 `docker images` 能够查看到所有已构建的镜像列表，通过 `docker history <image-id>` 命令能够查看镜像构建过程中的细节：包括每层指令执行的指令、构建后的产物占镜像的体积大小等，通过分析构建历史能够让我们掌握依据对 Dockerfile 进行优化。\n\n![容器构建历史](http://img.mrsingsing.com/docker-history.jpg)\n\n除此之外，构建好的镜像需要持久化保存的话，需要 `docker tag` 打标签并 `docker push` 到远程仓库中进行保存。\n\n## 容器互联\n\n我们知道服务端项目运行时是需要与数据库保持连接的，那么 Docker 是否提供某种机制让不同容器之间进行通信呢？\n\n当 Docker 启动时，实际上会自动在宿主机上创建一个 `docker0` 虚拟网桥，相当于 Linux 上的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n\n![容器互联](http://img.mrsingsing.com/docker-network.png)\n\n回到我们的需求上，我们需要将服务端项目、数据库项目和爬虫项目包裹在一个网络当中，也就是建立这三个项目对应容器的“局域网”。将容器加入指定的局域网其实很简单，talk is cheap，show you the code：\n\n```bash\n# 创建虚拟局域网 `totorox-net` 是该局域网的名称\ndocker network create -d bridge totorox-net\n\n# 启动容器时带上 `--network <你创建的局域网名称>` 即可加入到指定的局域网内\ndocker run -d --name totorox-server -p 3012:3012 --network totorox-net ...\n```\n\n以此类推在对应的容器启动时也加入局域网内，那么局域网内的容器之间就能够通过加入局域网时随机分配的域名进行访问。\n\n<!-- ![docker network ls 查询 docker]() -->\n\n那么问题来了，从服务端容器的角度出发，怎么知道数据库容器的域名是 `xxx.xxx.xxx.xxx` 呢，总不能每次启动后 `docker network ls` 查看容器分配到的局域网域名，然后再到对应的容器内部进行修改，这显然不太科学。\n\ndocker 作为广泛使用的技术，其开源团队显然不会犯如此低级的设计错误。实际上，除了运行容器时将容器加入局域网外，为容器命名也是必不可少的步骤。容器名称类比来理解，相当于我们需要申请购买域名以替代 IP 地址一样，一般用户只需要记住辨识度高的网站地址，访问时通过 DNS 解析到 IP 地址再对服务器进行访问，这里 docker 容器互联的原理是高度类似的，局域网内直接访问容器名称也能解析到对应的容器当中并进行访问。\n\n多说无益，我们看看如何在服务端项目中用 Mongoose 连接数据库容器的 MongoDB：\n\n```js\n// username 为数据库账户名称\n// password 为数据库账户密码\n// containerName 为数据库项目容器的名称\n// databaseName 为数据库名称\nconst uri = `mongodb://${username}:${password}@${containerName}/${databaseName}`;\n\nmongoose.connect(uri, {\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n  autoIndex: false,\n});\n```\n\n这里踩了不少坑，Mongoose 连接 MongoDB 的域名使用容器名称作为标识，而非使用随机分配的固定 IP 地址，或容器网络的名称。\n\n除此之外，很多中文文章中都没有提到一个遇上机率比较大的坑，就是服务端是需要等待 MongoDB 数据库启动并就绪后，才能连接成功的。\n\n在使用 `docker run` 方式启动容器时要先启动 MongoDB 的容器，再启动服务端项目的容器，两个启动命令执行需要有段时间差，不能执行前一个，马不停蹄地就执行下一个。这是因为 `docker run` 只是作为启动容器的起点，容器内部实际对外服务的数据库正在执行启动中，容器局域网内并不能第一时间对其进行访问，而是需要等待一段时候后暴露的端口才可接受外部请求。在容器外来看，`docker run` 命令执行后容器是启动了，但是内部实际提供服务的数据库还没准备就绪，这就有可能导致服务端项目连接数据库容器出现超时的问题发生。\n\n因此，我们需要对 mongoose 设立重连机制，当连接超时等情况出现时，也能自动对数据库进行重连操作。\n\n```js\nconst connect = () => {\n  mongoose.connect(uri, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n    autoIndex: false,\n  });\n};\ndb.on('error', error => {\n  console.error('Error in MongoDB connection:' + error);\n  mongoose.disconnect();\n});\ndb.on('disconnected', () => {\n  console.log('MongoDB disconnected!');\n  connect();\n});\ndb.on('close', () => {\n  console.log('Lost MongoDB connection...');\n  connect();\n  console.log('Reconnect to MongoDB, wait...');\n});\n```\n\n除了服务端内部进行数据库重连的保障外，后面会提到容器编排也会出现这样的情况，server 项目依赖 database 项目的启动，`docker-compose.yml` 中有个配置项是 `depends_on`，表示等待指定的容器启动后再进行当前容器的启动。在容器的角度来看，它只知道容器的是否已经启动，也可以理解为是否已经执行了 `docker run` 的命令，容器内部的项目是否启动，容器的管不着的，它也不知道，所以如果内部服务启动时间久于容器之间编排启动的时间，同时两者强依赖性质的，那么就会导致某方出现错误，这样的情况大部分出现在对数据库的连接上。\n\n可能由于接收到的反馈太多，官方文档中 [Control startup and shutdown order in Compose](https://docs.docker.com/compose/startup-order/) 也明确表示这个问题，它提供了几个轮训容器服务的解决方案，包括 [wait-for-it.sh](https://github.com/vishnubob/wait-for-it)、[dockerize](https://github.com/jwilder/dockerize) 和 [wait-for](https://github.com/Eficode/wait-for)。\n\n## 服务部署\n\n首先我们先部署好前端项目，前端项目容器内部执行 Nginx 命令启动代理服务器从而转发请求，如果按照前面所列的 Nginx 配置，理论上应该能顺利启动容器。\n\n不过这里也提一下实践中遇到的问题：\n\n```bash\n# 启动容器\n$ docker run -d --name totorox-admin -p 8200:80 hub.ppmoney.io/telescope/totorox-admin\nStarting nginx ... done\nAttating to nginx\n```\n\n就是执行完毕后，界面会一直停留在 `Attating to nginx`，没有报错也没有提示运行成功。\n\n这个问题，是由于容器内部 `/etc/nginx/conf.d/default.conf` 路径下的 `default.conf` 文件的缺失所导致，换句话说就是 Nginx 启动所需要执行的默认配置丢失了。在容器的层面分析，有可能是因为容器挂载了 `volumes`，而宿主机的 `conf.d` 目录下为空覆盖了容器内部对应目录下的文件，具体原因可以 `docker exec -it totorox-admin .` 进入容器内部检查。\n\n下面罗列了根据构建好的镜像在服务器上启动运行容器：\n\n![运行容器命令](http://img.mrsingsing.com/docker-run.png)\n\n容器启动后，可以输入 `docker ps -a` 查看宿主机上所有的容器列表。\n\n![查看宿主机容器列表](http://img.mrsingsing.com/docker-container-list.jpg)\n\n从上图可以表格中的 STATUS 和 PORTS 可以看出来，有三个容器已经启动，但是 MongoDB 的容器则启动失败了。\n\n查看日志 `docker logs <container-name>` 查看容器的运行日志，找到出错的原因（这里只是为了演示而出错，上述相关代码均验证有效）。\n\n这里可能会有些疑问，是否应该使用 PM2 等守护进程工具对进程进行守护呢？\n\n实际上容器中的应用都应该前台执行运行，而非后台执行，容器内没有后台服务的概念。对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义。 比如 `CMD service nginx start` 它等同于 `CMD [ \"bash\", \"-c\", \"service nginx start\"]` 主进程实际上是 `bash`，`bash` 也就结束了，`bash` 作为主进程退出了。因此在我们的镜像构建配置文件中，均直接开启服务而非通过 PM2 或 Forever 等工具开启。\n\n容器的启动相对比较简单，根据需要使用配置项即可快速启动/停止容器。但是，每次部署都需要输入一大串的命令，哪天忘记了哪个参数忘了传怎么办，命令的执行顺序调换了怎么，这个时候就需要一种容器编排的方式，让每次容器更新部署都能通过更简便的命令实现。\n\n## 容器编排\n\ndocker-compose 负责实现对 Docker 容器集群的快速编排。使用者通过 `docker-compose.yml` 模版文件定义一组关联的应用容器为一个项目。它默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。简单来说，就是把刚才一连串的命令利用静态的配置文件记录下来，启动容器只需通过 `docker compose up -d` 命令运行即可。\n\n![容器编排](http://img.mrsingsing.com/docker-compose.png)\n\n首先，我们需要注意 `docker-compose` 的版本问题，有的配置项是 version2.0 没有，而 version3.0 新增的，详情直接看官方文档 [Compose file versions and upgrading](https://docs.docker.com/compose/compose-file/compose-versioning/) 即可。\n\n`docker-compose.yml` 定义了启动容器名称、镜像地址、对外暴露的端口、环境变量、数据卷以及容器启动的先后顺序等。\n\n`docker-compose` 启动时会先获取本地镜像，如果本地已经有对应的镜像则会直接使用，如果本地没有找到，则会从远程仓库拉取到本地后再启动。\n\n`restart: always` 配置项可以让容器在内部服务挂掉的时候，自动重新启动内部服务。\n\n仓库公开的代码应该需要对文件进行脱敏，也就是将配置文件（包括登录数据库的用户名密码等）排除公开的文件列表中。\n\n```bash\n$ docker run -e VARIABLE1 --env VARIABLE2=foo --env-file ./env.list ubuntu bash\n```\n\n---\n\n**参考资料：**\n\n- [Passing variables to Docker](https://docs.docker.com/engine/reference/commandline/run/#set-environment-variables--e---env---env-file)\n- [Pass Docker Environment Variables During The Image Build](https://vsupalov.com/docker-build-pass-environment-variables/)\n- [How To Pass Environment Info During Docker Builds](https://blog.bitsrc.io/how-to-pass-environment-info-during-docker-builds-1f7c5566dd0e)\n- [How to setup Node environment variable in Dockerfile for running node.js application?](https://stackoverflow.com/questions/42992397/how-to-setup-node-environment-variable-in-dockerfile-for-running-node-js-applica)\n- [How to create a Node App within a Docker container with Mongo](https://hn.werick.codes/how-to-create-a-node-app-within-a-docker-container-with-mongo-cjwjd3l4t00067rs18w7035oc)\n- [Cannot connect from node to mongo replicaset in docker](http://quabr.com/57123227/cannot-connect-from-node-to-mongo-replicaset-in-docker)\n- [Docker Node 项目连接 MongoDB](https://blog.csdn.net/weixin_30466953/article/details/97366689)\n- [升级 Docker 后重启容器出现错误 Unknown runtime specified docker-runc](https://blog.csdn.net/wxb880114/article/details/88869215)\n- [Mongoose 远程连接 MongoDB，当客户端断开网络重连时报错 topology was destoryed？](https://segmentfault.com/q/1010000010768993)\n- [这可能是网络上唯一一篇给前端写的 Docker+Node+Nginx+MongoDB 的本地开发+部署实战](https://juejin.im/post/5ddb3f85e51d45231576af3c)\n","source":"_posts/docker-deploy-pratice.md","raw":"---\ntitle: Web 前后端应用 Docker 容器化独立部署实践\ndate: '2020-04-20'\n---\n\n在人类社会大分工越来越精细的大背景下，各式各样的软件技术公司层出不穷，为各行各业提供着或大众化或具有特色的软件服务，大部分软件服务是公有性质的，也就是这些服务提供商内部单独的运营软件平台，使用者获取软件使用权后在其平台生产内容，并由服务商提供数据存储服务，这种性质的平台对于软件开发商来说需要考虑数据的隔离，对于使用者来说则减少了维护成本，但是数据并非私自存储无法确保安全性。而相对于公有性软件服务的就是私有化软件服务，这类型产品提供可部署至客户私自的服务器上的版本，数据由客户自身存储，某种程度上保证的了数据的安全性。\n\n在 PPmoney 内部，龙猫 X 配置平台提供给理财及借贷两个技术团队使用，对于页面、模版、组件、素材都需要在公共空间进行共享存储，而现有的人员权限机制无法对这些要素进行筛选区分，无可避免出现管理混乱的局面。而根据不同的团队、不同的部署环境进行系统部署也是需求的关注点。考虑到对数据的隔离，以及未来龙猫 X 作为软件服务对外提供商业性质的服务，为龙猫 X 增强可独立部署的功能的事宜即提上开发的日程。\n\n在对龙猫 X 的独立部署的技术选型上我们选择了 Docker 容器化技术。之所以选择 Docker 是因为容器技术对进程进行封装隔离，能够高效地在利用服务器资源以及便捷地在多平台间进行迁移。\n\n在这篇文章中我尝试把容器化改造过程中遇到的坑位记录下来为后人提供借鉴，也是对整个坎坷的过程的记录。\n\n<!-- more -->\n\n## 容器化技术\n\n容器技术对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此称为容器。\n\n![服务器中的容器](http://img.mrsingsing.com/docker-in-server.png)\n\nDocker 容器化技术关键核心只需要掌握三个概念：\n\n- 镜像 Image\n- 容器 Container\n- 仓库 Repository\n\n从小白的角度理解的话可以把 **镜像** 和 **容器** 类比为面向对象编程中的类和实例，镜像是静态的定义，而容器则是镜像运行时的形态。我们可以把容器想像成包装盒，包装盒里装载着一个微型操作系统，其内部运行着我们的应用程序。\n\n仓库则是存放镜像的地方，可以为镜像打 tag（标签），就好像我们为 git commit 打版本号的 tag 一样，使用者可以根据需要选择版本部署，程序故障时也能立马根据版本进行回滚。\n\nDocker Hub 是 Docker 官方的公开的仓库，私有仓库则有 Harbor，商业化的容器服务提供商有阿里云、Dao Cloud 等。我们公司采用的是内部自建的 Harbor 仓库。\n\n因为本篇文章非科普性质，所以对于 Docker 的介绍就不过于深入叙述，有兴趣可以搜索相关文章进行研究，当然首推还是把 [官方文档](https://docs.docker.com/) 看一遍，毕竟第一手资料才是最具参考价值的。\n\n## 镜像制作\n\n对龙猫 X 进行容器化改造需要部署四个子项目，分别是 React 全家桶的客户端项目、Koa 服务端项目、页面爬虫项目以及 MongoDB 数据库。\n\n在 Docker 中，镜像是根据配置文件 Dockerfile 构建的。通过以下命令可以执行构建的工作：\n\n```bash\n# docker build -t <镜像名称> <构建目录>\n$ docker build -t totorox-admin .\n```\n\n`-t` 表示将镜像命名为 `totorox-admin`。\n\n### 前端项目\n\n如下图所示为前端项目镜像的配置文件：\n\n![Dockerfile in Frontend Project](http://img.mrsingsing.com/frontend-dockerfile.png)\n\n在 Dockerfile 中 `FROM` 指令是必然存在的并且作为构建的开头，该指令初始化一个新的构建阶段（也就是有多少个 `FROM` 指令就有多少个镜像构建阶段）并为后续指令设置基础映像。\n\n`COPY` 指令表示拷贝资源至镜像内部，这里有个优化的小技巧，就是在项目根目录添加 `.dockerignore` 文件，与 `.gitignore` 或 `.npmignore` 类似，添加到该文件下的目录 Docker 构建镜像时将忽略其中的文件。我们可以把只用于代码开发阶段或者规范性的文件排除在构建之外，例如 `.vscode`、`.eslint`、`dist` 等。\n\n接下来就是常规的安装依赖、项目构建打包的指令，`npm install` 可以指定为淘宝镜像，在国内的话下载速度相对有保障，能够缩减镜像的构建时间。\n\n类似地，由于我们的项目中使用到了 Sass 预编译，Webpack 打包需要用到 `node-sass` 插件，每次都必须下载 `win32-x64-57_binding.node` 文件，所以要不需要漫长的等待（因为从国外源仓库下载），要不下载失败报一系列的错。幸好它提供了人性化的配置，可以通过环境变量改变下载的地址。我们在 `.npmrc` 中将一些依赖包中需要额外下载的文件的链接地址的环境变量指定为国内的镜像地址。当然啦并非所有依赖包都支持这样做，有些写死了下载地址是无法通过这样的方法优化的。除了上面提到的 `node-sass`，其余可以在 [淘宝镜像](https://developer.aliyun.com/mirror/NPM?from=tnpm) 找到对应的镜像地址，后面会提到的页面爬虫项目中使用的 `phantomjs` 也是通过这种方式大幅度压缩了构建时间。\n\n![.npmrc配置文件](http://img.mrsingsing.com/npmrc.jpg)\n\n第二阶段我们从镜像仓库获取 Nginx 镜像。一般地，前端项目构建打包后生成静态资源文件，需要 Web 代理服务器进行请求转发，我们这里用的是 Nginx，当然也可以用 Express 实现一个 Web 服务作为代理转发。\n\nNginx 配置和使用相对来说比较简单，通过简单的配置即可拥有高性能和高可用性，下面是 Nginx 的示例配置：\n\n![Nginx配置](http://img.mrsingsing.com/nginx-conf.png)\n\n在该阶段中，主要是将第一阶段生成的产物转移到第二阶段，这是因为镜像最终的启动指令 `CMD` 是在第二阶段，而且分阶段的镜像构建能够使得最终容器内只需放置打包后的静态资源文件即可，不用包含源代码文件，镜像的体积也会因此而大幅度缩减，在某种程度也确保了源代码的不对外泄漏。\n\n最终 `CMD` 命令是容器运行时在内部执行的指令。考虑到不同使用者的 API 服务器域名是不同的是动态变化的，在源代码中把 API 域名写死显然是个不明智的做法。因此，我们通过在运行容器时的环境变量植入写好的 Shell 脚本，通过 Shell 脚本生成包含域名等信息的 JavaScript 文件，HTML 文档通过写好的外链该脚本文件实现加载，这样即可满足动态域名变更的需求。\n\n在镜像构建过程中，如果细心观察打印的日志，会发现有这么一句：\n\n![移除中间容器](http://img.mrsingsing.com/removeing-intermediate-container.jpg)\n\n其实从构建的日志中可以看到，实质上镜像构建的每个指令都会生成一个临时的中间容器，每层中间容器都是以前面一层中间容器为基础的。当对应的指令执行完毕后，对应层级就不会再发生改变，会移除该临时创建的中间容器，然后再进行下一个指令操作。\n\n构建成功后，在命令行中输入 `docker images` 即可查看当前宿主机的 Docker 镜像列表：\n\n![容器镜像](http://img.mrsingsing.com/docker-images.jpg)\n\n由于我们的项目所需要的镜像在公司内部有私有仓库，所以构建时速度有一定的保障，如果是个人开发者在自己的服务器上构建镜像可能需要从公有仓库例如 Docker Hub 拉取所需要的镜像，这里提供一个优化的手段，可以通过修改 Docker Daemon 配置 `/etc/docker/daemon.json` 的镜像地址，实现镜像的加速，Docker 官方和国内很多云服务器平台都提供了国内的加速服务。\n\n🌰 **示例：**\n\n这里提供的镜像地址仅供参考，可以到对应的云服务商找到对应的镜像加速地址。\n\n![镜像加速](http://img.mrsingsing.com/docker-image-acceleration.png)\n\n除此之外，在使用 Docker 构建部署应用前最好确认好 Docker 的版本，例如 CentOS 7 系统默认的 Docker 版本是 13，而 `FROM AS` 的语法则需要 Docker 版本 17 以上才支持，这个时候需要先对宿主机的 Docker 进行版本更新。\n\n安装最新版本的 Docker 可以参考：\n\n[CentOS 安装最新版本的 Docker](https://www.jianshu.com/p/2e208721aa39)\n\n升级 Docker 后重启容器出现错误 `Unknown runtime specified docker runc` 的解决方案：\n\n```bash\n$ grep -rl 'docker-runc' /var/lib/docker/containers/ | xargs sed -i 's/docker-runc/runc/g'\n\n$ systemctl stop docker\n\n$ systemctl start docker\n```\n\n### 服务端项目\n\n接下来我们看看用 Koa 搭建的服务端项目如何部署，类似操作指令就不再重复赘述了，主要谈谈需要注意的地方。\n\n![服务端Dockerfile](http://img.mrsingsing.com/backend-dockerfile.png)\n\n因为项目中通过开启子进程的方式执行 Webpack 命令进行页面的生成，因此我们需要在容器内全局安装 Webpack。\n\n我们看到这里为一个名为 `wait-for-it.sh` 的提供了可执行的权限，而且在后续的 `CMD` 指令中先执行了该脚本文件。应用容器化后，Docker 容器启动时，默认使用非 root 用户执行命令，所以应用内的脚本文件无法正常执行，这时候就需要执行 `chmod a+x` 为脚本文件提供可执行的权限。至于这个脚本的存在意义我们在后面容器通讯的部分再详细说明，暂且跳过。\n\n下面我们谈谈 Dockerfile 中的输入参数 `ARG`、环境变量 `ENV` 以及如何将 Dockerfile 中的环境变量/传入参数在 `CMD` 指令中的使用。\n\n指令 `ARG` 定义一个变量，用户可以在使用 `docker build` 命令使用 `--build-arg <varname>=<value>` 标志，在构建时将其传递给构建器。\n\n```dockerfile\nARG env\n\n# 指定默认值\nARG env=local\n```\n\n如果 `ARG` 对应的值有缺省值，并且如果在构建时没有传递值，则构建器使用缺省值。\n\nDockerfile 的 `ENV` 指令有两种书写方式：\n\n```dockerfile\nENV <key> <value>\n\n# 这种写法键/值与等号之间不能存在空格\nENV <key>=<value>\n\n# 通过斜杠 \\ 换行一次性声明多个环境变量\nENV API_URL=example.com \\\n    NODE_ENV=production \\\n    COMMAND=dev\n```\n\n与 `ARG` 指令对比，`ENV` 始终存在于镜像当中，而 `ARG` 仅在执行时存在。\n\n关于 dockerfile 中的环境变量替换可以阅读官方文档中有关 [环境变量替换](https://docs.docker.com/engine/reference/builder/#environment-replacement) 的相关章节。\n\n`CMD` 指令有三种书写方式：\n\n```dockerfile\n# 使用 exec 执行，这类格式在解析时会被解析成 JSON 数组，因此一定要使用双引号\nCMD [\"command\", \"instructions\", \"options\"]\n\n# 使用 /bin/sh 中执行，提供给需要交互的应用\n# 实际命令会被包装为 sh -c 的参数形式进行执行\nCMD command param1 param2\n```\n\n指定启动容器时执行命令，每个 Dockerfile 只能有一个 `CMD` 指令。如果指定了多条命令，则只有最后一条会被执行。如果用户启动容器时指定了运行的命令，则会覆盖掉 `CMD` 指定的命令。\n\n在我们的项目中，除了前面谈过的前端项目需要将 API 域名等在 Docker 运行初期动态植入外，服务端项目也需要传入数据库相关的信息。经过实验发现，`exec` 形式的 `CMD` 是通过 Docker 来运行命令的，并不支持参数替换。而 `shell` 形式的 `CMD` 则是通过 Docker 来运行 `sh`，`sh` 再运行我们写的命令，而 `sh` 是支持参数替换的。\n\n所以如果想将 Dockerfile 中的环境变量 `ENV` 或参数 `ARG` 在 `CMD` 指令中使用，就需要采用 `shell` 的形式书写启动命令。\n\n```dockerfile\n# docker run 后添加的参数传入\nARG env=production\n\n# 从执行 shell 命令的执行环境中读取 ENV 变量作为 dockerfile 中的 env 变量值\nENV env=${ENV}\n\n# 启动命令是执行脚本 /scripts/setup.sh\n# 该脚本需要传入环境变量 env，也就是 dockerfile 中定义的变量\nCMD /scripts/setup.sh ${env}\n```\n\n### 爬虫项目\n\n接着我们谈谈页面爬虫项目的镜像构建。\n\n由于龙猫 X 主要用于移动端营销活动，页面的加载体验对用户转化率起到至关重要的作用，因此发布页面都经由无头浏览器爬取发布页面的首屏渲染的 HTML 文档以缩减页面的白屏时间。\n\n在 Linux 系统中使用 PhantomJS 需要从源代码仓库中拉取整包，下载速度因众所周知的原因非常慢，所以这里改用阿里国内的镜像作为下载地址，后续经过一系列解压缩、移动文件、建立软链接等，在容器内能够直接通过命令行执行 PhantomJS 的相关命令。\n\n前面提及每个指令都是新的构建层，所以这里也是通过管道连接的方式实现一连串的操作，这种方式是很好的压缩镜像体积的方法。\n\n![爬虫项目 Dockerfile](http://img.mrsingsing.com/spider-dockerfile.png)\n\n### 数据库项目\n\n下面需要对 MongoDB 数据库实现容器化管理。先给大家看看 MongoDB 数据库的 Dockerfile 文件：\n\n![](http://img.mrsingsing.com/mongodb-dockerfile.png)\n\n由于独立部署版本的龙猫 X 在初始化时需要导入默认的数据，例如组件数据、组件类型数据、标签数据、页面类型数据等。我们从已有的项目中导出数据并进行适当修正后，将数据文件保存到项目指定默认数据的目录下，在 Dockerfile 中指定 `RUN` 通过下面的 shell 脚本对数据库进行初始化，并向数据库中导入数据。\n\n![MongoDB 初始化脚本](http://img.mrsingsing.com/docker-entrypoint-initdb.png)\n\n为了提高数据库的扩展性，数据库的用户名、密码、名称可以通过环境变量的方式进行设置，方便不同的团队根据自身需求修改。\n\n我们将四个项目分别通过 `docker build` 命令构建独立的镜像后，通过命令 `docker images` 能够查看到所有已构建的镜像列表，通过 `docker history <image-id>` 命令能够查看镜像构建过程中的细节：包括每层指令执行的指令、构建后的产物占镜像的体积大小等，通过分析构建历史能够让我们掌握依据对 Dockerfile 进行优化。\n\n![容器构建历史](http://img.mrsingsing.com/docker-history.jpg)\n\n除此之外，构建好的镜像需要持久化保存的话，需要 `docker tag` 打标签并 `docker push` 到远程仓库中进行保存。\n\n## 容器互联\n\n我们知道服务端项目运行时是需要与数据库保持连接的，那么 Docker 是否提供某种机制让不同容器之间进行通信呢？\n\n当 Docker 启动时，实际上会自动在宿主机上创建一个 `docker0` 虚拟网桥，相当于 Linux 上的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。\n\n![容器互联](http://img.mrsingsing.com/docker-network.png)\n\n回到我们的需求上，我们需要将服务端项目、数据库项目和爬虫项目包裹在一个网络当中，也就是建立这三个项目对应容器的“局域网”。将容器加入指定的局域网其实很简单，talk is cheap，show you the code：\n\n```bash\n# 创建虚拟局域网 `totorox-net` 是该局域网的名称\ndocker network create -d bridge totorox-net\n\n# 启动容器时带上 `--network <你创建的局域网名称>` 即可加入到指定的局域网内\ndocker run -d --name totorox-server -p 3012:3012 --network totorox-net ...\n```\n\n以此类推在对应的容器启动时也加入局域网内，那么局域网内的容器之间就能够通过加入局域网时随机分配的域名进行访问。\n\n<!-- ![docker network ls 查询 docker]() -->\n\n那么问题来了，从服务端容器的角度出发，怎么知道数据库容器的域名是 `xxx.xxx.xxx.xxx` 呢，总不能每次启动后 `docker network ls` 查看容器分配到的局域网域名，然后再到对应的容器内部进行修改，这显然不太科学。\n\ndocker 作为广泛使用的技术，其开源团队显然不会犯如此低级的设计错误。实际上，除了运行容器时将容器加入局域网外，为容器命名也是必不可少的步骤。容器名称类比来理解，相当于我们需要申请购买域名以替代 IP 地址一样，一般用户只需要记住辨识度高的网站地址，访问时通过 DNS 解析到 IP 地址再对服务器进行访问，这里 docker 容器互联的原理是高度类似的，局域网内直接访问容器名称也能解析到对应的容器当中并进行访问。\n\n多说无益，我们看看如何在服务端项目中用 Mongoose 连接数据库容器的 MongoDB：\n\n```js\n// username 为数据库账户名称\n// password 为数据库账户密码\n// containerName 为数据库项目容器的名称\n// databaseName 为数据库名称\nconst uri = `mongodb://${username}:${password}@${containerName}/${databaseName}`;\n\nmongoose.connect(uri, {\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n  autoIndex: false,\n});\n```\n\n这里踩了不少坑，Mongoose 连接 MongoDB 的域名使用容器名称作为标识，而非使用随机分配的固定 IP 地址，或容器网络的名称。\n\n除此之外，很多中文文章中都没有提到一个遇上机率比较大的坑，就是服务端是需要等待 MongoDB 数据库启动并就绪后，才能连接成功的。\n\n在使用 `docker run` 方式启动容器时要先启动 MongoDB 的容器，再启动服务端项目的容器，两个启动命令执行需要有段时间差，不能执行前一个，马不停蹄地就执行下一个。这是因为 `docker run` 只是作为启动容器的起点，容器内部实际对外服务的数据库正在执行启动中，容器局域网内并不能第一时间对其进行访问，而是需要等待一段时候后暴露的端口才可接受外部请求。在容器外来看，`docker run` 命令执行后容器是启动了，但是内部实际提供服务的数据库还没准备就绪，这就有可能导致服务端项目连接数据库容器出现超时的问题发生。\n\n因此，我们需要对 mongoose 设立重连机制，当连接超时等情况出现时，也能自动对数据库进行重连操作。\n\n```js\nconst connect = () => {\n  mongoose.connect(uri, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n    autoIndex: false,\n  });\n};\ndb.on('error', error => {\n  console.error('Error in MongoDB connection:' + error);\n  mongoose.disconnect();\n});\ndb.on('disconnected', () => {\n  console.log('MongoDB disconnected!');\n  connect();\n});\ndb.on('close', () => {\n  console.log('Lost MongoDB connection...');\n  connect();\n  console.log('Reconnect to MongoDB, wait...');\n});\n```\n\n除了服务端内部进行数据库重连的保障外，后面会提到容器编排也会出现这样的情况，server 项目依赖 database 项目的启动，`docker-compose.yml` 中有个配置项是 `depends_on`，表示等待指定的容器启动后再进行当前容器的启动。在容器的角度来看，它只知道容器的是否已经启动，也可以理解为是否已经执行了 `docker run` 的命令，容器内部的项目是否启动，容器的管不着的，它也不知道，所以如果内部服务启动时间久于容器之间编排启动的时间，同时两者强依赖性质的，那么就会导致某方出现错误，这样的情况大部分出现在对数据库的连接上。\n\n可能由于接收到的反馈太多，官方文档中 [Control startup and shutdown order in Compose](https://docs.docker.com/compose/startup-order/) 也明确表示这个问题，它提供了几个轮训容器服务的解决方案，包括 [wait-for-it.sh](https://github.com/vishnubob/wait-for-it)、[dockerize](https://github.com/jwilder/dockerize) 和 [wait-for](https://github.com/Eficode/wait-for)。\n\n## 服务部署\n\n首先我们先部署好前端项目，前端项目容器内部执行 Nginx 命令启动代理服务器从而转发请求，如果按照前面所列的 Nginx 配置，理论上应该能顺利启动容器。\n\n不过这里也提一下实践中遇到的问题：\n\n```bash\n# 启动容器\n$ docker run -d --name totorox-admin -p 8200:80 hub.ppmoney.io/telescope/totorox-admin\nStarting nginx ... done\nAttating to nginx\n```\n\n就是执行完毕后，界面会一直停留在 `Attating to nginx`，没有报错也没有提示运行成功。\n\n这个问题，是由于容器内部 `/etc/nginx/conf.d/default.conf` 路径下的 `default.conf` 文件的缺失所导致，换句话说就是 Nginx 启动所需要执行的默认配置丢失了。在容器的层面分析，有可能是因为容器挂载了 `volumes`，而宿主机的 `conf.d` 目录下为空覆盖了容器内部对应目录下的文件，具体原因可以 `docker exec -it totorox-admin .` 进入容器内部检查。\n\n下面罗列了根据构建好的镜像在服务器上启动运行容器：\n\n![运行容器命令](http://img.mrsingsing.com/docker-run.png)\n\n容器启动后，可以输入 `docker ps -a` 查看宿主机上所有的容器列表。\n\n![查看宿主机容器列表](http://img.mrsingsing.com/docker-container-list.jpg)\n\n从上图可以表格中的 STATUS 和 PORTS 可以看出来，有三个容器已经启动，但是 MongoDB 的容器则启动失败了。\n\n查看日志 `docker logs <container-name>` 查看容器的运行日志，找到出错的原因（这里只是为了演示而出错，上述相关代码均验证有效）。\n\n这里可能会有些疑问，是否应该使用 PM2 等守护进程工具对进程进行守护呢？\n\n实际上容器中的应用都应该前台执行运行，而非后台执行，容器内没有后台服务的概念。对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义。 比如 `CMD service nginx start` 它等同于 `CMD [ \"bash\", \"-c\", \"service nginx start\"]` 主进程实际上是 `bash`，`bash` 也就结束了，`bash` 作为主进程退出了。因此在我们的镜像构建配置文件中，均直接开启服务而非通过 PM2 或 Forever 等工具开启。\n\n容器的启动相对比较简单，根据需要使用配置项即可快速启动/停止容器。但是，每次部署都需要输入一大串的命令，哪天忘记了哪个参数忘了传怎么办，命令的执行顺序调换了怎么，这个时候就需要一种容器编排的方式，让每次容器更新部署都能通过更简便的命令实现。\n\n## 容器编排\n\ndocker-compose 负责实现对 Docker 容器集群的快速编排。使用者通过 `docker-compose.yml` 模版文件定义一组关联的应用容器为一个项目。它默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。简单来说，就是把刚才一连串的命令利用静态的配置文件记录下来，启动容器只需通过 `docker compose up -d` 命令运行即可。\n\n![容器编排](http://img.mrsingsing.com/docker-compose.png)\n\n首先，我们需要注意 `docker-compose` 的版本问题，有的配置项是 version2.0 没有，而 version3.0 新增的，详情直接看官方文档 [Compose file versions and upgrading](https://docs.docker.com/compose/compose-file/compose-versioning/) 即可。\n\n`docker-compose.yml` 定义了启动容器名称、镜像地址、对外暴露的端口、环境变量、数据卷以及容器启动的先后顺序等。\n\n`docker-compose` 启动时会先获取本地镜像，如果本地已经有对应的镜像则会直接使用，如果本地没有找到，则会从远程仓库拉取到本地后再启动。\n\n`restart: always` 配置项可以让容器在内部服务挂掉的时候，自动重新启动内部服务。\n\n仓库公开的代码应该需要对文件进行脱敏，也就是将配置文件（包括登录数据库的用户名密码等）排除公开的文件列表中。\n\n```bash\n$ docker run -e VARIABLE1 --env VARIABLE2=foo --env-file ./env.list ubuntu bash\n```\n\n---\n\n**参考资料：**\n\n- [Passing variables to Docker](https://docs.docker.com/engine/reference/commandline/run/#set-environment-variables--e---env---env-file)\n- [Pass Docker Environment Variables During The Image Build](https://vsupalov.com/docker-build-pass-environment-variables/)\n- [How To Pass Environment Info During Docker Builds](https://blog.bitsrc.io/how-to-pass-environment-info-during-docker-builds-1f7c5566dd0e)\n- [How to setup Node environment variable in Dockerfile for running node.js application?](https://stackoverflow.com/questions/42992397/how-to-setup-node-environment-variable-in-dockerfile-for-running-node-js-applica)\n- [How to create a Node App within a Docker container with Mongo](https://hn.werick.codes/how-to-create-a-node-app-within-a-docker-container-with-mongo-cjwjd3l4t00067rs18w7035oc)\n- [Cannot connect from node to mongo replicaset in docker](http://quabr.com/57123227/cannot-connect-from-node-to-mongo-replicaset-in-docker)\n- [Docker Node 项目连接 MongoDB](https://blog.csdn.net/weixin_30466953/article/details/97366689)\n- [升级 Docker 后重启容器出现错误 Unknown runtime specified docker-runc](https://blog.csdn.net/wxb880114/article/details/88869215)\n- [Mongoose 远程连接 MongoDB，当客户端断开网络重连时报错 topology was destoryed？](https://segmentfault.com/q/1010000010768993)\n- [这可能是网络上唯一一篇给前端写的 Docker+Node+Nginx+MongoDB 的本地开发+部署实战](https://juejin.im/post/5ddb3f85e51d45231576af3c)\n","slug":"docker-deploy-pratice","published":1,"updated":"2021-08-18T03:29:19.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99yy0009v31p0crbfq3t","content":"<p>在人类社会大分工越来越精细的大背景下，各式各样的软件技术公司层出不穷，为各行各业提供着或大众化或具有特色的软件服务，大部分软件服务是公有性质的，也就是这些服务提供商内部单独的运营软件平台，使用者获取软件使用权后在其平台生产内容，并由服务商提供数据存储服务，这种性质的平台对于软件开发商来说需要考虑数据的隔离，对于使用者来说则减少了维护成本，但是数据并非私自存储无法确保安全性。而相对于公有性软件服务的就是私有化软件服务，这类型产品提供可部署至客户私自的服务器上的版本，数据由客户自身存储，某种程度上保证的了数据的安全性。</p>\n<p>在 PPmoney 内部，龙猫 X 配置平台提供给理财及借贷两个技术团队使用，对于页面、模版、组件、素材都需要在公共空间进行共享存储，而现有的人员权限机制无法对这些要素进行筛选区分，无可避免出现管理混乱的局面。而根据不同的团队、不同的部署环境进行系统部署也是需求的关注点。考虑到对数据的隔离，以及未来龙猫 X 作为软件服务对外提供商业性质的服务，为龙猫 X 增强可独立部署的功能的事宜即提上开发的日程。</p>\n<p>在对龙猫 X 的独立部署的技术选型上我们选择了 Docker 容器化技术。之所以选择 Docker 是因为容器技术对进程进行封装隔离，能够高效地在利用服务器资源以及便捷地在多平台间进行迁移。</p>\n<p>在这篇文章中我尝试把容器化改造过程中遇到的坑位记录下来为后人提供借鉴，也是对整个坎坷的过程的记录。</p>\n<a id=\"more\"></a>\n<h2 id=\"容器化技术\"><a href=\"#容器化技术\" class=\"headerlink\" title=\"容器化技术\"></a>容器化技术</h2><p>容器技术对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此称为容器。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-in-server.png\" alt=\"服务器中的容器\"></p>\n<p>Docker 容器化技术关键核心只需要掌握三个概念：</p>\n<ul>\n<li>镜像 Image</li>\n<li>容器 Container</li>\n<li>仓库 Repository</li>\n</ul>\n<p>从小白的角度理解的话可以把 <strong>镜像</strong> 和 <strong>容器</strong> 类比为面向对象编程中的类和实例，镜像是静态的定义，而容器则是镜像运行时的形态。我们可以把容器想像成包装盒，包装盒里装载着一个微型操作系统，其内部运行着我们的应用程序。</p>\n<p>仓库则是存放镜像的地方，可以为镜像打 tag（标签），就好像我们为 git commit 打版本号的 tag 一样，使用者可以根据需要选择版本部署，程序故障时也能立马根据版本进行回滚。</p>\n<p>Docker Hub 是 Docker 官方的公开的仓库，私有仓库则有 Harbor，商业化的容器服务提供商有阿里云、Dao Cloud 等。我们公司采用的是内部自建的 Harbor 仓库。</p>\n<p>因为本篇文章非科普性质，所以对于 Docker 的介绍就不过于深入叙述，有兴趣可以搜索相关文章进行研究，当然首推还是把 <a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\">官方文档</a> 看一遍，毕竟第一手资料才是最具参考价值的。</p>\n<h2 id=\"镜像制作\"><a href=\"#镜像制作\" class=\"headerlink\" title=\"镜像制作\"></a>镜像制作</h2><p>对龙猫 X 进行容器化改造需要部署四个子项目，分别是 React 全家桶的客户端项目、Koa 服务端项目、页面爬虫项目以及 MongoDB 数据库。</p>\n<p>在 Docker 中，镜像是根据配置文件 Dockerfile 构建的。通过以下命令可以执行构建的工作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker build -t &lt;镜像名称&gt; &lt;构建目录&gt;</span></span><br><span class=\"line\">$ docker build -t totorox-admin .</span><br></pre></td></tr></table></figure>\n<p><code>-t</code> 表示将镜像命名为 <code>totorox-admin</code>。</p>\n<h3 id=\"前端项目\"><a href=\"#前端项目\" class=\"headerlink\" title=\"前端项目\"></a>前端项目</h3><p>如下图所示为前端项目镜像的配置文件：</p>\n<p><img src=\"http://img.mrsingsing.com/frontend-dockerfile.png\" alt=\"Dockerfile in Frontend Project\"></p>\n<p>在 Dockerfile 中 <code>FROM</code> 指令是必然存在的并且作为构建的开头，该指令初始化一个新的构建阶段（也就是有多少个 <code>FROM</code> 指令就有多少个镜像构建阶段）并为后续指令设置基础映像。</p>\n<p><code>COPY</code> 指令表示拷贝资源至镜像内部，这里有个优化的小技巧，就是在项目根目录添加 <code>.dockerignore</code> 文件，与 <code>.gitignore</code> 或 <code>.npmignore</code> 类似，添加到该文件下的目录 Docker 构建镜像时将忽略其中的文件。我们可以把只用于代码开发阶段或者规范性的文件排除在构建之外，例如 <code>.vscode</code>、<code>.eslint</code>、<code>dist</code> 等。</p>\n<p>接下来就是常规的安装依赖、项目构建打包的指令，<code>npm install</code> 可以指定为淘宝镜像，在国内的话下载速度相对有保障，能够缩减镜像的构建时间。</p>\n<p>类似地，由于我们的项目中使用到了 Sass 预编译，Webpack 打包需要用到 <code>node-sass</code> 插件，每次都必须下载 <code>win32-x64-57_binding.node</code> 文件，所以要不需要漫长的等待（因为从国外源仓库下载），要不下载失败报一系列的错。幸好它提供了人性化的配置，可以通过环境变量改变下载的地址。我们在 <code>.npmrc</code> 中将一些依赖包中需要额外下载的文件的链接地址的环境变量指定为国内的镜像地址。当然啦并非所有依赖包都支持这样做，有些写死了下载地址是无法通过这样的方法优化的。除了上面提到的 <code>node-sass</code>，其余可以在 <a href=\"https://developer.aliyun.com/mirror/NPM?from=tnpm\" target=\"_blank\" rel=\"noopener\">淘宝镜像</a> 找到对应的镜像地址，后面会提到的页面爬虫项目中使用的 <code>phantomjs</code> 也是通过这种方式大幅度压缩了构建时间。</p>\n<p><img src=\"http://img.mrsingsing.com/npmrc.jpg\" alt=\".npmrc配置文件\"></p>\n<p>第二阶段我们从镜像仓库获取 Nginx 镜像。一般地，前端项目构建打包后生成静态资源文件，需要 Web 代理服务器进行请求转发，我们这里用的是 Nginx，当然也可以用 Express 实现一个 Web 服务作为代理转发。</p>\n<p>Nginx 配置和使用相对来说比较简单，通过简单的配置即可拥有高性能和高可用性，下面是 Nginx 的示例配置：</p>\n<p><img src=\"http://img.mrsingsing.com/nginx-conf.png\" alt=\"Nginx配置\"></p>\n<p>在该阶段中，主要是将第一阶段生成的产物转移到第二阶段，这是因为镜像最终的启动指令 <code>CMD</code> 是在第二阶段，而且分阶段的镜像构建能够使得最终容器内只需放置打包后的静态资源文件即可，不用包含源代码文件，镜像的体积也会因此而大幅度缩减，在某种程度也确保了源代码的不对外泄漏。</p>\n<p>最终 <code>CMD</code> 命令是容器运行时在内部执行的指令。考虑到不同使用者的 API 服务器域名是不同的是动态变化的，在源代码中把 API 域名写死显然是个不明智的做法。因此，我们通过在运行容器时的环境变量植入写好的 Shell 脚本，通过 Shell 脚本生成包含域名等信息的 JavaScript 文件，HTML 文档通过写好的外链该脚本文件实现加载，这样即可满足动态域名变更的需求。</p>\n<p>在镜像构建过程中，如果细心观察打印的日志，会发现有这么一句：</p>\n<p><img src=\"http://img.mrsingsing.com/removeing-intermediate-container.jpg\" alt=\"移除中间容器\"></p>\n<p>其实从构建的日志中可以看到，实质上镜像构建的每个指令都会生成一个临时的中间容器，每层中间容器都是以前面一层中间容器为基础的。当对应的指令执行完毕后，对应层级就不会再发生改变，会移除该临时创建的中间容器，然后再进行下一个指令操作。</p>\n<p>构建成功后，在命令行中输入 <code>docker images</code> 即可查看当前宿主机的 Docker 镜像列表：</p>\n<p><img src=\"http://img.mrsingsing.com/docker-images.jpg\" alt=\"容器镜像\"></p>\n<p>由于我们的项目所需要的镜像在公司内部有私有仓库，所以构建时速度有一定的保障，如果是个人开发者在自己的服务器上构建镜像可能需要从公有仓库例如 Docker Hub 拉取所需要的镜像，这里提供一个优化的手段，可以通过修改 Docker Daemon 配置 <code>/etc/docker/daemon.json</code> 的镜像地址，实现镜像的加速，Docker 官方和国内很多云服务器平台都提供了国内的加速服务。</p>\n<p>🌰 <strong>示例：</strong></p>\n<p>这里提供的镜像地址仅供参考，可以到对应的云服务商找到对应的镜像加速地址。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-image-acceleration.png\" alt=\"镜像加速\"></p>\n<p>除此之外，在使用 Docker 构建部署应用前最好确认好 Docker 的版本，例如 CentOS 7 系统默认的 Docker 版本是 13，而 <code>FROM AS</code> 的语法则需要 Docker 版本 17 以上才支持，这个时候需要先对宿主机的 Docker 进行版本更新。</p>\n<p>安装最新版本的 Docker 可以参考：</p>\n<p><a href=\"https://www.jianshu.com/p/2e208721aa39\" target=\"_blank\" rel=\"noopener\">CentOS 安装最新版本的 Docker</a></p>\n<p>升级 Docker 后重启容器出现错误 <code>Unknown runtime specified docker runc</code> 的解决方案：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ grep -rl <span class=\"string\">'docker-runc'</span> /var/lib/docker/containers/ | xargs sed -i <span class=\"string\">'s/docker-runc/runc/g'</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ systemctl stop docker</span><br><span class=\"line\"></span><br><span class=\"line\">$ systemctl start docker</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务端项目\"><a href=\"#服务端项目\" class=\"headerlink\" title=\"服务端项目\"></a>服务端项目</h3><p>接下来我们看看用 Koa 搭建的服务端项目如何部署，类似操作指令就不再重复赘述了，主要谈谈需要注意的地方。</p>\n<p><img src=\"http://img.mrsingsing.com/backend-dockerfile.png\" alt=\"服务端Dockerfile\"></p>\n<p>因为项目中通过开启子进程的方式执行 Webpack 命令进行页面的生成，因此我们需要在容器内全局安装 Webpack。</p>\n<p>我们看到这里为一个名为 <code>wait-for-it.sh</code> 的提供了可执行的权限，而且在后续的 <code>CMD</code> 指令中先执行了该脚本文件。应用容器化后，Docker 容器启动时，默认使用非 root 用户执行命令，所以应用内的脚本文件无法正常执行，这时候就需要执行 <code>chmod a+x</code> 为脚本文件提供可执行的权限。至于这个脚本的存在意义我们在后面容器通讯的部分再详细说明，暂且跳过。</p>\n<p>下面我们谈谈 Dockerfile 中的输入参数 <code>ARG</code>、环境变量 <code>ENV</code> 以及如何将 Dockerfile 中的环境变量/传入参数在 <code>CMD</code> 指令中的使用。</p>\n<p>指令 <code>ARG</code> 定义一个变量，用户可以在使用 <code>docker build</code> 命令使用 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 标志，在构建时将其传递给构建器。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ARG</span> <span class=\"keyword\">env</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定默认值</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> <span class=\"keyword\">env</span>=local</span><br></pre></td></tr></table></figure>\n<p>如果 <code>ARG</code> 对应的值有缺省值，并且如果在构建时没有传递值，则构建器使用缺省值。</p>\n<p>Dockerfile 的 <code>ENV</code> 指令有两种书写方式：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这种写法键/值与等号之间不能存在空格</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> &lt;key&gt;=&lt;value&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过斜杠 \\ 换行一次性声明多个环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> API_URL=example.com \\</span><br><span class=\"line\">    NODE_ENV=production \\</span><br><span class=\"line\">    COMMAND=dev</span><br></pre></td></tr></table></figure>\n<p>与 <code>ARG</code> 指令对比，<code>ENV</code> 始终存在于镜像当中，而 <code>ARG</code> 仅在执行时存在。</p>\n<p>关于 dockerfile 中的环境变量替换可以阅读官方文档中有关 <a href=\"https://docs.docker.com/engine/reference/builder/#environment-replacement\" target=\"_blank\" rel=\"noopener\">环境变量替换</a> 的相关章节。</p>\n<p><code>CMD</code> 指令有三种书写方式：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 exec 执行，这类格式在解析时会被解析成 JSON 数组，因此一定要使用双引号</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"command\"</span>, <span class=\"string\">\"instructions\"</span>, <span class=\"string\">\"options\"</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 /bin/sh 中执行，提供给需要交互的应用</span></span><br><span class=\"line\"><span class=\"comment\"># 实际命令会被包装为 sh -c 的参数形式进行执行</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> <span class=\"built_in\">command</span> param1 param2</span></span><br></pre></td></tr></table></figure>\n<p>指定启动容器时执行命令，每个 Dockerfile 只能有一个 <code>CMD</code> 指令。如果指定了多条命令，则只有最后一条会被执行。如果用户启动容器时指定了运行的命令，则会覆盖掉 <code>CMD</code> 指定的命令。</p>\n<p>在我们的项目中，除了前面谈过的前端项目需要将 API 域名等在 Docker 运行初期动态植入外，服务端项目也需要传入数据库相关的信息。经过实验发现，<code>exec</code> 形式的 <code>CMD</code> 是通过 Docker 来运行命令的，并不支持参数替换。而 <code>shell</code> 形式的 <code>CMD</code> 则是通过 Docker 来运行 <code>sh</code>，<code>sh</code> 再运行我们写的命令，而 <code>sh</code> 是支持参数替换的。</p>\n<p>所以如果想将 Dockerfile 中的环境变量 <code>ENV</code> 或参数 <code>ARG</code> 在 <code>CMD</code> 指令中使用，就需要采用 <code>shell</code> 的形式书写启动命令。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker run 后添加的参数传入</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> <span class=\"keyword\">env</span>=production</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从执行 shell 命令的执行环境中读取 ENV 变量作为 dockerfile 中的 env 变量值</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> <span class=\"keyword\">env</span>=$&#123;<span class=\"keyword\">ENV</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动命令是执行脚本 /scripts/setup.sh</span></span><br><span class=\"line\"><span class=\"comment\"># 该脚本需要传入环境变量 env，也就是 dockerfile 中定义的变量</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> /scripts/setup.sh <span class=\"variable\">$&#123;env&#125;</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"爬虫项目\"><a href=\"#爬虫项目\" class=\"headerlink\" title=\"爬虫项目\"></a>爬虫项目</h3><p>接着我们谈谈页面爬虫项目的镜像构建。</p>\n<p>由于龙猫 X 主要用于移动端营销活动，页面的加载体验对用户转化率起到至关重要的作用，因此发布页面都经由无头浏览器爬取发布页面的首屏渲染的 HTML 文档以缩减页面的白屏时间。</p>\n<p>在 Linux 系统中使用 PhantomJS 需要从源代码仓库中拉取整包，下载速度因众所周知的原因非常慢，所以这里改用阿里国内的镜像作为下载地址，后续经过一系列解压缩、移动文件、建立软链接等，在容器内能够直接通过命令行执行 PhantomJS 的相关命令。</p>\n<p>前面提及每个指令都是新的构建层，所以这里也是通过管道连接的方式实现一连串的操作，这种方式是很好的压缩镜像体积的方法。</p>\n<p><img src=\"http://img.mrsingsing.com/spider-dockerfile.png\" alt=\"爬虫项目 Dockerfile\"></p>\n<h3 id=\"数据库项目\"><a href=\"#数据库项目\" class=\"headerlink\" title=\"数据库项目\"></a>数据库项目</h3><p>下面需要对 MongoDB 数据库实现容器化管理。先给大家看看 MongoDB 数据库的 Dockerfile 文件：</p>\n<p><img src=\"http://img.mrsingsing.com/mongodb-dockerfile.png\" alt></p>\n<p>由于独立部署版本的龙猫 X 在初始化时需要导入默认的数据，例如组件数据、组件类型数据、标签数据、页面类型数据等。我们从已有的项目中导出数据并进行适当修正后，将数据文件保存到项目指定默认数据的目录下，在 Dockerfile 中指定 <code>RUN</code> 通过下面的 shell 脚本对数据库进行初始化，并向数据库中导入数据。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-entrypoint-initdb.png\" alt=\"MongoDB 初始化脚本\"></p>\n<p>为了提高数据库的扩展性，数据库的用户名、密码、名称可以通过环境变量的方式进行设置，方便不同的团队根据自身需求修改。</p>\n<p>我们将四个项目分别通过 <code>docker build</code> 命令构建独立的镜像后，通过命令 <code>docker images</code> 能够查看到所有已构建的镜像列表，通过 <code>docker history &lt;image-id&gt;</code> 命令能够查看镜像构建过程中的细节：包括每层指令执行的指令、构建后的产物占镜像的体积大小等，通过分析构建历史能够让我们掌握依据对 Dockerfile 进行优化。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-history.jpg\" alt=\"容器构建历史\"></p>\n<p>除此之外，构建好的镜像需要持久化保存的话，需要 <code>docker tag</code> 打标签并 <code>docker push</code> 到远程仓库中进行保存。</p>\n<h2 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h2><p>我们知道服务端项目运行时是需要与数据库保持连接的，那么 Docker 是否提供某种机制让不同容器之间进行通信呢？</p>\n<p>当 Docker 启动时，实际上会自动在宿主机上创建一个 <code>docker0</code> 虚拟网桥，相当于 Linux 上的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-network.png\" alt=\"容器互联\"></p>\n<p>回到我们的需求上，我们需要将服务端项目、数据库项目和爬虫项目包裹在一个网络当中，也就是建立这三个项目对应容器的“局域网”。将容器加入指定的局域网其实很简单，talk is cheap，show you the code：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建虚拟局域网 `totorox-net` 是该局域网的名称</span></span><br><span class=\"line\">docker network create -d bridge totorox-net</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器时带上 `--network &lt;你创建的局域网名称&gt;` 即可加入到指定的局域网内</span></span><br><span class=\"line\">docker run -d --name totorox-server -p 3012:3012 --network totorox-net ...</span><br></pre></td></tr></table></figure>\n<p>以此类推在对应的容器启动时也加入局域网内，那么局域网内的容器之间就能够通过加入局域网时随机分配的域名进行访问。</p>\n<!-- ![docker network ls 查询 docker]() -->\n<p>那么问题来了，从服务端容器的角度出发，怎么知道数据库容器的域名是 <code>xxx.xxx.xxx.xxx</code> 呢，总不能每次启动后 <code>docker network ls</code> 查看容器分配到的局域网域名，然后再到对应的容器内部进行修改，这显然不太科学。</p>\n<p>docker 作为广泛使用的技术，其开源团队显然不会犯如此低级的设计错误。实际上，除了运行容器时将容器加入局域网外，为容器命名也是必不可少的步骤。容器名称类比来理解，相当于我们需要申请购买域名以替代 IP 地址一样，一般用户只需要记住辨识度高的网站地址，访问时通过 DNS 解析到 IP 地址再对服务器进行访问，这里 docker 容器互联的原理是高度类似的，局域网内直接访问容器名称也能解析到对应的容器当中并进行访问。</p>\n<p>多说无益，我们看看如何在服务端项目中用 Mongoose 连接数据库容器的 MongoDB：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// username 为数据库账户名称</span></span><br><span class=\"line\"><span class=\"comment\">// password 为数据库账户密码</span></span><br><span class=\"line\"><span class=\"comment\">// containerName 为数据库项目容器的名称</span></span><br><span class=\"line\"><span class=\"comment\">// databaseName 为数据库名称</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> uri = <span class=\"string\">`mongodb://<span class=\"subst\">$&#123;username&#125;</span>:<span class=\"subst\">$&#123;password&#125;</span>@<span class=\"subst\">$&#123;containerName&#125;</span>/<span class=\"subst\">$&#123;databaseName&#125;</span>`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">mongoose.connect(uri, &#123;</span><br><span class=\"line\">  useNewUrlParser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  useUnifiedTopology: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  autoIndex: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里踩了不少坑，Mongoose 连接 MongoDB 的域名使用容器名称作为标识，而非使用随机分配的固定 IP 地址，或容器网络的名称。</p>\n<p>除此之外，很多中文文章中都没有提到一个遇上机率比较大的坑，就是服务端是需要等待 MongoDB 数据库启动并就绪后，才能连接成功的。</p>\n<p>在使用 <code>docker run</code> 方式启动容器时要先启动 MongoDB 的容器，再启动服务端项目的容器，两个启动命令执行需要有段时间差，不能执行前一个，马不停蹄地就执行下一个。这是因为 <code>docker run</code> 只是作为启动容器的起点，容器内部实际对外服务的数据库正在执行启动中，容器局域网内并不能第一时间对其进行访问，而是需要等待一段时候后暴露的端口才可接受外部请求。在容器外来看，<code>docker run</code> 命令执行后容器是启动了，但是内部实际提供服务的数据库还没准备就绪，这就有可能导致服务端项目连接数据库容器出现超时的问题发生。</p>\n<p>因此，我们需要对 mongoose 设立重连机制，当连接超时等情况出现时，也能自动对数据库进行重连操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> connect = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  mongoose.connect(uri, &#123;</span><br><span class=\"line\">    useNewUrlParser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    useUnifiedTopology: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    autoIndex: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">db.on(<span class=\"string\">'error'</span>, error =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'Error in MongoDB connection:'</span> + error);</span><br><span class=\"line\">  mongoose.disconnect();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">db.on(<span class=\"string\">'disconnected'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'MongoDB disconnected!'</span>);</span><br><span class=\"line\">  connect();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">db.on(<span class=\"string\">'close'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Lost MongoDB connection...'</span>);</span><br><span class=\"line\">  connect();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Reconnect to MongoDB, wait...'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>除了服务端内部进行数据库重连的保障外，后面会提到容器编排也会出现这样的情况，server 项目依赖 database 项目的启动，<code>docker-compose.yml</code> 中有个配置项是 <code>depends_on</code>，表示等待指定的容器启动后再进行当前容器的启动。在容器的角度来看，它只知道容器的是否已经启动，也可以理解为是否已经执行了 <code>docker run</code> 的命令，容器内部的项目是否启动，容器的管不着的，它也不知道，所以如果内部服务启动时间久于容器之间编排启动的时间，同时两者强依赖性质的，那么就会导致某方出现错误，这样的情况大部分出现在对数据库的连接上。</p>\n<p>可能由于接收到的反馈太多，官方文档中 <a href=\"https://docs.docker.com/compose/startup-order/\" target=\"_blank\" rel=\"noopener\">Control startup and shutdown order in Compose</a> 也明确表示这个问题，它提供了几个轮训容器服务的解决方案，包括 <a href=\"https://github.com/vishnubob/wait-for-it\" target=\"_blank\" rel=\"noopener\">wait-for-it.sh</a>、<a href=\"https://github.com/jwilder/dockerize\" target=\"_blank\" rel=\"noopener\">dockerize</a> 和 <a href=\"https://github.com/Eficode/wait-for\" target=\"_blank\" rel=\"noopener\">wait-for</a>。</p>\n<h2 id=\"服务部署\"><a href=\"#服务部署\" class=\"headerlink\" title=\"服务部署\"></a>服务部署</h2><p>首先我们先部署好前端项目，前端项目容器内部执行 Nginx 命令启动代理服务器从而转发请求，如果按照前面所列的 Nginx 配置，理论上应该能顺利启动容器。</p>\n<p>不过这里也提一下实践中遇到的问题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动容器</span></span><br><span class=\"line\">$ docker run -d --name totorox-admin -p 8200:80 hub.ppmoney.io/telescope/totorox-admin</span><br><span class=\"line\">Starting nginx ... <span class=\"keyword\">done</span></span><br><span class=\"line\">Attating to nginx</span><br></pre></td></tr></table></figure>\n<p>就是执行完毕后，界面会一直停留在 <code>Attating to nginx</code>，没有报错也没有提示运行成功。</p>\n<p>这个问题，是由于容器内部 <code>/etc/nginx/conf.d/default.conf</code> 路径下的 <code>default.conf</code> 文件的缺失所导致，换句话说就是 Nginx 启动所需要执行的默认配置丢失了。在容器的层面分析，有可能是因为容器挂载了 <code>volumes</code>，而宿主机的 <code>conf.d</code> 目录下为空覆盖了容器内部对应目录下的文件，具体原因可以 <code>docker exec -it totorox-admin .</code> 进入容器内部检查。</p>\n<p>下面罗列了根据构建好的镜像在服务器上启动运行容器：</p>\n<p><img src=\"http://img.mrsingsing.com/docker-run.png\" alt=\"运行容器命令\"></p>\n<p>容器启动后，可以输入 <code>docker ps -a</code> 查看宿主机上所有的容器列表。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-container-list.jpg\" alt=\"查看宿主机容器列表\"></p>\n<p>从上图可以表格中的 STATUS 和 PORTS 可以看出来，有三个容器已经启动，但是 MongoDB 的容器则启动失败了。</p>\n<p>查看日志 <code>docker logs &lt;container-name&gt;</code> 查看容器的运行日志，找到出错的原因（这里只是为了演示而出错，上述相关代码均验证有效）。</p>\n<p>这里可能会有些疑问，是否应该使用 PM2 等守护进程工具对进程进行守护呢？</p>\n<p>实际上容器中的应用都应该前台执行运行，而非后台执行，容器内没有后台服务的概念。对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义。 比如 <code>CMD service nginx start</code> 它等同于 <code>CMD [ &quot;bash&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code> 主进程实际上是 <code>bash</code>，<code>bash</code> 也就结束了，<code>bash</code> 作为主进程退出了。因此在我们的镜像构建配置文件中，均直接开启服务而非通过 PM2 或 Forever 等工具开启。</p>\n<p>容器的启动相对比较简单，根据需要使用配置项即可快速启动/停止容器。但是，每次部署都需要输入一大串的命令，哪天忘记了哪个参数忘了传怎么办，命令的执行顺序调换了怎么，这个时候就需要一种容器编排的方式，让每次容器更新部署都能通过更简便的命令实现。</p>\n<h2 id=\"容器编排\"><a href=\"#容器编排\" class=\"headerlink\" title=\"容器编排\"></a>容器编排</h2><p>docker-compose 负责实现对 Docker 容器集群的快速编排。使用者通过 <code>docker-compose.yml</code> 模版文件定义一组关联的应用容器为一个项目。它默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。简单来说，就是把刚才一连串的命令利用静态的配置文件记录下来，启动容器只需通过 <code>docker compose up -d</code> 命令运行即可。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-compose.png\" alt=\"容器编排\"></p>\n<p>首先，我们需要注意 <code>docker-compose</code> 的版本问题，有的配置项是 version2.0 没有，而 version3.0 新增的，详情直接看官方文档 <a href=\"https://docs.docker.com/compose/compose-file/compose-versioning/\" target=\"_blank\" rel=\"noopener\">Compose file versions and upgrading</a> 即可。</p>\n<p><code>docker-compose.yml</code> 定义了启动容器名称、镜像地址、对外暴露的端口、环境变量、数据卷以及容器启动的先后顺序等。</p>\n<p><code>docker-compose</code> 启动时会先获取本地镜像，如果本地已经有对应的镜像则会直接使用，如果本地没有找到，则会从远程仓库拉取到本地后再启动。</p>\n<p><code>restart: always</code> 配置项可以让容器在内部服务挂掉的时候，自动重新启动内部服务。</p>\n<p>仓库公开的代码应该需要对文件进行脱敏，也就是将配置文件（包括登录数据库的用户名密码等）排除公开的文件列表中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -e VARIABLE1 --env VARIABLE2=foo --env-file ./env.list ubuntu bash</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li><a href=\"https://docs.docker.com/engine/reference/commandline/run/#set-environment-variables--e---env---env-file\" target=\"_blank\" rel=\"noopener\">Passing variables to Docker</a></li>\n<li><a href=\"https://vsupalov.com/docker-build-pass-environment-variables/\" target=\"_blank\" rel=\"noopener\">Pass Docker Environment Variables During The Image Build</a></li>\n<li><a href=\"https://blog.bitsrc.io/how-to-pass-environment-info-during-docker-builds-1f7c5566dd0e\" target=\"_blank\" rel=\"noopener\">How To Pass Environment Info During Docker Builds</a></li>\n<li><a href=\"https://stackoverflow.com/questions/42992397/how-to-setup-node-environment-variable-in-dockerfile-for-running-node-js-applica\" target=\"_blank\" rel=\"noopener\">How to setup Node environment variable in Dockerfile for running node.js application?</a></li>\n<li><a href=\"https://hn.werick.codes/how-to-create-a-node-app-within-a-docker-container-with-mongo-cjwjd3l4t00067rs18w7035oc\" target=\"_blank\" rel=\"noopener\">How to create a Node App within a Docker container with Mongo</a></li>\n<li><a href=\"http://quabr.com/57123227/cannot-connect-from-node-to-mongo-replicaset-in-docker\" target=\"_blank\" rel=\"noopener\">Cannot connect from node to mongo replicaset in docker</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_30466953/article/details/97366689\" target=\"_blank\" rel=\"noopener\">Docker Node 项目连接 MongoDB</a></li>\n<li><a href=\"https://blog.csdn.net/wxb880114/article/details/88869215\" target=\"_blank\" rel=\"noopener\">升级 Docker 后重启容器出现错误 Unknown runtime specified docker-runc</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000010768993\" target=\"_blank\" rel=\"noopener\">Mongoose 远程连接 MongoDB，当客户端断开网络重连时报错 topology was destoryed？</a></li>\n<li><a href=\"https://juejin.im/post/5ddb3f85e51d45231576af3c\" target=\"_blank\" rel=\"noopener\">这可能是网络上唯一一篇给前端写的 Docker+Node+Nginx+MongoDB 的本地开发+部署实战</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在人类社会大分工越来越精细的大背景下，各式各样的软件技术公司层出不穷，为各行各业提供着或大众化或具有特色的软件服务，大部分软件服务是公有性质的，也就是这些服务提供商内部单独的运营软件平台，使用者获取软件使用权后在其平台生产内容，并由服务商提供数据存储服务，这种性质的平台对于软件开发商来说需要考虑数据的隔离，对于使用者来说则减少了维护成本，但是数据并非私自存储无法确保安全性。而相对于公有性软件服务的就是私有化软件服务，这类型产品提供可部署至客户私自的服务器上的版本，数据由客户自身存储，某种程度上保证的了数据的安全性。</p>\n<p>在 PPmoney 内部，龙猫 X 配置平台提供给理财及借贷两个技术团队使用，对于页面、模版、组件、素材都需要在公共空间进行共享存储，而现有的人员权限机制无法对这些要素进行筛选区分，无可避免出现管理混乱的局面。而根据不同的团队、不同的部署环境进行系统部署也是需求的关注点。考虑到对数据的隔离，以及未来龙猫 X 作为软件服务对外提供商业性质的服务，为龙猫 X 增强可独立部署的功能的事宜即提上开发的日程。</p>\n<p>在对龙猫 X 的独立部署的技术选型上我们选择了 Docker 容器化技术。之所以选择 Docker 是因为容器技术对进程进行封装隔离，能够高效地在利用服务器资源以及便捷地在多平台间进行迁移。</p>\n<p>在这篇文章中我尝试把容器化改造过程中遇到的坑位记录下来为后人提供借鉴，也是对整个坎坷的过程的记录。</p>","more":"<h2 id=\"容器化技术\"><a href=\"#容器化技术\" class=\"headerlink\" title=\"容器化技术\"></a>容器化技术</h2><p>容器技术对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此称为容器。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-in-server.png\" alt=\"服务器中的容器\"></p>\n<p>Docker 容器化技术关键核心只需要掌握三个概念：</p>\n<ul>\n<li>镜像 Image</li>\n<li>容器 Container</li>\n<li>仓库 Repository</li>\n</ul>\n<p>从小白的角度理解的话可以把 <strong>镜像</strong> 和 <strong>容器</strong> 类比为面向对象编程中的类和实例，镜像是静态的定义，而容器则是镜像运行时的形态。我们可以把容器想像成包装盒，包装盒里装载着一个微型操作系统，其内部运行着我们的应用程序。</p>\n<p>仓库则是存放镜像的地方，可以为镜像打 tag（标签），就好像我们为 git commit 打版本号的 tag 一样，使用者可以根据需要选择版本部署，程序故障时也能立马根据版本进行回滚。</p>\n<p>Docker Hub 是 Docker 官方的公开的仓库，私有仓库则有 Harbor，商业化的容器服务提供商有阿里云、Dao Cloud 等。我们公司采用的是内部自建的 Harbor 仓库。</p>\n<p>因为本篇文章非科普性质，所以对于 Docker 的介绍就不过于深入叙述，有兴趣可以搜索相关文章进行研究，当然首推还是把 <a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\">官方文档</a> 看一遍，毕竟第一手资料才是最具参考价值的。</p>\n<h2 id=\"镜像制作\"><a href=\"#镜像制作\" class=\"headerlink\" title=\"镜像制作\"></a>镜像制作</h2><p>对龙猫 X 进行容器化改造需要部署四个子项目，分别是 React 全家桶的客户端项目、Koa 服务端项目、页面爬虫项目以及 MongoDB 数据库。</p>\n<p>在 Docker 中，镜像是根据配置文件 Dockerfile 构建的。通过以下命令可以执行构建的工作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker build -t &lt;镜像名称&gt; &lt;构建目录&gt;</span></span><br><span class=\"line\">$ docker build -t totorox-admin .</span><br></pre></td></tr></table></figure>\n<p><code>-t</code> 表示将镜像命名为 <code>totorox-admin</code>。</p>\n<h3 id=\"前端项目\"><a href=\"#前端项目\" class=\"headerlink\" title=\"前端项目\"></a>前端项目</h3><p>如下图所示为前端项目镜像的配置文件：</p>\n<p><img src=\"http://img.mrsingsing.com/frontend-dockerfile.png\" alt=\"Dockerfile in Frontend Project\"></p>\n<p>在 Dockerfile 中 <code>FROM</code> 指令是必然存在的并且作为构建的开头，该指令初始化一个新的构建阶段（也就是有多少个 <code>FROM</code> 指令就有多少个镜像构建阶段）并为后续指令设置基础映像。</p>\n<p><code>COPY</code> 指令表示拷贝资源至镜像内部，这里有个优化的小技巧，就是在项目根目录添加 <code>.dockerignore</code> 文件，与 <code>.gitignore</code> 或 <code>.npmignore</code> 类似，添加到该文件下的目录 Docker 构建镜像时将忽略其中的文件。我们可以把只用于代码开发阶段或者规范性的文件排除在构建之外，例如 <code>.vscode</code>、<code>.eslint</code>、<code>dist</code> 等。</p>\n<p>接下来就是常规的安装依赖、项目构建打包的指令，<code>npm install</code> 可以指定为淘宝镜像，在国内的话下载速度相对有保障，能够缩减镜像的构建时间。</p>\n<p>类似地，由于我们的项目中使用到了 Sass 预编译，Webpack 打包需要用到 <code>node-sass</code> 插件，每次都必须下载 <code>win32-x64-57_binding.node</code> 文件，所以要不需要漫长的等待（因为从国外源仓库下载），要不下载失败报一系列的错。幸好它提供了人性化的配置，可以通过环境变量改变下载的地址。我们在 <code>.npmrc</code> 中将一些依赖包中需要额外下载的文件的链接地址的环境变量指定为国内的镜像地址。当然啦并非所有依赖包都支持这样做，有些写死了下载地址是无法通过这样的方法优化的。除了上面提到的 <code>node-sass</code>，其余可以在 <a href=\"https://developer.aliyun.com/mirror/NPM?from=tnpm\" target=\"_blank\" rel=\"noopener\">淘宝镜像</a> 找到对应的镜像地址，后面会提到的页面爬虫项目中使用的 <code>phantomjs</code> 也是通过这种方式大幅度压缩了构建时间。</p>\n<p><img src=\"http://img.mrsingsing.com/npmrc.jpg\" alt=\".npmrc配置文件\"></p>\n<p>第二阶段我们从镜像仓库获取 Nginx 镜像。一般地，前端项目构建打包后生成静态资源文件，需要 Web 代理服务器进行请求转发，我们这里用的是 Nginx，当然也可以用 Express 实现一个 Web 服务作为代理转发。</p>\n<p>Nginx 配置和使用相对来说比较简单，通过简单的配置即可拥有高性能和高可用性，下面是 Nginx 的示例配置：</p>\n<p><img src=\"http://img.mrsingsing.com/nginx-conf.png\" alt=\"Nginx配置\"></p>\n<p>在该阶段中，主要是将第一阶段生成的产物转移到第二阶段，这是因为镜像最终的启动指令 <code>CMD</code> 是在第二阶段，而且分阶段的镜像构建能够使得最终容器内只需放置打包后的静态资源文件即可，不用包含源代码文件，镜像的体积也会因此而大幅度缩减，在某种程度也确保了源代码的不对外泄漏。</p>\n<p>最终 <code>CMD</code> 命令是容器运行时在内部执行的指令。考虑到不同使用者的 API 服务器域名是不同的是动态变化的，在源代码中把 API 域名写死显然是个不明智的做法。因此，我们通过在运行容器时的环境变量植入写好的 Shell 脚本，通过 Shell 脚本生成包含域名等信息的 JavaScript 文件，HTML 文档通过写好的外链该脚本文件实现加载，这样即可满足动态域名变更的需求。</p>\n<p>在镜像构建过程中，如果细心观察打印的日志，会发现有这么一句：</p>\n<p><img src=\"http://img.mrsingsing.com/removeing-intermediate-container.jpg\" alt=\"移除中间容器\"></p>\n<p>其实从构建的日志中可以看到，实质上镜像构建的每个指令都会生成一个临时的中间容器，每层中间容器都是以前面一层中间容器为基础的。当对应的指令执行完毕后，对应层级就不会再发生改变，会移除该临时创建的中间容器，然后再进行下一个指令操作。</p>\n<p>构建成功后，在命令行中输入 <code>docker images</code> 即可查看当前宿主机的 Docker 镜像列表：</p>\n<p><img src=\"http://img.mrsingsing.com/docker-images.jpg\" alt=\"容器镜像\"></p>\n<p>由于我们的项目所需要的镜像在公司内部有私有仓库，所以构建时速度有一定的保障，如果是个人开发者在自己的服务器上构建镜像可能需要从公有仓库例如 Docker Hub 拉取所需要的镜像，这里提供一个优化的手段，可以通过修改 Docker Daemon 配置 <code>/etc/docker/daemon.json</code> 的镜像地址，实现镜像的加速，Docker 官方和国内很多云服务器平台都提供了国内的加速服务。</p>\n<p>🌰 <strong>示例：</strong></p>\n<p>这里提供的镜像地址仅供参考，可以到对应的云服务商找到对应的镜像加速地址。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-image-acceleration.png\" alt=\"镜像加速\"></p>\n<p>除此之外，在使用 Docker 构建部署应用前最好确认好 Docker 的版本，例如 CentOS 7 系统默认的 Docker 版本是 13，而 <code>FROM AS</code> 的语法则需要 Docker 版本 17 以上才支持，这个时候需要先对宿主机的 Docker 进行版本更新。</p>\n<p>安装最新版本的 Docker 可以参考：</p>\n<p><a href=\"https://www.jianshu.com/p/2e208721aa39\" target=\"_blank\" rel=\"noopener\">CentOS 安装最新版本的 Docker</a></p>\n<p>升级 Docker 后重启容器出现错误 <code>Unknown runtime specified docker runc</code> 的解决方案：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ grep -rl <span class=\"string\">'docker-runc'</span> /var/lib/docker/containers/ | xargs sed -i <span class=\"string\">'s/docker-runc/runc/g'</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ systemctl stop docker</span><br><span class=\"line\"></span><br><span class=\"line\">$ systemctl start docker</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务端项目\"><a href=\"#服务端项目\" class=\"headerlink\" title=\"服务端项目\"></a>服务端项目</h3><p>接下来我们看看用 Koa 搭建的服务端项目如何部署，类似操作指令就不再重复赘述了，主要谈谈需要注意的地方。</p>\n<p><img src=\"http://img.mrsingsing.com/backend-dockerfile.png\" alt=\"服务端Dockerfile\"></p>\n<p>因为项目中通过开启子进程的方式执行 Webpack 命令进行页面的生成，因此我们需要在容器内全局安装 Webpack。</p>\n<p>我们看到这里为一个名为 <code>wait-for-it.sh</code> 的提供了可执行的权限，而且在后续的 <code>CMD</code> 指令中先执行了该脚本文件。应用容器化后，Docker 容器启动时，默认使用非 root 用户执行命令，所以应用内的脚本文件无法正常执行，这时候就需要执行 <code>chmod a+x</code> 为脚本文件提供可执行的权限。至于这个脚本的存在意义我们在后面容器通讯的部分再详细说明，暂且跳过。</p>\n<p>下面我们谈谈 Dockerfile 中的输入参数 <code>ARG</code>、环境变量 <code>ENV</code> 以及如何将 Dockerfile 中的环境变量/传入参数在 <code>CMD</code> 指令中的使用。</p>\n<p>指令 <code>ARG</code> 定义一个变量，用户可以在使用 <code>docker build</code> 命令使用 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 标志，在构建时将其传递给构建器。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ARG</span> <span class=\"keyword\">env</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定默认值</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> <span class=\"keyword\">env</span>=local</span><br></pre></td></tr></table></figure>\n<p>如果 <code>ARG</code> 对应的值有缺省值，并且如果在构建时没有传递值，则构建器使用缺省值。</p>\n<p>Dockerfile 的 <code>ENV</code> 指令有两种书写方式：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这种写法键/值与等号之间不能存在空格</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> &lt;key&gt;=&lt;value&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过斜杠 \\ 换行一次性声明多个环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> API_URL=example.com \\</span><br><span class=\"line\">    NODE_ENV=production \\</span><br><span class=\"line\">    COMMAND=dev</span><br></pre></td></tr></table></figure>\n<p>与 <code>ARG</code> 指令对比，<code>ENV</code> 始终存在于镜像当中，而 <code>ARG</code> 仅在执行时存在。</p>\n<p>关于 dockerfile 中的环境变量替换可以阅读官方文档中有关 <a href=\"https://docs.docker.com/engine/reference/builder/#environment-replacement\" target=\"_blank\" rel=\"noopener\">环境变量替换</a> 的相关章节。</p>\n<p><code>CMD</code> 指令有三种书写方式：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 exec 执行，这类格式在解析时会被解析成 JSON 数组，因此一定要使用双引号</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"command\"</span>, <span class=\"string\">\"instructions\"</span>, <span class=\"string\">\"options\"</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 /bin/sh 中执行，提供给需要交互的应用</span></span><br><span class=\"line\"><span class=\"comment\"># 实际命令会被包装为 sh -c 的参数形式进行执行</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> <span class=\"built_in\">command</span> param1 param2</span></span><br></pre></td></tr></table></figure>\n<p>指定启动容器时执行命令，每个 Dockerfile 只能有一个 <code>CMD</code> 指令。如果指定了多条命令，则只有最后一条会被执行。如果用户启动容器时指定了运行的命令，则会覆盖掉 <code>CMD</code> 指定的命令。</p>\n<p>在我们的项目中，除了前面谈过的前端项目需要将 API 域名等在 Docker 运行初期动态植入外，服务端项目也需要传入数据库相关的信息。经过实验发现，<code>exec</code> 形式的 <code>CMD</code> 是通过 Docker 来运行命令的，并不支持参数替换。而 <code>shell</code> 形式的 <code>CMD</code> 则是通过 Docker 来运行 <code>sh</code>，<code>sh</code> 再运行我们写的命令，而 <code>sh</code> 是支持参数替换的。</p>\n<p>所以如果想将 Dockerfile 中的环境变量 <code>ENV</code> 或参数 <code>ARG</code> 在 <code>CMD</code> 指令中使用，就需要采用 <code>shell</code> 的形式书写启动命令。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker run 后添加的参数传入</span></span><br><span class=\"line\"><span class=\"keyword\">ARG</span> <span class=\"keyword\">env</span>=production</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从执行 shell 命令的执行环境中读取 ENV 变量作为 dockerfile 中的 env 变量值</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> <span class=\"keyword\">env</span>=$&#123;<span class=\"keyword\">ENV</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动命令是执行脚本 /scripts/setup.sh</span></span><br><span class=\"line\"><span class=\"comment\"># 该脚本需要传入环境变量 env，也就是 dockerfile 中定义的变量</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> /scripts/setup.sh <span class=\"variable\">$&#123;env&#125;</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"爬虫项目\"><a href=\"#爬虫项目\" class=\"headerlink\" title=\"爬虫项目\"></a>爬虫项目</h3><p>接着我们谈谈页面爬虫项目的镜像构建。</p>\n<p>由于龙猫 X 主要用于移动端营销活动，页面的加载体验对用户转化率起到至关重要的作用，因此发布页面都经由无头浏览器爬取发布页面的首屏渲染的 HTML 文档以缩减页面的白屏时间。</p>\n<p>在 Linux 系统中使用 PhantomJS 需要从源代码仓库中拉取整包，下载速度因众所周知的原因非常慢，所以这里改用阿里国内的镜像作为下载地址，后续经过一系列解压缩、移动文件、建立软链接等，在容器内能够直接通过命令行执行 PhantomJS 的相关命令。</p>\n<p>前面提及每个指令都是新的构建层，所以这里也是通过管道连接的方式实现一连串的操作，这种方式是很好的压缩镜像体积的方法。</p>\n<p><img src=\"http://img.mrsingsing.com/spider-dockerfile.png\" alt=\"爬虫项目 Dockerfile\"></p>\n<h3 id=\"数据库项目\"><a href=\"#数据库项目\" class=\"headerlink\" title=\"数据库项目\"></a>数据库项目</h3><p>下面需要对 MongoDB 数据库实现容器化管理。先给大家看看 MongoDB 数据库的 Dockerfile 文件：</p>\n<p><img src=\"http://img.mrsingsing.com/mongodb-dockerfile.png\" alt></p>\n<p>由于独立部署版本的龙猫 X 在初始化时需要导入默认的数据，例如组件数据、组件类型数据、标签数据、页面类型数据等。我们从已有的项目中导出数据并进行适当修正后，将数据文件保存到项目指定默认数据的目录下，在 Dockerfile 中指定 <code>RUN</code> 通过下面的 shell 脚本对数据库进行初始化，并向数据库中导入数据。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-entrypoint-initdb.png\" alt=\"MongoDB 初始化脚本\"></p>\n<p>为了提高数据库的扩展性，数据库的用户名、密码、名称可以通过环境变量的方式进行设置，方便不同的团队根据自身需求修改。</p>\n<p>我们将四个项目分别通过 <code>docker build</code> 命令构建独立的镜像后，通过命令 <code>docker images</code> 能够查看到所有已构建的镜像列表，通过 <code>docker history &lt;image-id&gt;</code> 命令能够查看镜像构建过程中的细节：包括每层指令执行的指令、构建后的产物占镜像的体积大小等，通过分析构建历史能够让我们掌握依据对 Dockerfile 进行优化。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-history.jpg\" alt=\"容器构建历史\"></p>\n<p>除此之外，构建好的镜像需要持久化保存的话，需要 <code>docker tag</code> 打标签并 <code>docker push</code> 到远程仓库中进行保存。</p>\n<h2 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h2><p>我们知道服务端项目运行时是需要与数据库保持连接的，那么 Docker 是否提供某种机制让不同容器之间进行通信呢？</p>\n<p>当 Docker 启动时，实际上会自动在宿主机上创建一个 <code>docker0</code> 虚拟网桥，相当于 Linux 上的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-network.png\" alt=\"容器互联\"></p>\n<p>回到我们的需求上，我们需要将服务端项目、数据库项目和爬虫项目包裹在一个网络当中，也就是建立这三个项目对应容器的“局域网”。将容器加入指定的局域网其实很简单，talk is cheap，show you the code：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建虚拟局域网 `totorox-net` 是该局域网的名称</span></span><br><span class=\"line\">docker network create -d bridge totorox-net</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器时带上 `--network &lt;你创建的局域网名称&gt;` 即可加入到指定的局域网内</span></span><br><span class=\"line\">docker run -d --name totorox-server -p 3012:3012 --network totorox-net ...</span><br></pre></td></tr></table></figure>\n<p>以此类推在对应的容器启动时也加入局域网内，那么局域网内的容器之间就能够通过加入局域网时随机分配的域名进行访问。</p>\n<!-- ![docker network ls 查询 docker]() -->\n<p>那么问题来了，从服务端容器的角度出发，怎么知道数据库容器的域名是 <code>xxx.xxx.xxx.xxx</code> 呢，总不能每次启动后 <code>docker network ls</code> 查看容器分配到的局域网域名，然后再到对应的容器内部进行修改，这显然不太科学。</p>\n<p>docker 作为广泛使用的技术，其开源团队显然不会犯如此低级的设计错误。实际上，除了运行容器时将容器加入局域网外，为容器命名也是必不可少的步骤。容器名称类比来理解，相当于我们需要申请购买域名以替代 IP 地址一样，一般用户只需要记住辨识度高的网站地址，访问时通过 DNS 解析到 IP 地址再对服务器进行访问，这里 docker 容器互联的原理是高度类似的，局域网内直接访问容器名称也能解析到对应的容器当中并进行访问。</p>\n<p>多说无益，我们看看如何在服务端项目中用 Mongoose 连接数据库容器的 MongoDB：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// username 为数据库账户名称</span></span><br><span class=\"line\"><span class=\"comment\">// password 为数据库账户密码</span></span><br><span class=\"line\"><span class=\"comment\">// containerName 为数据库项目容器的名称</span></span><br><span class=\"line\"><span class=\"comment\">// databaseName 为数据库名称</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> uri = <span class=\"string\">`mongodb://<span class=\"subst\">$&#123;username&#125;</span>:<span class=\"subst\">$&#123;password&#125;</span>@<span class=\"subst\">$&#123;containerName&#125;</span>/<span class=\"subst\">$&#123;databaseName&#125;</span>`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">mongoose.connect(uri, &#123;</span><br><span class=\"line\">  useNewUrlParser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  useUnifiedTopology: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  autoIndex: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里踩了不少坑，Mongoose 连接 MongoDB 的域名使用容器名称作为标识，而非使用随机分配的固定 IP 地址，或容器网络的名称。</p>\n<p>除此之外，很多中文文章中都没有提到一个遇上机率比较大的坑，就是服务端是需要等待 MongoDB 数据库启动并就绪后，才能连接成功的。</p>\n<p>在使用 <code>docker run</code> 方式启动容器时要先启动 MongoDB 的容器，再启动服务端项目的容器，两个启动命令执行需要有段时间差，不能执行前一个，马不停蹄地就执行下一个。这是因为 <code>docker run</code> 只是作为启动容器的起点，容器内部实际对外服务的数据库正在执行启动中，容器局域网内并不能第一时间对其进行访问，而是需要等待一段时候后暴露的端口才可接受外部请求。在容器外来看，<code>docker run</code> 命令执行后容器是启动了，但是内部实际提供服务的数据库还没准备就绪，这就有可能导致服务端项目连接数据库容器出现超时的问题发生。</p>\n<p>因此，我们需要对 mongoose 设立重连机制，当连接超时等情况出现时，也能自动对数据库进行重连操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> connect = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  mongoose.connect(uri, &#123;</span><br><span class=\"line\">    useNewUrlParser: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    useUnifiedTopology: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    autoIndex: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">db.on(<span class=\"string\">'error'</span>, error =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'Error in MongoDB connection:'</span> + error);</span><br><span class=\"line\">  mongoose.disconnect();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">db.on(<span class=\"string\">'disconnected'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'MongoDB disconnected!'</span>);</span><br><span class=\"line\">  connect();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">db.on(<span class=\"string\">'close'</span>, () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Lost MongoDB connection...'</span>);</span><br><span class=\"line\">  connect();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Reconnect to MongoDB, wait...'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>除了服务端内部进行数据库重连的保障外，后面会提到容器编排也会出现这样的情况，server 项目依赖 database 项目的启动，<code>docker-compose.yml</code> 中有个配置项是 <code>depends_on</code>，表示等待指定的容器启动后再进行当前容器的启动。在容器的角度来看，它只知道容器的是否已经启动，也可以理解为是否已经执行了 <code>docker run</code> 的命令，容器内部的项目是否启动，容器的管不着的，它也不知道，所以如果内部服务启动时间久于容器之间编排启动的时间，同时两者强依赖性质的，那么就会导致某方出现错误，这样的情况大部分出现在对数据库的连接上。</p>\n<p>可能由于接收到的反馈太多，官方文档中 <a href=\"https://docs.docker.com/compose/startup-order/\" target=\"_blank\" rel=\"noopener\">Control startup and shutdown order in Compose</a> 也明确表示这个问题，它提供了几个轮训容器服务的解决方案，包括 <a href=\"https://github.com/vishnubob/wait-for-it\" target=\"_blank\" rel=\"noopener\">wait-for-it.sh</a>、<a href=\"https://github.com/jwilder/dockerize\" target=\"_blank\" rel=\"noopener\">dockerize</a> 和 <a href=\"https://github.com/Eficode/wait-for\" target=\"_blank\" rel=\"noopener\">wait-for</a>。</p>\n<h2 id=\"服务部署\"><a href=\"#服务部署\" class=\"headerlink\" title=\"服务部署\"></a>服务部署</h2><p>首先我们先部署好前端项目，前端项目容器内部执行 Nginx 命令启动代理服务器从而转发请求，如果按照前面所列的 Nginx 配置，理论上应该能顺利启动容器。</p>\n<p>不过这里也提一下实践中遇到的问题：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动容器</span></span><br><span class=\"line\">$ docker run -d --name totorox-admin -p 8200:80 hub.ppmoney.io/telescope/totorox-admin</span><br><span class=\"line\">Starting nginx ... <span class=\"keyword\">done</span></span><br><span class=\"line\">Attating to nginx</span><br></pre></td></tr></table></figure>\n<p>就是执行完毕后，界面会一直停留在 <code>Attating to nginx</code>，没有报错也没有提示运行成功。</p>\n<p>这个问题，是由于容器内部 <code>/etc/nginx/conf.d/default.conf</code> 路径下的 <code>default.conf</code> 文件的缺失所导致，换句话说就是 Nginx 启动所需要执行的默认配置丢失了。在容器的层面分析，有可能是因为容器挂载了 <code>volumes</code>，而宿主机的 <code>conf.d</code> 目录下为空覆盖了容器内部对应目录下的文件，具体原因可以 <code>docker exec -it totorox-admin .</code> 进入容器内部检查。</p>\n<p>下面罗列了根据构建好的镜像在服务器上启动运行容器：</p>\n<p><img src=\"http://img.mrsingsing.com/docker-run.png\" alt=\"运行容器命令\"></p>\n<p>容器启动后，可以输入 <code>docker ps -a</code> 查看宿主机上所有的容器列表。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-container-list.jpg\" alt=\"查看宿主机容器列表\"></p>\n<p>从上图可以表格中的 STATUS 和 PORTS 可以看出来，有三个容器已经启动，但是 MongoDB 的容器则启动失败了。</p>\n<p>查看日志 <code>docker logs &lt;container-name&gt;</code> 查看容器的运行日志，找到出错的原因（这里只是为了演示而出错，上述相关代码均验证有效）。</p>\n<p>这里可能会有些疑问，是否应该使用 PM2 等守护进程工具对进程进行守护呢？</p>\n<p>实际上容器中的应用都应该前台执行运行，而非后台执行，容器内没有后台服务的概念。对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义。 比如 <code>CMD service nginx start</code> 它等同于 <code>CMD [ &quot;bash&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code> 主进程实际上是 <code>bash</code>，<code>bash</code> 也就结束了，<code>bash</code> 作为主进程退出了。因此在我们的镜像构建配置文件中，均直接开启服务而非通过 PM2 或 Forever 等工具开启。</p>\n<p>容器的启动相对比较简单，根据需要使用配置项即可快速启动/停止容器。但是，每次部署都需要输入一大串的命令，哪天忘记了哪个参数忘了传怎么办，命令的执行顺序调换了怎么，这个时候就需要一种容器编排的方式，让每次容器更新部署都能通过更简便的命令实现。</p>\n<h2 id=\"容器编排\"><a href=\"#容器编排\" class=\"headerlink\" title=\"容器编排\"></a>容器编排</h2><p>docker-compose 负责实现对 Docker 容器集群的快速编排。使用者通过 <code>docker-compose.yml</code> 模版文件定义一组关联的应用容器为一个项目。它默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。简单来说，就是把刚才一连串的命令利用静态的配置文件记录下来，启动容器只需通过 <code>docker compose up -d</code> 命令运行即可。</p>\n<p><img src=\"http://img.mrsingsing.com/docker-compose.png\" alt=\"容器编排\"></p>\n<p>首先，我们需要注意 <code>docker-compose</code> 的版本问题，有的配置项是 version2.0 没有，而 version3.0 新增的，详情直接看官方文档 <a href=\"https://docs.docker.com/compose/compose-file/compose-versioning/\" target=\"_blank\" rel=\"noopener\">Compose file versions and upgrading</a> 即可。</p>\n<p><code>docker-compose.yml</code> 定义了启动容器名称、镜像地址、对外暴露的端口、环境变量、数据卷以及容器启动的先后顺序等。</p>\n<p><code>docker-compose</code> 启动时会先获取本地镜像，如果本地已经有对应的镜像则会直接使用，如果本地没有找到，则会从远程仓库拉取到本地后再启动。</p>\n<p><code>restart: always</code> 配置项可以让容器在内部服务挂掉的时候，自动重新启动内部服务。</p>\n<p>仓库公开的代码应该需要对文件进行脱敏，也就是将配置文件（包括登录数据库的用户名密码等）排除公开的文件列表中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -e VARIABLE1 --env VARIABLE2=foo --env-file ./env.list ubuntu bash</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li><a href=\"https://docs.docker.com/engine/reference/commandline/run/#set-environment-variables--e---env---env-file\" target=\"_blank\" rel=\"noopener\">Passing variables to Docker</a></li>\n<li><a href=\"https://vsupalov.com/docker-build-pass-environment-variables/\" target=\"_blank\" rel=\"noopener\">Pass Docker Environment Variables During The Image Build</a></li>\n<li><a href=\"https://blog.bitsrc.io/how-to-pass-environment-info-during-docker-builds-1f7c5566dd0e\" target=\"_blank\" rel=\"noopener\">How To Pass Environment Info During Docker Builds</a></li>\n<li><a href=\"https://stackoverflow.com/questions/42992397/how-to-setup-node-environment-variable-in-dockerfile-for-running-node-js-applica\" target=\"_blank\" rel=\"noopener\">How to setup Node environment variable in Dockerfile for running node.js application?</a></li>\n<li><a href=\"https://hn.werick.codes/how-to-create-a-node-app-within-a-docker-container-with-mongo-cjwjd3l4t00067rs18w7035oc\" target=\"_blank\" rel=\"noopener\">How to create a Node App within a Docker container with Mongo</a></li>\n<li><a href=\"http://quabr.com/57123227/cannot-connect-from-node-to-mongo-replicaset-in-docker\" target=\"_blank\" rel=\"noopener\">Cannot connect from node to mongo replicaset in docker</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_30466953/article/details/97366689\" target=\"_blank\" rel=\"noopener\">Docker Node 项目连接 MongoDB</a></li>\n<li><a href=\"https://blog.csdn.net/wxb880114/article/details/88869215\" target=\"_blank\" rel=\"noopener\">升级 Docker 后重启容器出现错误 Unknown runtime specified docker-runc</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000010768993\" target=\"_blank\" rel=\"noopener\">Mongoose 远程连接 MongoDB，当客户端断开网络重连时报错 topology was destoryed？</a></li>\n<li><a href=\"https://juejin.im/post/5ddb3f85e51d45231576af3c\" target=\"_blank\" rel=\"noopener\">这可能是网络上唯一一篇给前端写的 Docker+Node+Nginx+MongoDB 的本地开发+部署实战</a></li>\n</ul>"},{"title":"可视化配置系统页面批量更新工具的开发实践","date":"2019-11-15T00:00:00.000Z","_content":"\n> 首发于：[可视化配置系统页面批量更新工具的开发实践](https://juejin.im/post/5dc8fd92f265da4d287f4551)\n\nTotoroX 作为 PPmoney 集团内部集 UI 和业务逻辑于一体的前端页面可视化配置系统，为运营部门提供快速构建前端页面的解决方案。该系统为页面开发及运营人员提供了强大的组件市场，通过拖拽、表单配置等方式实现专题页面的业务需求。目前已支撑集团 850+营销活动页面。\n\n## 业务痛点\n\n在产品设计阶段，产品经理会根据对用户的调研，借助用户画像理解用户的需求，想想用户使用的场景，以及他们可能会遇到的困难。随着产品上线后，运营团队通过转化漏斗分析用户交互行为以及最终的转化的实际效果。所以这个阶段，随着真实用户群体的积累，在设计阶段虚构的用户画像需要重新调研、设想。\n\n而在技术的角度，我们也希望通过用户行为数据，为产品运营提供更好的支撑，例如为不同的用户提供不同 UI 的前端页面，通过对比的方法观察数据变化，以此作为对用户行为的准确判断。\n\n以下面的营销活动页为例，我们会在既有的页面配置中生成新的页面，并根据设计要求进行局部的调整，除了 UI 部分，内部逻辑包括埋点数据、事件链条关系等也会进行相关的修正。在此需求背景之下，如果需要人工手动对每个配置页面进行修改，这将会耗费大量的人力资源。而且，上文提到会涉及逻辑的修改，配置人员不易发现变更的地方，无法对修改后的页面进行校验。综上所述，我们需要一款对比前后变化的工具，能够可视化地对不同的配置数据进行对比，并通过图形绘制的形式清晰知道配置数据树中哪些节点没有修改，哪些节点修改了，修改前后的值又是什么，就好像我们进行代码协助时通过 `git diff` 能够知道文件中哪行代码发生了冲突，通过人工判断对冲突进行修改合并，并最终达到我们需要的效果。\n\n![AB Test](http://img.mrsingsing.com/diff-tool-abtest.jpg)\n\nTotoroX 基于用户配置的数据组装生成页面，配置数据均由组件市场的物料支撑，单个组件的配置数据结构基本相同，包括但不限于：唯一标识、组件名称、组件属性、组件样式、组件事件链以及动画相关配置等。组件间在配置数据的集合中是扁平化的，通过各组件配置数据中的标识集合相互关联起来，这样的数据结构设计避免了因为嵌套层级过深而产生的问题。基于这些条件，为多路差异化对比以及合并提供了可能。\n\n<!-- more -->\n\n## 差异化配置数据结构的设计\n\n在进行配置数据的对比合并前，需要设计出能够准确描述数据变化前后的数据结构。\n\n在 TotoroX 中，配置数据的结构模式与 JSON 的结构模式一致，因此数据结构的设计应以 JSON 的数据结构为基础。\n\n而在 JSON 中值存在以下几种数据类型：\n\n- null\n- 字符串\n- 布尔值\n- 数值\n- 数组\n- 对象\n\n因此，我们不用考虑诸如 Date、Function、Symbol、Set 等数据类型的值。\n\n同时，在设定的配置数据中不能存在空值 `null`，如果要表示不对某配置项作配置，实际上会采用默认的配置属性，所以在实际配置数据中，是不会存在空值存在，可以忽略这种情况。\n\n综合上述，从大致上能分为两大类数据类型：\n\n- 基本数据类型：字符串、布尔值、数值\n- 引用数据类型：数组、对象\n\n那么我们是怎样去描述 JSON 对比前后变更状态呢？\n\nJSON 是目前应用广泛的数据交换格式，那么交换双方肯定需要对数据进行约定和校验，而 JSON Schema 就是扮演定义 JSON 数据约束的标准。因此，我们尝试引入 JSON Schema 的概念，并结合实际功用进行改造。\n\n传统的 JSON Schema 表现为这样：\n\n```json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"http://example.com/product.schema.json\",\n  \"title\": \"Product\",\n  \"description\": \"A product from Acme's catalog\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"productId\": {\n      \"description\": \"The unique identifier for a product\",\n      \"type\": \"integer\"\n    },\n    \"productName\": {\n      \"description\": \"Name of the product\",\n      \"type\": \"string\"\n    },\n    \"price\": {\n      \"description\": \"The price of the product\",\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"tags\": {\n      \"description\": \"Tags for the product\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"dimensions\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"length\": {\n          \"type\": \"number\"\n        },\n        \"width\": {\n          \"type\": \"number\"\n        },\n        \"height\": {\n          \"type\": \"number\"\n        }\n      },\n      \"required\": [\"length\", \"width\", \"height\"]\n    }\n  },\n  \"required\": [\"productId\", \"productName\", \"price\"]\n}\n```\n\n从形式上来讲，JSON Schema 还是 JSON 的格式，但不同的是，JSON Schema 会在原来的 JSON 基础上在每个层级的数据外包装了一层用以描述对应层级值的相关信息，包括对应层级的值、描述、数据类型以及其它额外配置的信息。\n\n在结构上，我们沿用了 JSON Schema 的一套标准，在源数据基础上通过遍历递归的方法对数据进行描述。而在描述的信息上，我们针对实际的应用场景进行了定制。\n\n描述信息中必不可少的就是对数据变化信息的描述，我们参考了 Git 管理代码变更的策略，在两两对比下，我们梳理出可能产生的四种值比较情况：\n\n- **相等（Equal）**：当两个基本数据类型的值严格相等时，则为相等状态；而对于引用数据类型，需要提供额外的手段进行匹配\n- **新增（Add）**：当对象间对比时，目标对象存在新增的键时，描述该键值为新增状态；同理，当数组中无对应的匹配项时，则为新增状态\n- **删除（Delete）**：与新增状态类似，当对象间对比时，目标对象存在删除的键时，描述该键值为删除状态，而数组中对应的匹配项不存在时，则为删除状态\n- **冲突（Conflict）**：当两个基本数据类型的值不严格相等时，则为冲突状态\n\n举个例子，如下为两个个仅有一个按钮组件的配置页数据集合：\n\n![修改前后的配置数据](http://img.mrsingsing.com/diff-tool-data-structure-comparation-.jpg)\n\n通过 diff 后预设能产生的数据结构：\n\n![对比后产生的数据结构](http://img.mrsingsing.com/diff-tool-result-data-structure.jpg)\n\n我们对描述变化的数据结构进行了约定：\n\n- 对象类型和数组类型的值使用 `_properties` 字段描述，对应值被源数据对应的数据类型包裹\n- 基本数据类型的值根据具体值的状态 `_status` 决定展示的字段\n  - 相等（Equal）：使用 `_origin` 表示值\n  - 新增（Add）：使用 `_target` 表示新增的值\n  - 删除（Delete）：使用 `_origin` 表示删除的值\n  - 冲突（Conflict）：使用 `_orign` 表示更改前的值，`_target` 表示更改后的值\n\n你也许会发现即便是对象类型和数组类型，也会有 `_status` 字段描述更改状态。这是因为我们在交互界面上采取了**自底向上**的状态变更显示策略。例如，当一个组件配置数据大部分保持不变的情况下，样式配置字段 `style` 中的 `height` 配置项改变了值，那么除了描述该字段的 Schema 结构中状态字段 `_status` 会显示为冲突（Conflict）外，在递归返回的过程中，亦会将层级更高的对象或数组状态标记为冲突（Conflict）。\n\n> 需要特别说明的是，如果下层结构仅有一种变化状态时，上层结构会显示该变化状态，而下层结构存在不只一种变化状态时，则上层会统一表示为冲突状态。\n\n![状态自底向上传递显示策略](http://img.mrsingsing.com/diff-tool-status-display-tatics.jpg)\n\n这样处理的目的，是为了树结构在可视化视图组装渲染后能够更清晰地让配置人员知道各节点的状态。树状的图形能够让开发人员快速知道哪些组件配置项发生了变更，并能沿着路径找到变化的根源。\n\n![可视化冲突解决界面](http://img.mrsingsing.com/diff-tool-path-to-root.jpg)\n\n## Diff 功能实现\n\n约定好对比后的数据结构后，那么就要通过方法封装对变化前后的页面配置数据进行比较。\n\n在实现 diff 方法前，就设想实现的方法应该能保证在不同的配置数据结构下也能使用。也就是说，实现过程需要脱离业务相关的代码，尽可能保证方法通用性。\n\n而在实现过程中，我们遇到的其中一个问题就是当对比双方的数组类型且其数组成员为对象类型时，我们需要为此类情况提供用于匹配的方法。\n\n我们以 TotoroX 的配置为例来解释为什么需要为数组结构的比较提供匹配方法。例如 TotoroX 的配置数据中 `eventList` 字段表示组件相关的事件列表，每个事件（对象）之间的 `name` 字段是唯一的，因此我们在对比 `eventList` 数组时，需要明确对象数组中各成员的 `name` 键值为严格相等，才能对双方进行后续的 diff。而实际上，并非所有对象数组都通过 `name` 字段进行匹配，将类似的代码参杂到通用类型方法中显然是不恰当的。因此，我们需要提高类库的可拓展性，将用于对象数组匹配的方法抽离，并通过配置的形式植入。\n\n![Button组件配置](http://img.mrsingsing.com/diff-tool-button-data.jpeg)\n\n### 数组辅助方法\n\n对象数组间的匹配筛选在实现中应用的场景是较多的，因此我们封装了一系列的辅助方法减少重复的代码，包括：\n\n**数组差集函数**\n\n通过数组成员间逐一对比，筛选出两数组中所有成员的差集集合并返回（仅限于数组成员为基本类型值）\n\n```js\nfunction getDifference(a, b) {\n  return [...new Set(a.filter(x => !new Set(b).has(x)))];\n}\n```\n\n功能同上，当对象数组成员为对象类型时使用，需要提供用于匹配的比较器函数，返回结果只保留以参数 `a` 传入的数组的成员项\n\n```js\nfunction getDifferenceWith(a, b, comparator = (x, y) => x === y) {\n  return a.filter(x => b.findIndex(y => comparator(x, y)) === -1);\n}\n```\n\n**数组交集函数**\n\n通过数组成员间逐一对比，筛选出两数组中所有成员的交集集合并返回（仅限于数组成员为基本类型值）\n\n```js\nfunction getIntersection(a, b) {\n  return [...new Set(a.filter(x => new Set(b).has(x)))];\n}\n```\n\n功能同上，当对象数组成员为对象类型时使用，需要提供用于匹配的比较器函数，返回结果只保留以参数 `a` 传入的数组的的成员项\n\n```js\nfunction getIntersectionWith(a, b, comparator = (x, y) => x === y) {\n  return a.filter(x => b.findIndex(y => comparator(x, y)) !== -1);\n}\n```\n\n**数组并集函数**\n\n```js\nfunction getUnionWith(a, b, comparator = (x, y) => x === y) {\n  return Array.from(new Set([...a, ...b.filter(x => a.findIndex(y => comparator(x, y)) === -1)]));\n}\n```\n\n**数组去重函数**\n\n```js\nfunction getDedupeBy(arr, comparator = (x, y) => x === y) {\n  return arr.reduce((acc, v) => {\n    if (!acc.some(x => comparator(v, x))) {\n      acc.push(v);\n    }\n    return acc;\n  }, []);\n}\n```\n\n可以留意到，上述辅助函数除了用于匹配的两个数组类型的参数外，还需要提供一个 `comparator` 的参数。`comparator` 意为比较器，类型为函数类型，用于封装方法内部 `filter` 函数对应的回调函数，从而筛选出用以匹配数组的对象成员。如：\n\n```js\nconst comparator = (x, y) => x.id === y.id;\n```\n\n表示为 `x` 对象的 `id` 字段与 `y` 对象的 `id` 字段完全相等时，表示 `x` 对象和 `y` 对象为匹配的双方。\n\n通过这样的形式，我们能够将配置中数组形式存在的配置项的匹配字段以 `comparator` 的形式配置植入，而不必在实现的代码中植入业务相关的代码。当然，仅仅如此并不够的，因为还无法解决到底配置结构中到底哪个层级是数组类型的值，下面会详细解析如何解决这个问题。\n\n### 差异化流程实现\n\n根据 JSON 的不同类型的处理方式的不同，我们实现了三个方法：\n\n- `diffObject`：用于对象类型值之间的对比方法，通过 `Object.keys` 获取各自对象的键名集合，配合数组差集函数和数组交集函数，可以筛选出新对象中新增的字段集合、旧对象中删除的字段集合以及新对象和旧对象共有的字段集合\n- `diffArray`：用于数组类型值之间的对比方法，通过 `comparator` 比较函数入参，同样利用差集函数和交集函数，分别筛选出新数组中新增的数组成员、旧数组中删除的数组成员以及各自数组中共有的数组成员\n- `diffValue`：用于基本数据类型值的对比方法，采用严格相等的对比方式，若相等则为相等（Equal）状态，否则为冲突状态（Conflict）\n\n引用类型的值比较（也就是 `diffObject` 和 `diffArray`）在匹配到键值或数组成员时，会利用调和函数作为匹配跳板，根据传入数据源类型不同继续对下层结构的值递归执行上述三种不同数据类型的方法。\n\n而旧对象/旧数组中删除的值或新对象/新数组中新增的值，则不会再进行深层次的递归，会直接投放到另一个处理方法 `getRecursion` 中递归修改下层结构中的变化状态。\n\n![diff结构流程图](http://img.mrsingsing.com/diff-tool-workflow.jpg)\n\n对象类型值之间的比较，我们会使用 `Object.keys()` 方法分别获取两个对比对象的键名，并通过数组辅助方法拆分为三组：共同拥有的键名的集合、仅有 `origin` 对象（理解为变化前的配置对象）拥有的键名的集合和 `target` 对象（理解为变化后的配置对象）拥有的键名集合。\n\n由此可得，共同拥有的键名集合需要通过比较得出变化状态。而 `origin` 对象拥有的键名，则表示 `target` 对象没有，也就是 `origin` 对象集合中的键值被删除了，会被标记为删除状态。相似地，仅 `target` 对象拥有的键名表示 `origin` 没有该键名，则 `target` 的键值为新增配置项，会被标记为新增状态。\n\n刚才提到对象数组类型之间需要通过比较器函数 `comparator` 用于匹配，但是需要提供一种让运行机制知道什么样的数组对比需要用怎样的 `comparator`。在运行 diff 前，我们通过以递归路径为键名，以 `comparator` 为键值组成的配置对象传入 `diff` 函数。\n\n在向下递归进行配置项比较时，遇到对象类型的值，会将键名传入调和函数。在函数内部，会被推入一个已声明的面包屑栈（也称为递归路径，以数组形式表示），当返回值时，又会退栈。当检查到下层结构为数组类型时，会通过 `Array.prototype.join()` 方法将面包屑栈中的值合成键名路径，匹配外部传入的比较器配置后，将下层数组结构匹配所需的 `comparator` 传入 `diffArray` 中。这样就解决了对象数组匹配的问题，同时也将相关的业务代码抽离至外部，提升了方法的通用性和可配置性。\n\n```js\nconst comparator = {\n  // 如果原始数据为数组类型（也就是传入数据最外层为数组类型），必须有 init 字段作为 comparator 函数\n  init: (a, b) => a.name === b.name && a.id === b.id,\n  eventList: (a, b) => a.name === b.name,\n  'eventList.value': (a, b) => a === b,\n  'eventList.subEvents': (a, b) => a.id === b.id,\n  'eventList.subEvents.actions': (a, b) => a.id === b.id,\n  animation: (a, b) => a.antType === b.antType,\n};\n```\n\n⚠️**注意**：如果原始数据为数组类型，则必须提供 `init` 作为根（顶层）结构的比较器函数。\n\n上述就是 diff 功能实现过程中遇到的主要问题的解决方案，但是仅对两路的配置数据进行 diff 是不够的，这主要是从我们本身 TotoroX 的业务考虑。如前文所述 `origin` 可以为用于创建页面的模版，`target` 为基于模版创建的页面，但后续需求变更时会对模版数据进行修改，而在我们的系统中并不会同步到创建的页面，那么模版修改后需要将修改的内容同步到之前创建的页面，就需要提供一个用于合并新模版与旧页面的方法，下面我们就聊聊 merge 功能的实现。\n\n## Merge 功能实现\n\n在对 merge 功能实现过程进行讲解前，我们需要对 git 的合并策略进行一定程度的了解。\n\ngit 采用三路合并策略：\n\n```\nB - C - D master(*)\n \\\n  E - F dev\n```\n\n以我们日常的开发协作流程为例，当前分支也就是主分支为 `master`，当尝试把 `dev` 开发分支合并到 `master` 时，两个分支共同拥有的提交就是 commitB，我们将该提交 commit 称为 `base`，`master` 分支最新的提交 commitD 称为 `ours`，而 `dev` 分支最新的提交 commitF 称为 `theirs`。\n\n那么 git 是怎样合并 `ours` 和 `theirs` 的呢？\n\n在合并时，会参考他们的共同祖先 `base`，并根据下面策略进行合并。\n\n| 祖先（base） | HEAD（ours） | 分支（theirs） | 结果     | 说明                                                             |\n| ------------ | ------------ | -------------- | -------- | ---------------------------------------------------------------- |\n| A            | A            | A              | A        |                                                                  |\n| A            | A            | B              | B        | 如果一方修改了一行，那么这一行选择修改版的                       |\n| A            | B            | A              | B        | 同上                                                             |\n| A            | B            | B              | B        | 如果某一行双方拥有相同的变更，则选择修改过的行                   |\n| A            | B            | C              | conflict | 如果某一行双方都修改了，且修改得不一样，则报告冲突，需要用户解决 |\n\n根据上表规则，合并过程类似这样：\n\n![合并过程](http://img.mrsingsing.com/diff-tool-merge-strategy.png)\n\n可以看到，第四行，双方都修改了，且各自修改的内容不一样，所以 git 不知道怎么解决，所以就把问题抛给用户了。\n\n### 根节点层级筛选合并\n\n我们在实现 merge 功能时，正是采用了与此种合并策略一致的方式。在 merge 的合并流程中，原始数据即为**祖先**（base），而实际需要合并的两份数据分别为 **Head**（ours）和**分支**（theirs）。我们将 `base` 作为中间者，以此判断两份配置数据哪些部分是属于原始数据的，哪些部分又是新数据。\n\n首先，我们分别将新数据与共同组件 `base` 进行 diff 操作，获得分别的 JSON Schema 结构的结果，后续再对结果进行 mergeBranch 的操作。\n\n```js\nfunction merge(base, ours, theirs, diffComparator, mergeComparator) {\n  const originDiff = diff(base, ours, diffComparator);\n  const targetDiff = diff(base, theris, diffComparator);\n\n  const newDataSchema = mergeBranch(originDiff, targetDiff, mergeComparator);\n\n  return newDataSchema;\n}\n```\n\n而由于 merge 是根据两两 diff 后的 Schema 结构的 JSON，我们先从**根节点**的 `_status` 字段匹配进行区分，共有五种情况：\n\n| 源配置数据根节点状态 | 变更配置数据根节点状态 | 说明                                                                                                                                  |\n| -------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| Equal                | Equal                  | 表示 `base` 和 `ours` 完全相等，`base` 和 `theirs` 完全相等，即表示三路完全相等                                                       |\n| Equal                | Updated                | 表示 `base` 和 `ours` 完全相等，`base` 和 `theirs` 存在变更，即单路变更，最终给你会采用变更路数据                                     |\n| Updated              | Equal                  | 表示 `base` 和 `ours` 存在变更，`base` 和 `theirs` 完全相等，即单路变更，最终给你会采用变更路数据                                     |\n| Updated              | Updated                | 表示 `base` 和 `ours` 存在变更，`base` 和 `theirs` 也存在变更，但是变更对应的值不相等，即三路冲突                                     |\n| Updated              | Updated                | 表示 `base` 和 `ours` 存在变更，`base` 和 `theirs` 也存在变更，但是变更对应的值相等，实际上 `ours` 和 `theirs` 变更值与 `base` 值冲突 |\n\n![变更状态韦恩图](http://img.mrsingsing.com/diff-tool-merge-venn-diagram.jpg)\n\n对上述五种情况进行分析归纳后，在代码实现层面上可以大致分为三个方向处理：\n\n1. 三路相等（A-A-A）=> `mergeUnmodified`（相当于上文韦恩图天蓝色部分中状态为 `equal` 的部分）\n2. 单路变更，采用变更路数据（A-A-B、A-B-A）=> `mergeUpdated`（相当于上文韦恩图紫色和橙色部分，表示的是 `base` 存在但是存在变更的状态，可以是完全或局部的删除和冲突，也可以是局部配置项的新增，但是不可能是完全的新增）\n3. 两路变更，根据变更情况选择或保留冲突状态并提供手动处理方式，变更又分为新增、删除和修改（A-B-B、A-B-C）=> `mergeConflict`（相当于上文韦恩图绿色、红色和蓝灰色）\n\n三路相等的情况是最好处理的，在对根节点进行遍历时匹配两者的 `_status` 变化状态为相等状态（`equal`）时即表明三路相等。\n\n单路变更的情况，在对根节点进行遍历时匹配两者的 `_status` 为相等（`equal`）而另一方为不相等，即为需要采用变更路数据。\n\n而对于两路变更的情况，我们不能单纯地以根节点的状态作为区分，这是因为我们采用了上文提及过的**自底向上的状态变更显示策略**，所以根节点呈现为变更状态，不代表整个结构内部的属性均为变更状态，也可能因为某个配置项的变更，导致结构树上层的状态改变。所以对于这种情况，我们又能细分为两种情况进行处理：\n\n1. 通过 `comparator` 比较函数能两两匹配的节点树，实际上为 `base`、`ours` 和 `theirs` 三路均存在该根节点的，则需要对双方子孙层级的节点进行递归遍历并逐一对比（相当于上文韦恩图中蓝色 `conflict` 的部分）\n2. 在对比双方的配置数据中，根节点状态 `_status` 为新增状态（`add`）且子孙层级的配置属性值也为新增状态时，则可判断该配置树为完全新增（相当于上文韦恩图中绿色 `add` 的部分），按照约定的合并策略，需要保留整个配置树\n\n### 子孙层级筛选合并\n\n下面我们把重点聚焦于两路变更的情况下子孙层级筛选合并的实现。\n\n从根节点的变更状态的角度分析（已排除完全新增的配置节点树），可以大致分为五种情况：\n\n| base_ours 根节点状态 | base_theirs 根节点状态 | 说明                                                                                                                                                |\n| -------------------- | ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Add                  | Add                    | 表示 `base` 没有某项配置项，而 `ours` 和 `theris` 新增了某项配置项                                                                                  |\n| Conflict             | Conflict               | 表示 `base` 存在某项配置项，`ours` 也存在该项配置项但是值与 `base` 不同，`theris` 也存在该项配置项但是值与 `base` 也不同（未必与 `ours` 相同/不同） |\n| Conflict             | Delete                 | 表示 `base` 存在某项配置项，`ours` 也存在该项配置项但是值与 `base` 不同，而 `theris` 则不存在该项配置项                                             |\n| Delete               | Conflict               | 表示 `base` 存在某项配置项，`ours` 不存在该项配置项，而 `theris` 存在该项配置项且值与 `base` 不同                                                   |\n| Delete               | Delete                 | 表示 base 存在某项配置项，`ours` 和 `theris` 均不存在该配置项                                                                                       |\n\n我们以一个简单的代码示例说明：\n\n![三路合并配置代码示例](http://img.mrsingsing.com/diff-tool-merge-code-demo.jpg)\n\n结合上文提及五种两两比对存在变更状态时的情况，并结合代码示例得出以下结论：\n\n- `color` 对应第一种情况，`base` 没有该配置项，而 `ours` 和 `theirs` 则有\n- `width` 对应第二种情况，`base` 有该配置项，而 `ours` 和 `theirs` 同样有该配置项，但是 `ours` 和 `theirs` 的值存在差异\n- `height` 同样对应第二种情况，与 `width` 配置项不同的是，`ours` 和 `theirs` 的值严格相等\n- `translateX` 对应第三种情况，`base` 与 `ours` 有该配置，且值冲突，而 `theirs` 则删除了该配置项\n- `translateX` 对应第四种情况，`base` 与 `theirs` 有该配置，且值冲突，而 `ours` 则删除了该配置项\n- `line-height` 对应第五种情况，仅 `base` 存在该配置项，`ours` 和 `theirs` 均删除了该配置项\n\n> 这里提及的新增或删除字段只为覆盖更完整的功能，实际的可视化配置业务中，因为组件的配置项基本固定且均提供了默认值，所以出现新增或删除字段的情况较少。\n\n最后基于 `base` 进行 diff 后得出如下两份 JSON Schema 结构差异化数据：\n\n![diff-between-base-and-ours](http://img.mrsingsing.com/diff-between-base-and-ours.jpg)\n\n![diff-between-base-and-theirs](http://img.mrsingsing.com/diff-between-base-and-theirs.jpg)\n\n基于三路合并的策略，当三路值均不同时会保留差异让用户手动解决，当变更两路值相同或新增时则保留相同值，最后合并后得出新的 JSON Schema 配置数据：\n\n![Merge base and ours and theirs](http://img.mrsingsing.com/diff-tool-merge-base-ours-and-theirs.jpeg)\n\n## Revert 功能实现\n\n最终通过自动合并和手动解决冲突，完整的配置数据应该所有节点都表示为相等状态。通过对返还的 JSON Schema 结构的数据递归还原，自动新建页面即完成整个批量更新页面的功能。\n\n---\n\n**参考资料**：\n\n- [三路合并 Git 学习笔记 17](https://blog.csdn.net/longintchar/article/details/83049840)\n","source":"_posts/practice-of-page-batch-update-tool-in-visual-configuration-system.md","raw":"---\ntitle: 可视化配置系统页面批量更新工具的开发实践\ndate: '2019-11-15'\n---\n\n> 首发于：[可视化配置系统页面批量更新工具的开发实践](https://juejin.im/post/5dc8fd92f265da4d287f4551)\n\nTotoroX 作为 PPmoney 集团内部集 UI 和业务逻辑于一体的前端页面可视化配置系统，为运营部门提供快速构建前端页面的解决方案。该系统为页面开发及运营人员提供了强大的组件市场，通过拖拽、表单配置等方式实现专题页面的业务需求。目前已支撑集团 850+营销活动页面。\n\n## 业务痛点\n\n在产品设计阶段，产品经理会根据对用户的调研，借助用户画像理解用户的需求，想想用户使用的场景，以及他们可能会遇到的困难。随着产品上线后，运营团队通过转化漏斗分析用户交互行为以及最终的转化的实际效果。所以这个阶段，随着真实用户群体的积累，在设计阶段虚构的用户画像需要重新调研、设想。\n\n而在技术的角度，我们也希望通过用户行为数据，为产品运营提供更好的支撑，例如为不同的用户提供不同 UI 的前端页面，通过对比的方法观察数据变化，以此作为对用户行为的准确判断。\n\n以下面的营销活动页为例，我们会在既有的页面配置中生成新的页面，并根据设计要求进行局部的调整，除了 UI 部分，内部逻辑包括埋点数据、事件链条关系等也会进行相关的修正。在此需求背景之下，如果需要人工手动对每个配置页面进行修改，这将会耗费大量的人力资源。而且，上文提到会涉及逻辑的修改，配置人员不易发现变更的地方，无法对修改后的页面进行校验。综上所述，我们需要一款对比前后变化的工具，能够可视化地对不同的配置数据进行对比，并通过图形绘制的形式清晰知道配置数据树中哪些节点没有修改，哪些节点修改了，修改前后的值又是什么，就好像我们进行代码协助时通过 `git diff` 能够知道文件中哪行代码发生了冲突，通过人工判断对冲突进行修改合并，并最终达到我们需要的效果。\n\n![AB Test](http://img.mrsingsing.com/diff-tool-abtest.jpg)\n\nTotoroX 基于用户配置的数据组装生成页面，配置数据均由组件市场的物料支撑，单个组件的配置数据结构基本相同，包括但不限于：唯一标识、组件名称、组件属性、组件样式、组件事件链以及动画相关配置等。组件间在配置数据的集合中是扁平化的，通过各组件配置数据中的标识集合相互关联起来，这样的数据结构设计避免了因为嵌套层级过深而产生的问题。基于这些条件，为多路差异化对比以及合并提供了可能。\n\n<!-- more -->\n\n## 差异化配置数据结构的设计\n\n在进行配置数据的对比合并前，需要设计出能够准确描述数据变化前后的数据结构。\n\n在 TotoroX 中，配置数据的结构模式与 JSON 的结构模式一致，因此数据结构的设计应以 JSON 的数据结构为基础。\n\n而在 JSON 中值存在以下几种数据类型：\n\n- null\n- 字符串\n- 布尔值\n- 数值\n- 数组\n- 对象\n\n因此，我们不用考虑诸如 Date、Function、Symbol、Set 等数据类型的值。\n\n同时，在设定的配置数据中不能存在空值 `null`，如果要表示不对某配置项作配置，实际上会采用默认的配置属性，所以在实际配置数据中，是不会存在空值存在，可以忽略这种情况。\n\n综合上述，从大致上能分为两大类数据类型：\n\n- 基本数据类型：字符串、布尔值、数值\n- 引用数据类型：数组、对象\n\n那么我们是怎样去描述 JSON 对比前后变更状态呢？\n\nJSON 是目前应用广泛的数据交换格式，那么交换双方肯定需要对数据进行约定和校验，而 JSON Schema 就是扮演定义 JSON 数据约束的标准。因此，我们尝试引入 JSON Schema 的概念，并结合实际功用进行改造。\n\n传统的 JSON Schema 表现为这样：\n\n```json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"http://example.com/product.schema.json\",\n  \"title\": \"Product\",\n  \"description\": \"A product from Acme's catalog\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"productId\": {\n      \"description\": \"The unique identifier for a product\",\n      \"type\": \"integer\"\n    },\n    \"productName\": {\n      \"description\": \"Name of the product\",\n      \"type\": \"string\"\n    },\n    \"price\": {\n      \"description\": \"The price of the product\",\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"tags\": {\n      \"description\": \"Tags for the product\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"dimensions\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"length\": {\n          \"type\": \"number\"\n        },\n        \"width\": {\n          \"type\": \"number\"\n        },\n        \"height\": {\n          \"type\": \"number\"\n        }\n      },\n      \"required\": [\"length\", \"width\", \"height\"]\n    }\n  },\n  \"required\": [\"productId\", \"productName\", \"price\"]\n}\n```\n\n从形式上来讲，JSON Schema 还是 JSON 的格式，但不同的是，JSON Schema 会在原来的 JSON 基础上在每个层级的数据外包装了一层用以描述对应层级值的相关信息，包括对应层级的值、描述、数据类型以及其它额外配置的信息。\n\n在结构上，我们沿用了 JSON Schema 的一套标准，在源数据基础上通过遍历递归的方法对数据进行描述。而在描述的信息上，我们针对实际的应用场景进行了定制。\n\n描述信息中必不可少的就是对数据变化信息的描述，我们参考了 Git 管理代码变更的策略，在两两对比下，我们梳理出可能产生的四种值比较情况：\n\n- **相等（Equal）**：当两个基本数据类型的值严格相等时，则为相等状态；而对于引用数据类型，需要提供额外的手段进行匹配\n- **新增（Add）**：当对象间对比时，目标对象存在新增的键时，描述该键值为新增状态；同理，当数组中无对应的匹配项时，则为新增状态\n- **删除（Delete）**：与新增状态类似，当对象间对比时，目标对象存在删除的键时，描述该键值为删除状态，而数组中对应的匹配项不存在时，则为删除状态\n- **冲突（Conflict）**：当两个基本数据类型的值不严格相等时，则为冲突状态\n\n举个例子，如下为两个个仅有一个按钮组件的配置页数据集合：\n\n![修改前后的配置数据](http://img.mrsingsing.com/diff-tool-data-structure-comparation-.jpg)\n\n通过 diff 后预设能产生的数据结构：\n\n![对比后产生的数据结构](http://img.mrsingsing.com/diff-tool-result-data-structure.jpg)\n\n我们对描述变化的数据结构进行了约定：\n\n- 对象类型和数组类型的值使用 `_properties` 字段描述，对应值被源数据对应的数据类型包裹\n- 基本数据类型的值根据具体值的状态 `_status` 决定展示的字段\n  - 相等（Equal）：使用 `_origin` 表示值\n  - 新增（Add）：使用 `_target` 表示新增的值\n  - 删除（Delete）：使用 `_origin` 表示删除的值\n  - 冲突（Conflict）：使用 `_orign` 表示更改前的值，`_target` 表示更改后的值\n\n你也许会发现即便是对象类型和数组类型，也会有 `_status` 字段描述更改状态。这是因为我们在交互界面上采取了**自底向上**的状态变更显示策略。例如，当一个组件配置数据大部分保持不变的情况下，样式配置字段 `style` 中的 `height` 配置项改变了值，那么除了描述该字段的 Schema 结构中状态字段 `_status` 会显示为冲突（Conflict）外，在递归返回的过程中，亦会将层级更高的对象或数组状态标记为冲突（Conflict）。\n\n> 需要特别说明的是，如果下层结构仅有一种变化状态时，上层结构会显示该变化状态，而下层结构存在不只一种变化状态时，则上层会统一表示为冲突状态。\n\n![状态自底向上传递显示策略](http://img.mrsingsing.com/diff-tool-status-display-tatics.jpg)\n\n这样处理的目的，是为了树结构在可视化视图组装渲染后能够更清晰地让配置人员知道各节点的状态。树状的图形能够让开发人员快速知道哪些组件配置项发生了变更，并能沿着路径找到变化的根源。\n\n![可视化冲突解决界面](http://img.mrsingsing.com/diff-tool-path-to-root.jpg)\n\n## Diff 功能实现\n\n约定好对比后的数据结构后，那么就要通过方法封装对变化前后的页面配置数据进行比较。\n\n在实现 diff 方法前，就设想实现的方法应该能保证在不同的配置数据结构下也能使用。也就是说，实现过程需要脱离业务相关的代码，尽可能保证方法通用性。\n\n而在实现过程中，我们遇到的其中一个问题就是当对比双方的数组类型且其数组成员为对象类型时，我们需要为此类情况提供用于匹配的方法。\n\n我们以 TotoroX 的配置为例来解释为什么需要为数组结构的比较提供匹配方法。例如 TotoroX 的配置数据中 `eventList` 字段表示组件相关的事件列表，每个事件（对象）之间的 `name` 字段是唯一的，因此我们在对比 `eventList` 数组时，需要明确对象数组中各成员的 `name` 键值为严格相等，才能对双方进行后续的 diff。而实际上，并非所有对象数组都通过 `name` 字段进行匹配，将类似的代码参杂到通用类型方法中显然是不恰当的。因此，我们需要提高类库的可拓展性，将用于对象数组匹配的方法抽离，并通过配置的形式植入。\n\n![Button组件配置](http://img.mrsingsing.com/diff-tool-button-data.jpeg)\n\n### 数组辅助方法\n\n对象数组间的匹配筛选在实现中应用的场景是较多的，因此我们封装了一系列的辅助方法减少重复的代码，包括：\n\n**数组差集函数**\n\n通过数组成员间逐一对比，筛选出两数组中所有成员的差集集合并返回（仅限于数组成员为基本类型值）\n\n```js\nfunction getDifference(a, b) {\n  return [...new Set(a.filter(x => !new Set(b).has(x)))];\n}\n```\n\n功能同上，当对象数组成员为对象类型时使用，需要提供用于匹配的比较器函数，返回结果只保留以参数 `a` 传入的数组的成员项\n\n```js\nfunction getDifferenceWith(a, b, comparator = (x, y) => x === y) {\n  return a.filter(x => b.findIndex(y => comparator(x, y)) === -1);\n}\n```\n\n**数组交集函数**\n\n通过数组成员间逐一对比，筛选出两数组中所有成员的交集集合并返回（仅限于数组成员为基本类型值）\n\n```js\nfunction getIntersection(a, b) {\n  return [...new Set(a.filter(x => new Set(b).has(x)))];\n}\n```\n\n功能同上，当对象数组成员为对象类型时使用，需要提供用于匹配的比较器函数，返回结果只保留以参数 `a` 传入的数组的的成员项\n\n```js\nfunction getIntersectionWith(a, b, comparator = (x, y) => x === y) {\n  return a.filter(x => b.findIndex(y => comparator(x, y)) !== -1);\n}\n```\n\n**数组并集函数**\n\n```js\nfunction getUnionWith(a, b, comparator = (x, y) => x === y) {\n  return Array.from(new Set([...a, ...b.filter(x => a.findIndex(y => comparator(x, y)) === -1)]));\n}\n```\n\n**数组去重函数**\n\n```js\nfunction getDedupeBy(arr, comparator = (x, y) => x === y) {\n  return arr.reduce((acc, v) => {\n    if (!acc.some(x => comparator(v, x))) {\n      acc.push(v);\n    }\n    return acc;\n  }, []);\n}\n```\n\n可以留意到，上述辅助函数除了用于匹配的两个数组类型的参数外，还需要提供一个 `comparator` 的参数。`comparator` 意为比较器，类型为函数类型，用于封装方法内部 `filter` 函数对应的回调函数，从而筛选出用以匹配数组的对象成员。如：\n\n```js\nconst comparator = (x, y) => x.id === y.id;\n```\n\n表示为 `x` 对象的 `id` 字段与 `y` 对象的 `id` 字段完全相等时，表示 `x` 对象和 `y` 对象为匹配的双方。\n\n通过这样的形式，我们能够将配置中数组形式存在的配置项的匹配字段以 `comparator` 的形式配置植入，而不必在实现的代码中植入业务相关的代码。当然，仅仅如此并不够的，因为还无法解决到底配置结构中到底哪个层级是数组类型的值，下面会详细解析如何解决这个问题。\n\n### 差异化流程实现\n\n根据 JSON 的不同类型的处理方式的不同，我们实现了三个方法：\n\n- `diffObject`：用于对象类型值之间的对比方法，通过 `Object.keys` 获取各自对象的键名集合，配合数组差集函数和数组交集函数，可以筛选出新对象中新增的字段集合、旧对象中删除的字段集合以及新对象和旧对象共有的字段集合\n- `diffArray`：用于数组类型值之间的对比方法，通过 `comparator` 比较函数入参，同样利用差集函数和交集函数，分别筛选出新数组中新增的数组成员、旧数组中删除的数组成员以及各自数组中共有的数组成员\n- `diffValue`：用于基本数据类型值的对比方法，采用严格相等的对比方式，若相等则为相等（Equal）状态，否则为冲突状态（Conflict）\n\n引用类型的值比较（也就是 `diffObject` 和 `diffArray`）在匹配到键值或数组成员时，会利用调和函数作为匹配跳板，根据传入数据源类型不同继续对下层结构的值递归执行上述三种不同数据类型的方法。\n\n而旧对象/旧数组中删除的值或新对象/新数组中新增的值，则不会再进行深层次的递归，会直接投放到另一个处理方法 `getRecursion` 中递归修改下层结构中的变化状态。\n\n![diff结构流程图](http://img.mrsingsing.com/diff-tool-workflow.jpg)\n\n对象类型值之间的比较，我们会使用 `Object.keys()` 方法分别获取两个对比对象的键名，并通过数组辅助方法拆分为三组：共同拥有的键名的集合、仅有 `origin` 对象（理解为变化前的配置对象）拥有的键名的集合和 `target` 对象（理解为变化后的配置对象）拥有的键名集合。\n\n由此可得，共同拥有的键名集合需要通过比较得出变化状态。而 `origin` 对象拥有的键名，则表示 `target` 对象没有，也就是 `origin` 对象集合中的键值被删除了，会被标记为删除状态。相似地，仅 `target` 对象拥有的键名表示 `origin` 没有该键名，则 `target` 的键值为新增配置项，会被标记为新增状态。\n\n刚才提到对象数组类型之间需要通过比较器函数 `comparator` 用于匹配，但是需要提供一种让运行机制知道什么样的数组对比需要用怎样的 `comparator`。在运行 diff 前，我们通过以递归路径为键名，以 `comparator` 为键值组成的配置对象传入 `diff` 函数。\n\n在向下递归进行配置项比较时，遇到对象类型的值，会将键名传入调和函数。在函数内部，会被推入一个已声明的面包屑栈（也称为递归路径，以数组形式表示），当返回值时，又会退栈。当检查到下层结构为数组类型时，会通过 `Array.prototype.join()` 方法将面包屑栈中的值合成键名路径，匹配外部传入的比较器配置后，将下层数组结构匹配所需的 `comparator` 传入 `diffArray` 中。这样就解决了对象数组匹配的问题，同时也将相关的业务代码抽离至外部，提升了方法的通用性和可配置性。\n\n```js\nconst comparator = {\n  // 如果原始数据为数组类型（也就是传入数据最外层为数组类型），必须有 init 字段作为 comparator 函数\n  init: (a, b) => a.name === b.name && a.id === b.id,\n  eventList: (a, b) => a.name === b.name,\n  'eventList.value': (a, b) => a === b,\n  'eventList.subEvents': (a, b) => a.id === b.id,\n  'eventList.subEvents.actions': (a, b) => a.id === b.id,\n  animation: (a, b) => a.antType === b.antType,\n};\n```\n\n⚠️**注意**：如果原始数据为数组类型，则必须提供 `init` 作为根（顶层）结构的比较器函数。\n\n上述就是 diff 功能实现过程中遇到的主要问题的解决方案，但是仅对两路的配置数据进行 diff 是不够的，这主要是从我们本身 TotoroX 的业务考虑。如前文所述 `origin` 可以为用于创建页面的模版，`target` 为基于模版创建的页面，但后续需求变更时会对模版数据进行修改，而在我们的系统中并不会同步到创建的页面，那么模版修改后需要将修改的内容同步到之前创建的页面，就需要提供一个用于合并新模版与旧页面的方法，下面我们就聊聊 merge 功能的实现。\n\n## Merge 功能实现\n\n在对 merge 功能实现过程进行讲解前，我们需要对 git 的合并策略进行一定程度的了解。\n\ngit 采用三路合并策略：\n\n```\nB - C - D master(*)\n \\\n  E - F dev\n```\n\n以我们日常的开发协作流程为例，当前分支也就是主分支为 `master`，当尝试把 `dev` 开发分支合并到 `master` 时，两个分支共同拥有的提交就是 commitB，我们将该提交 commit 称为 `base`，`master` 分支最新的提交 commitD 称为 `ours`，而 `dev` 分支最新的提交 commitF 称为 `theirs`。\n\n那么 git 是怎样合并 `ours` 和 `theirs` 的呢？\n\n在合并时，会参考他们的共同祖先 `base`，并根据下面策略进行合并。\n\n| 祖先（base） | HEAD（ours） | 分支（theirs） | 结果     | 说明                                                             |\n| ------------ | ------------ | -------------- | -------- | ---------------------------------------------------------------- |\n| A            | A            | A              | A        |                                                                  |\n| A            | A            | B              | B        | 如果一方修改了一行，那么这一行选择修改版的                       |\n| A            | B            | A              | B        | 同上                                                             |\n| A            | B            | B              | B        | 如果某一行双方拥有相同的变更，则选择修改过的行                   |\n| A            | B            | C              | conflict | 如果某一行双方都修改了，且修改得不一样，则报告冲突，需要用户解决 |\n\n根据上表规则，合并过程类似这样：\n\n![合并过程](http://img.mrsingsing.com/diff-tool-merge-strategy.png)\n\n可以看到，第四行，双方都修改了，且各自修改的内容不一样，所以 git 不知道怎么解决，所以就把问题抛给用户了。\n\n### 根节点层级筛选合并\n\n我们在实现 merge 功能时，正是采用了与此种合并策略一致的方式。在 merge 的合并流程中，原始数据即为**祖先**（base），而实际需要合并的两份数据分别为 **Head**（ours）和**分支**（theirs）。我们将 `base` 作为中间者，以此判断两份配置数据哪些部分是属于原始数据的，哪些部分又是新数据。\n\n首先，我们分别将新数据与共同组件 `base` 进行 diff 操作，获得分别的 JSON Schema 结构的结果，后续再对结果进行 mergeBranch 的操作。\n\n```js\nfunction merge(base, ours, theirs, diffComparator, mergeComparator) {\n  const originDiff = diff(base, ours, diffComparator);\n  const targetDiff = diff(base, theris, diffComparator);\n\n  const newDataSchema = mergeBranch(originDiff, targetDiff, mergeComparator);\n\n  return newDataSchema;\n}\n```\n\n而由于 merge 是根据两两 diff 后的 Schema 结构的 JSON，我们先从**根节点**的 `_status` 字段匹配进行区分，共有五种情况：\n\n| 源配置数据根节点状态 | 变更配置数据根节点状态 | 说明                                                                                                                                  |\n| -------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| Equal                | Equal                  | 表示 `base` 和 `ours` 完全相等，`base` 和 `theirs` 完全相等，即表示三路完全相等                                                       |\n| Equal                | Updated                | 表示 `base` 和 `ours` 完全相等，`base` 和 `theirs` 存在变更，即单路变更，最终给你会采用变更路数据                                     |\n| Updated              | Equal                  | 表示 `base` 和 `ours` 存在变更，`base` 和 `theirs` 完全相等，即单路变更，最终给你会采用变更路数据                                     |\n| Updated              | Updated                | 表示 `base` 和 `ours` 存在变更，`base` 和 `theirs` 也存在变更，但是变更对应的值不相等，即三路冲突                                     |\n| Updated              | Updated                | 表示 `base` 和 `ours` 存在变更，`base` 和 `theirs` 也存在变更，但是变更对应的值相等，实际上 `ours` 和 `theirs` 变更值与 `base` 值冲突 |\n\n![变更状态韦恩图](http://img.mrsingsing.com/diff-tool-merge-venn-diagram.jpg)\n\n对上述五种情况进行分析归纳后，在代码实现层面上可以大致分为三个方向处理：\n\n1. 三路相等（A-A-A）=> `mergeUnmodified`（相当于上文韦恩图天蓝色部分中状态为 `equal` 的部分）\n2. 单路变更，采用变更路数据（A-A-B、A-B-A）=> `mergeUpdated`（相当于上文韦恩图紫色和橙色部分，表示的是 `base` 存在但是存在变更的状态，可以是完全或局部的删除和冲突，也可以是局部配置项的新增，但是不可能是完全的新增）\n3. 两路变更，根据变更情况选择或保留冲突状态并提供手动处理方式，变更又分为新增、删除和修改（A-B-B、A-B-C）=> `mergeConflict`（相当于上文韦恩图绿色、红色和蓝灰色）\n\n三路相等的情况是最好处理的，在对根节点进行遍历时匹配两者的 `_status` 变化状态为相等状态（`equal`）时即表明三路相等。\n\n单路变更的情况，在对根节点进行遍历时匹配两者的 `_status` 为相等（`equal`）而另一方为不相等，即为需要采用变更路数据。\n\n而对于两路变更的情况，我们不能单纯地以根节点的状态作为区分，这是因为我们采用了上文提及过的**自底向上的状态变更显示策略**，所以根节点呈现为变更状态，不代表整个结构内部的属性均为变更状态，也可能因为某个配置项的变更，导致结构树上层的状态改变。所以对于这种情况，我们又能细分为两种情况进行处理：\n\n1. 通过 `comparator` 比较函数能两两匹配的节点树，实际上为 `base`、`ours` 和 `theirs` 三路均存在该根节点的，则需要对双方子孙层级的节点进行递归遍历并逐一对比（相当于上文韦恩图中蓝色 `conflict` 的部分）\n2. 在对比双方的配置数据中，根节点状态 `_status` 为新增状态（`add`）且子孙层级的配置属性值也为新增状态时，则可判断该配置树为完全新增（相当于上文韦恩图中绿色 `add` 的部分），按照约定的合并策略，需要保留整个配置树\n\n### 子孙层级筛选合并\n\n下面我们把重点聚焦于两路变更的情况下子孙层级筛选合并的实现。\n\n从根节点的变更状态的角度分析（已排除完全新增的配置节点树），可以大致分为五种情况：\n\n| base_ours 根节点状态 | base_theirs 根节点状态 | 说明                                                                                                                                                |\n| -------------------- | ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Add                  | Add                    | 表示 `base` 没有某项配置项，而 `ours` 和 `theris` 新增了某项配置项                                                                                  |\n| Conflict             | Conflict               | 表示 `base` 存在某项配置项，`ours` 也存在该项配置项但是值与 `base` 不同，`theris` 也存在该项配置项但是值与 `base` 也不同（未必与 `ours` 相同/不同） |\n| Conflict             | Delete                 | 表示 `base` 存在某项配置项，`ours` 也存在该项配置项但是值与 `base` 不同，而 `theris` 则不存在该项配置项                                             |\n| Delete               | Conflict               | 表示 `base` 存在某项配置项，`ours` 不存在该项配置项，而 `theris` 存在该项配置项且值与 `base` 不同                                                   |\n| Delete               | Delete                 | 表示 base 存在某项配置项，`ours` 和 `theris` 均不存在该配置项                                                                                       |\n\n我们以一个简单的代码示例说明：\n\n![三路合并配置代码示例](http://img.mrsingsing.com/diff-tool-merge-code-demo.jpg)\n\n结合上文提及五种两两比对存在变更状态时的情况，并结合代码示例得出以下结论：\n\n- `color` 对应第一种情况，`base` 没有该配置项，而 `ours` 和 `theirs` 则有\n- `width` 对应第二种情况，`base` 有该配置项，而 `ours` 和 `theirs` 同样有该配置项，但是 `ours` 和 `theirs` 的值存在差异\n- `height` 同样对应第二种情况，与 `width` 配置项不同的是，`ours` 和 `theirs` 的值严格相等\n- `translateX` 对应第三种情况，`base` 与 `ours` 有该配置，且值冲突，而 `theirs` 则删除了该配置项\n- `translateX` 对应第四种情况，`base` 与 `theirs` 有该配置，且值冲突，而 `ours` 则删除了该配置项\n- `line-height` 对应第五种情况，仅 `base` 存在该配置项，`ours` 和 `theirs` 均删除了该配置项\n\n> 这里提及的新增或删除字段只为覆盖更完整的功能，实际的可视化配置业务中，因为组件的配置项基本固定且均提供了默认值，所以出现新增或删除字段的情况较少。\n\n最后基于 `base` 进行 diff 后得出如下两份 JSON Schema 结构差异化数据：\n\n![diff-between-base-and-ours](http://img.mrsingsing.com/diff-between-base-and-ours.jpg)\n\n![diff-between-base-and-theirs](http://img.mrsingsing.com/diff-between-base-and-theirs.jpg)\n\n基于三路合并的策略，当三路值均不同时会保留差异让用户手动解决，当变更两路值相同或新增时则保留相同值，最后合并后得出新的 JSON Schema 配置数据：\n\n![Merge base and ours and theirs](http://img.mrsingsing.com/diff-tool-merge-base-ours-and-theirs.jpeg)\n\n## Revert 功能实现\n\n最终通过自动合并和手动解决冲突，完整的配置数据应该所有节点都表示为相等状态。通过对返还的 JSON Schema 结构的数据递归还原，自动新建页面即完成整个批量更新页面的功能。\n\n---\n\n**参考资料**：\n\n- [三路合并 Git 学习笔记 17](https://blog.csdn.net/longintchar/article/details/83049840)\n","slug":"practice-of-page-batch-update-tool-in-visual-configuration-system","published":1,"updated":"2021-08-18T03:30:43.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99z0000av31p77r2jv2z","content":"<blockquote>\n<p>首发于：<a href=\"https://juejin.im/post/5dc8fd92f265da4d287f4551\" target=\"_blank\" rel=\"noopener\">可视化配置系统页面批量更新工具的开发实践</a></p>\n</blockquote>\n<p>TotoroX 作为 PPmoney 集团内部集 UI 和业务逻辑于一体的前端页面可视化配置系统，为运营部门提供快速构建前端页面的解决方案。该系统为页面开发及运营人员提供了强大的组件市场，通过拖拽、表单配置等方式实现专题页面的业务需求。目前已支撑集团 850+营销活动页面。</p>\n<h2 id=\"业务痛点\"><a href=\"#业务痛点\" class=\"headerlink\" title=\"业务痛点\"></a>业务痛点</h2><p>在产品设计阶段，产品经理会根据对用户的调研，借助用户画像理解用户的需求，想想用户使用的场景，以及他们可能会遇到的困难。随着产品上线后，运营团队通过转化漏斗分析用户交互行为以及最终的转化的实际效果。所以这个阶段，随着真实用户群体的积累，在设计阶段虚构的用户画像需要重新调研、设想。</p>\n<p>而在技术的角度，我们也希望通过用户行为数据，为产品运营提供更好的支撑，例如为不同的用户提供不同 UI 的前端页面，通过对比的方法观察数据变化，以此作为对用户行为的准确判断。</p>\n<p>以下面的营销活动页为例，我们会在既有的页面配置中生成新的页面，并根据设计要求进行局部的调整，除了 UI 部分，内部逻辑包括埋点数据、事件链条关系等也会进行相关的修正。在此需求背景之下，如果需要人工手动对每个配置页面进行修改，这将会耗费大量的人力资源。而且，上文提到会涉及逻辑的修改，配置人员不易发现变更的地方，无法对修改后的页面进行校验。综上所述，我们需要一款对比前后变化的工具，能够可视化地对不同的配置数据进行对比，并通过图形绘制的形式清晰知道配置数据树中哪些节点没有修改，哪些节点修改了，修改前后的值又是什么，就好像我们进行代码协助时通过 <code>git diff</code> 能够知道文件中哪行代码发生了冲突，通过人工判断对冲突进行修改合并，并最终达到我们需要的效果。</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-abtest.jpg\" alt=\"AB Test\"></p>\n<p>TotoroX 基于用户配置的数据组装生成页面，配置数据均由组件市场的物料支撑，单个组件的配置数据结构基本相同，包括但不限于：唯一标识、组件名称、组件属性、组件样式、组件事件链以及动画相关配置等。组件间在配置数据的集合中是扁平化的，通过各组件配置数据中的标识集合相互关联起来，这样的数据结构设计避免了因为嵌套层级过深而产生的问题。基于这些条件，为多路差异化对比以及合并提供了可能。</p>\n<a id=\"more\"></a>\n<h2 id=\"差异化配置数据结构的设计\"><a href=\"#差异化配置数据结构的设计\" class=\"headerlink\" title=\"差异化配置数据结构的设计\"></a>差异化配置数据结构的设计</h2><p>在进行配置数据的对比合并前，需要设计出能够准确描述数据变化前后的数据结构。</p>\n<p>在 TotoroX 中，配置数据的结构模式与 JSON 的结构模式一致，因此数据结构的设计应以 JSON 的数据结构为基础。</p>\n<p>而在 JSON 中值存在以下几种数据类型：</p>\n<ul>\n<li>null</li>\n<li>字符串</li>\n<li>布尔值</li>\n<li>数值</li>\n<li>数组</li>\n<li>对象</li>\n</ul>\n<p>因此，我们不用考虑诸如 Date、Function、Symbol、Set 等数据类型的值。</p>\n<p>同时，在设定的配置数据中不能存在空值 <code>null</code>，如果要表示不对某配置项作配置，实际上会采用默认的配置属性，所以在实际配置数据中，是不会存在空值存在，可以忽略这种情况。</p>\n<p>综合上述，从大致上能分为两大类数据类型：</p>\n<ul>\n<li>基本数据类型：字符串、布尔值、数值</li>\n<li>引用数据类型：数组、对象</li>\n</ul>\n<p>那么我们是怎样去描述 JSON 对比前后变更状态呢？</p>\n<p>JSON 是目前应用广泛的数据交换格式，那么交换双方肯定需要对数据进行约定和校验，而 JSON Schema 就是扮演定义 JSON 数据约束的标准。因此，我们尝试引入 JSON Schema 的概念，并结合实际功用进行改造。</p>\n<p>传统的 JSON Schema 表现为这样：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"$schema\"</span>: <span class=\"string\">\"http://json-schema.org/draft-07/schema#\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"$id\"</span>: <span class=\"string\">\"http://example.com/product.schema.json\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Product\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"A product from Acme's catalog\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"object\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"properties\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"productId\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"The unique identifier for a product\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"integer\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"productName\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"Name of the product\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"string\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"price\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"The price of the product\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"number\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"exclusiveMinimum\"</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"tags\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"Tags for the product\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"array\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"items\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"string\"</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"minItems\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"uniqueItems\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"dimensions\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"object\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"properties\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"length\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"number\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"width\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"number\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"height\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"number\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"required\"</span>: [<span class=\"string\">\"length\"</span>, <span class=\"string\">\"width\"</span>, <span class=\"string\">\"height\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"required\"</span>: [<span class=\"string\">\"productId\"</span>, <span class=\"string\">\"productName\"</span>, <span class=\"string\">\"price\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从形式上来讲，JSON Schema 还是 JSON 的格式，但不同的是，JSON Schema 会在原来的 JSON 基础上在每个层级的数据外包装了一层用以描述对应层级值的相关信息，包括对应层级的值、描述、数据类型以及其它额外配置的信息。</p>\n<p>在结构上，我们沿用了 JSON Schema 的一套标准，在源数据基础上通过遍历递归的方法对数据进行描述。而在描述的信息上，我们针对实际的应用场景进行了定制。</p>\n<p>描述信息中必不可少的就是对数据变化信息的描述，我们参考了 Git 管理代码变更的策略，在两两对比下，我们梳理出可能产生的四种值比较情况：</p>\n<ul>\n<li><strong>相等（Equal）</strong>：当两个基本数据类型的值严格相等时，则为相等状态；而对于引用数据类型，需要提供额外的手段进行匹配</li>\n<li><strong>新增（Add）</strong>：当对象间对比时，目标对象存在新增的键时，描述该键值为新增状态；同理，当数组中无对应的匹配项时，则为新增状态</li>\n<li><strong>删除（Delete）</strong>：与新增状态类似，当对象间对比时，目标对象存在删除的键时，描述该键值为删除状态，而数组中对应的匹配项不存在时，则为删除状态</li>\n<li><strong>冲突（Conflict）</strong>：当两个基本数据类型的值不严格相等时，则为冲突状态</li>\n</ul>\n<p>举个例子，如下为两个个仅有一个按钮组件的配置页数据集合：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-data-structure-comparation-.jpg\" alt=\"修改前后的配置数据\"></p>\n<p>通过 diff 后预设能产生的数据结构：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-result-data-structure.jpg\" alt=\"对比后产生的数据结构\"></p>\n<p>我们对描述变化的数据结构进行了约定：</p>\n<ul>\n<li>对象类型和数组类型的值使用 <code>_properties</code> 字段描述，对应值被源数据对应的数据类型包裹</li>\n<li>基本数据类型的值根据具体值的状态 <code>_status</code> 决定展示的字段<ul>\n<li>相等（Equal）：使用 <code>_origin</code> 表示值</li>\n<li>新增（Add）：使用 <code>_target</code> 表示新增的值</li>\n<li>删除（Delete）：使用 <code>_origin</code> 表示删除的值</li>\n<li>冲突（Conflict）：使用 <code>_orign</code> 表示更改前的值，<code>_target</code> 表示更改后的值</li>\n</ul>\n</li>\n</ul>\n<p>你也许会发现即便是对象类型和数组类型，也会有 <code>_status</code> 字段描述更改状态。这是因为我们在交互界面上采取了<strong>自底向上</strong>的状态变更显示策略。例如，当一个组件配置数据大部分保持不变的情况下，样式配置字段 <code>style</code> 中的 <code>height</code> 配置项改变了值，那么除了描述该字段的 Schema 结构中状态字段 <code>_status</code> 会显示为冲突（Conflict）外，在递归返回的过程中，亦会将层级更高的对象或数组状态标记为冲突（Conflict）。</p>\n<blockquote>\n<p>需要特别说明的是，如果下层结构仅有一种变化状态时，上层结构会显示该变化状态，而下层结构存在不只一种变化状态时，则上层会统一表示为冲突状态。</p>\n</blockquote>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-status-display-tatics.jpg\" alt=\"状态自底向上传递显示策略\"></p>\n<p>这样处理的目的，是为了树结构在可视化视图组装渲染后能够更清晰地让配置人员知道各节点的状态。树状的图形能够让开发人员快速知道哪些组件配置项发生了变更，并能沿着路径找到变化的根源。</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-path-to-root.jpg\" alt=\"可视化冲突解决界面\"></p>\n<h2 id=\"Diff-功能实现\"><a href=\"#Diff-功能实现\" class=\"headerlink\" title=\"Diff 功能实现\"></a>Diff 功能实现</h2><p>约定好对比后的数据结构后，那么就要通过方法封装对变化前后的页面配置数据进行比较。</p>\n<p>在实现 diff 方法前，就设想实现的方法应该能保证在不同的配置数据结构下也能使用。也就是说，实现过程需要脱离业务相关的代码，尽可能保证方法通用性。</p>\n<p>而在实现过程中，我们遇到的其中一个问题就是当对比双方的数组类型且其数组成员为对象类型时，我们需要为此类情况提供用于匹配的方法。</p>\n<p>我们以 TotoroX 的配置为例来解释为什么需要为数组结构的比较提供匹配方法。例如 TotoroX 的配置数据中 <code>eventList</code> 字段表示组件相关的事件列表，每个事件（对象）之间的 <code>name</code> 字段是唯一的，因此我们在对比 <code>eventList</code> 数组时，需要明确对象数组中各成员的 <code>name</code> 键值为严格相等，才能对双方进行后续的 diff。而实际上，并非所有对象数组都通过 <code>name</code> 字段进行匹配，将类似的代码参杂到通用类型方法中显然是不恰当的。因此，我们需要提高类库的可拓展性，将用于对象数组匹配的方法抽离，并通过配置的形式植入。</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-button-data.jpeg\" alt=\"Button组件配置\"></p>\n<h3 id=\"数组辅助方法\"><a href=\"#数组辅助方法\" class=\"headerlink\" title=\"数组辅助方法\"></a>数组辅助方法</h3><p>对象数组间的匹配筛选在实现中应用的场景是较多的，因此我们封装了一系列的辅助方法减少重复的代码，包括：</p>\n<p><strong>数组差集函数</strong></p>\n<p>通过数组成员间逐一对比，筛选出两数组中所有成员的差集集合并返回（仅限于数组成员为基本类型值）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDifference</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [...new <span class=\"built_in\">Set</span>(a.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(b).has(x)))];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>功能同上，当对象数组成员为对象类型时使用，需要提供用于匹配的比较器函数，返回结果只保留以参数 <code>a</code> 传入的数组的成员项</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDifferenceWith</span>(<span class=\"params\">a, b, comparator = (x, y</span>) =&gt; <span class=\"title\">x</span> === <span class=\"title\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.findIndex(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> comparator(x, y)) === <span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>数组交集函数</strong></p>\n<p>通过数组成员间逐一对比，筛选出两数组中所有成员的交集集合并返回（仅限于数组成员为基本类型值）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getIntersection</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [...new <span class=\"built_in\">Set</span>(a.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(b).has(x)))];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>功能同上，当对象数组成员为对象类型时使用，需要提供用于匹配的比较器函数，返回结果只保留以参数 <code>a</code> 传入的数组的的成员项</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getIntersectionWith</span>(<span class=\"params\">a, b, comparator = (x, y</span>) =&gt; <span class=\"title\">x</span> === <span class=\"title\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.findIndex(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> comparator(x, y)) !== <span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>数组并集函数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUnionWith</span>(<span class=\"params\">a, b, comparator = (x, y</span>) =&gt; <span class=\"title\">x</span> === <span class=\"title\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a, ...b.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> a.findIndex(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> comparator(x, y)) === <span class=\"number\">-1</span>)]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>数组去重函数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDedupeBy</span>(<span class=\"params\">arr, comparator = (x, y</span>) =&gt; <span class=\"title\">x</span> === <span class=\"title\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">acc, v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!acc.some(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> comparator(v, x))) &#123;</span><br><span class=\"line\">      acc.push(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以留意到，上述辅助函数除了用于匹配的两个数组类型的参数外，还需要提供一个 <code>comparator</code> 的参数。<code>comparator</code> 意为比较器，类型为函数类型，用于封装方法内部 <code>filter</code> 函数对应的回调函数，从而筛选出用以匹配数组的对象成员。如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> comparator = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x.id === y.id;</span><br></pre></td></tr></table></figure>\n<p>表示为 <code>x</code> 对象的 <code>id</code> 字段与 <code>y</code> 对象的 <code>id</code> 字段完全相等时，表示 <code>x</code> 对象和 <code>y</code> 对象为匹配的双方。</p>\n<p>通过这样的形式，我们能够将配置中数组形式存在的配置项的匹配字段以 <code>comparator</code> 的形式配置植入，而不必在实现的代码中植入业务相关的代码。当然，仅仅如此并不够的，因为还无法解决到底配置结构中到底哪个层级是数组类型的值，下面会详细解析如何解决这个问题。</p>\n<h3 id=\"差异化流程实现\"><a href=\"#差异化流程实现\" class=\"headerlink\" title=\"差异化流程实现\"></a>差异化流程实现</h3><p>根据 JSON 的不同类型的处理方式的不同，我们实现了三个方法：</p>\n<ul>\n<li><code>diffObject</code>：用于对象类型值之间的对比方法，通过 <code>Object.keys</code> 获取各自对象的键名集合，配合数组差集函数和数组交集函数，可以筛选出新对象中新增的字段集合、旧对象中删除的字段集合以及新对象和旧对象共有的字段集合</li>\n<li><code>diffArray</code>：用于数组类型值之间的对比方法，通过 <code>comparator</code> 比较函数入参，同样利用差集函数和交集函数，分别筛选出新数组中新增的数组成员、旧数组中删除的数组成员以及各自数组中共有的数组成员</li>\n<li><code>diffValue</code>：用于基本数据类型值的对比方法，采用严格相等的对比方式，若相等则为相等（Equal）状态，否则为冲突状态（Conflict）</li>\n</ul>\n<p>引用类型的值比较（也就是 <code>diffObject</code> 和 <code>diffArray</code>）在匹配到键值或数组成员时，会利用调和函数作为匹配跳板，根据传入数据源类型不同继续对下层结构的值递归执行上述三种不同数据类型的方法。</p>\n<p>而旧对象/旧数组中删除的值或新对象/新数组中新增的值，则不会再进行深层次的递归，会直接投放到另一个处理方法 <code>getRecursion</code> 中递归修改下层结构中的变化状态。</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-workflow.jpg\" alt=\"diff结构流程图\"></p>\n<p>对象类型值之间的比较，我们会使用 <code>Object.keys()</code> 方法分别获取两个对比对象的键名，并通过数组辅助方法拆分为三组：共同拥有的键名的集合、仅有 <code>origin</code> 对象（理解为变化前的配置对象）拥有的键名的集合和 <code>target</code> 对象（理解为变化后的配置对象）拥有的键名集合。</p>\n<p>由此可得，共同拥有的键名集合需要通过比较得出变化状态。而 <code>origin</code> 对象拥有的键名，则表示 <code>target</code> 对象没有，也就是 <code>origin</code> 对象集合中的键值被删除了，会被标记为删除状态。相似地，仅 <code>target</code> 对象拥有的键名表示 <code>origin</code> 没有该键名，则 <code>target</code> 的键值为新增配置项，会被标记为新增状态。</p>\n<p>刚才提到对象数组类型之间需要通过比较器函数 <code>comparator</code> 用于匹配，但是需要提供一种让运行机制知道什么样的数组对比需要用怎样的 <code>comparator</code>。在运行 diff 前，我们通过以递归路径为键名，以 <code>comparator</code> 为键值组成的配置对象传入 <code>diff</code> 函数。</p>\n<p>在向下递归进行配置项比较时，遇到对象类型的值，会将键名传入调和函数。在函数内部，会被推入一个已声明的面包屑栈（也称为递归路径，以数组形式表示），当返回值时，又会退栈。当检查到下层结构为数组类型时，会通过 <code>Array.prototype.join()</code> 方法将面包屑栈中的值合成键名路径，匹配外部传入的比较器配置后，将下层数组结构匹配所需的 <code>comparator</code> 传入 <code>diffArray</code> 中。这样就解决了对象数组匹配的问题，同时也将相关的业务代码抽离至外部，提升了方法的通用性和可配置性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> comparator = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果原始数据为数组类型（也就是传入数据最外层为数组类型），必须有 init 字段作为 comparator 函数</span></span><br><span class=\"line\">  init: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.name === b.name &amp;&amp; a.id === b.id,</span><br><span class=\"line\">  eventList: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.name === b.name,</span><br><span class=\"line\">  <span class=\"string\">'eventList.value'</span>: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a === b,</span><br><span class=\"line\">  <span class=\"string\">'eventList.subEvents'</span>: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.id === b.id,</span><br><span class=\"line\">  <span class=\"string\">'eventList.subEvents.actions'</span>: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.id === b.id,</span><br><span class=\"line\">  animation: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.antType === b.antType,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>⚠️<strong>注意</strong>：如果原始数据为数组类型，则必须提供 <code>init</code> 作为根（顶层）结构的比较器函数。</p>\n<p>上述就是 diff 功能实现过程中遇到的主要问题的解决方案，但是仅对两路的配置数据进行 diff 是不够的，这主要是从我们本身 TotoroX 的业务考虑。如前文所述 <code>origin</code> 可以为用于创建页面的模版，<code>target</code> 为基于模版创建的页面，但后续需求变更时会对模版数据进行修改，而在我们的系统中并不会同步到创建的页面，那么模版修改后需要将修改的内容同步到之前创建的页面，就需要提供一个用于合并新模版与旧页面的方法，下面我们就聊聊 merge 功能的实现。</p>\n<h2 id=\"Merge-功能实现\"><a href=\"#Merge-功能实现\" class=\"headerlink\" title=\"Merge 功能实现\"></a>Merge 功能实现</h2><p>在对 merge 功能实现过程进行讲解前，我们需要对 git 的合并策略进行一定程度的了解。</p>\n<p>git 采用三路合并策略：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B - C - D master(*)</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  E - F dev</span><br></pre></td></tr></table></figure>\n<p>以我们日常的开发协作流程为例，当前分支也就是主分支为 <code>master</code>，当尝试把 <code>dev</code> 开发分支合并到 <code>master</code> 时，两个分支共同拥有的提交就是 commitB，我们将该提交 commit 称为 <code>base</code>，<code>master</code> 分支最新的提交 commitD 称为 <code>ours</code>，而 <code>dev</code> 分支最新的提交 commitF 称为 <code>theirs</code>。</p>\n<p>那么 git 是怎样合并 <code>ours</code> 和 <code>theirs</code> 的呢？</p>\n<p>在合并时，会参考他们的共同祖先 <code>base</code>，并根据下面策略进行合并。</p>\n<table>\n<thead>\n<tr>\n<th>祖先（base）</th>\n<th>HEAD（ours）</th>\n<th>分支（theirs）</th>\n<th>结果</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n<td></td>\n</tr>\n<tr>\n<td>A</td>\n<td>A</td>\n<td>B</td>\n<td>B</td>\n<td>如果一方修改了一行，那么这一行选择修改版的</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B</td>\n<td>A</td>\n<td>B</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>如果某一行双方拥有相同的变更，则选择修改过的行</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B</td>\n<td>C</td>\n<td>conflict</td>\n<td>如果某一行双方都修改了，且修改得不一样，则报告冲突，需要用户解决</td>\n</tr>\n</tbody>\n</table>\n<p>根据上表规则，合并过程类似这样：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-merge-strategy.png\" alt=\"合并过程\"></p>\n<p>可以看到，第四行，双方都修改了，且各自修改的内容不一样，所以 git 不知道怎么解决，所以就把问题抛给用户了。</p>\n<h3 id=\"根节点层级筛选合并\"><a href=\"#根节点层级筛选合并\" class=\"headerlink\" title=\"根节点层级筛选合并\"></a>根节点层级筛选合并</h3><p>我们在实现 merge 功能时，正是采用了与此种合并策略一致的方式。在 merge 的合并流程中，原始数据即为<strong>祖先</strong>（base），而实际需要合并的两份数据分别为 <strong>Head</strong>（ours）和<strong>分支</strong>（theirs）。我们将 <code>base</code> 作为中间者，以此判断两份配置数据哪些部分是属于原始数据的，哪些部分又是新数据。</p>\n<p>首先，我们分别将新数据与共同组件 <code>base</code> 进行 diff 操作，获得分别的 JSON Schema 结构的结果，后续再对结果进行 mergeBranch 的操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">base, ours, theirs, diffComparator, mergeComparator</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> originDiff = diff(base, ours, diffComparator);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> targetDiff = diff(base, theris, diffComparator);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newDataSchema = mergeBranch(originDiff, targetDiff, mergeComparator);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> newDataSchema;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而由于 merge 是根据两两 diff 后的 Schema 结构的 JSON，我们先从<strong>根节点</strong>的 <code>_status</code> 字段匹配进行区分，共有五种情况：</p>\n<table>\n<thead>\n<tr>\n<th>源配置数据根节点状态</th>\n<th>变更配置数据根节点状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Equal</td>\n<td>Equal</td>\n<td>表示 <code>base</code> 和 <code>ours</code> 完全相等，<code>base</code> 和 <code>theirs</code> 完全相等，即表示三路完全相等</td>\n</tr>\n<tr>\n<td>Equal</td>\n<td>Updated</td>\n<td>表示 <code>base</code> 和 <code>ours</code> 完全相等，<code>base</code> 和 <code>theirs</code> 存在变更，即单路变更，最终给你会采用变更路数据</td>\n</tr>\n<tr>\n<td>Updated</td>\n<td>Equal</td>\n<td>表示 <code>base</code> 和 <code>ours</code> 存在变更，<code>base</code> 和 <code>theirs</code> 完全相等，即单路变更，最终给你会采用变更路数据</td>\n</tr>\n<tr>\n<td>Updated</td>\n<td>Updated</td>\n<td>表示 <code>base</code> 和 <code>ours</code> 存在变更，<code>base</code> 和 <code>theirs</code> 也存在变更，但是变更对应的值不相等，即三路冲突</td>\n</tr>\n<tr>\n<td>Updated</td>\n<td>Updated</td>\n<td>表示 <code>base</code> 和 <code>ours</code> 存在变更，<code>base</code> 和 <code>theirs</code> 也存在变更，但是变更对应的值相等，实际上 <code>ours</code> 和 <code>theirs</code> 变更值与 <code>base</code> 值冲突</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-merge-venn-diagram.jpg\" alt=\"变更状态韦恩图\"></p>\n<p>对上述五种情况进行分析归纳后，在代码实现层面上可以大致分为三个方向处理：</p>\n<ol>\n<li>三路相等（A-A-A）=&gt; <code>mergeUnmodified</code>（相当于上文韦恩图天蓝色部分中状态为 <code>equal</code> 的部分）</li>\n<li>单路变更，采用变更路数据（A-A-B、A-B-A）=&gt; <code>mergeUpdated</code>（相当于上文韦恩图紫色和橙色部分，表示的是 <code>base</code> 存在但是存在变更的状态，可以是完全或局部的删除和冲突，也可以是局部配置项的新增，但是不可能是完全的新增）</li>\n<li>两路变更，根据变更情况选择或保留冲突状态并提供手动处理方式，变更又分为新增、删除和修改（A-B-B、A-B-C）=&gt; <code>mergeConflict</code>（相当于上文韦恩图绿色、红色和蓝灰色）</li>\n</ol>\n<p>三路相等的情况是最好处理的，在对根节点进行遍历时匹配两者的 <code>_status</code> 变化状态为相等状态（<code>equal</code>）时即表明三路相等。</p>\n<p>单路变更的情况，在对根节点进行遍历时匹配两者的 <code>_status</code> 为相等（<code>equal</code>）而另一方为不相等，即为需要采用变更路数据。</p>\n<p>而对于两路变更的情况，我们不能单纯地以根节点的状态作为区分，这是因为我们采用了上文提及过的<strong>自底向上的状态变更显示策略</strong>，所以根节点呈现为变更状态，不代表整个结构内部的属性均为变更状态，也可能因为某个配置项的变更，导致结构树上层的状态改变。所以对于这种情况，我们又能细分为两种情况进行处理：</p>\n<ol>\n<li>通过 <code>comparator</code> 比较函数能两两匹配的节点树，实际上为 <code>base</code>、<code>ours</code> 和 <code>theirs</code> 三路均存在该根节点的，则需要对双方子孙层级的节点进行递归遍历并逐一对比（相当于上文韦恩图中蓝色 <code>conflict</code> 的部分）</li>\n<li>在对比双方的配置数据中，根节点状态 <code>_status</code> 为新增状态（<code>add</code>）且子孙层级的配置属性值也为新增状态时，则可判断该配置树为完全新增（相当于上文韦恩图中绿色 <code>add</code> 的部分），按照约定的合并策略，需要保留整个配置树</li>\n</ol>\n<h3 id=\"子孙层级筛选合并\"><a href=\"#子孙层级筛选合并\" class=\"headerlink\" title=\"子孙层级筛选合并\"></a>子孙层级筛选合并</h3><p>下面我们把重点聚焦于两路变更的情况下子孙层级筛选合并的实现。</p>\n<p>从根节点的变更状态的角度分析（已排除完全新增的配置节点树），可以大致分为五种情况：</p>\n<table>\n<thead>\n<tr>\n<th>base_ours 根节点状态</th>\n<th>base_theirs 根节点状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Add</td>\n<td>Add</td>\n<td>表示 <code>base</code> 没有某项配置项，而 <code>ours</code> 和 <code>theris</code> 新增了某项配置项</td>\n</tr>\n<tr>\n<td>Conflict</td>\n<td>Conflict</td>\n<td>表示 <code>base</code> 存在某项配置项，<code>ours</code> 也存在该项配置项但是值与 <code>base</code> 不同，<code>theris</code> 也存在该项配置项但是值与 <code>base</code> 也不同（未必与 <code>ours</code> 相同/不同）</td>\n</tr>\n<tr>\n<td>Conflict</td>\n<td>Delete</td>\n<td>表示 <code>base</code> 存在某项配置项，<code>ours</code> 也存在该项配置项但是值与 <code>base</code> 不同，而 <code>theris</code> 则不存在该项配置项</td>\n</tr>\n<tr>\n<td>Delete</td>\n<td>Conflict</td>\n<td>表示 <code>base</code> 存在某项配置项，<code>ours</code> 不存在该项配置项，而 <code>theris</code> 存在该项配置项且值与 <code>base</code> 不同</td>\n</tr>\n<tr>\n<td>Delete</td>\n<td>Delete</td>\n<td>表示 base 存在某项配置项，<code>ours</code> 和 <code>theris</code> 均不存在该配置项</td>\n</tr>\n</tbody>\n</table>\n<p>我们以一个简单的代码示例说明：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-merge-code-demo.jpg\" alt=\"三路合并配置代码示例\"></p>\n<p>结合上文提及五种两两比对存在变更状态时的情况，并结合代码示例得出以下结论：</p>\n<ul>\n<li><code>color</code> 对应第一种情况，<code>base</code> 没有该配置项，而 <code>ours</code> 和 <code>theirs</code> 则有</li>\n<li><code>width</code> 对应第二种情况，<code>base</code> 有该配置项，而 <code>ours</code> 和 <code>theirs</code> 同样有该配置项，但是 <code>ours</code> 和 <code>theirs</code> 的值存在差异</li>\n<li><code>height</code> 同样对应第二种情况，与 <code>width</code> 配置项不同的是，<code>ours</code> 和 <code>theirs</code> 的值严格相等</li>\n<li><code>translateX</code> 对应第三种情况，<code>base</code> 与 <code>ours</code> 有该配置，且值冲突，而 <code>theirs</code> 则删除了该配置项</li>\n<li><code>translateX</code> 对应第四种情况，<code>base</code> 与 <code>theirs</code> 有该配置，且值冲突，而 <code>ours</code> 则删除了该配置项</li>\n<li><code>line-height</code> 对应第五种情况，仅 <code>base</code> 存在该配置项，<code>ours</code> 和 <code>theirs</code> 均删除了该配置项</li>\n</ul>\n<blockquote>\n<p>这里提及的新增或删除字段只为覆盖更完整的功能，实际的可视化配置业务中，因为组件的配置项基本固定且均提供了默认值，所以出现新增或删除字段的情况较少。</p>\n</blockquote>\n<p>最后基于 <code>base</code> 进行 diff 后得出如下两份 JSON Schema 结构差异化数据：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-between-base-and-ours.jpg\" alt=\"diff-between-base-and-ours\"></p>\n<p><img src=\"http://img.mrsingsing.com/diff-between-base-and-theirs.jpg\" alt=\"diff-between-base-and-theirs\"></p>\n<p>基于三路合并的策略，当三路值均不同时会保留差异让用户手动解决，当变更两路值相同或新增时则保留相同值，最后合并后得出新的 JSON Schema 配置数据：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-merge-base-ours-and-theirs.jpeg\" alt=\"Merge base and ours and theirs\"></p>\n<h2 id=\"Revert-功能实现\"><a href=\"#Revert-功能实现\" class=\"headerlink\" title=\"Revert 功能实现\"></a>Revert 功能实现</h2><p>最终通过自动合并和手动解决冲突，完整的配置数据应该所有节点都表示为相等状态。通过对返还的 JSON Schema 结构的数据递归还原，自动新建页面即完成整个批量更新页面的功能。</p>\n<hr>\n<p><strong>参考资料</strong>：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/longintchar/article/details/83049840\" target=\"_blank\" rel=\"noopener\">三路合并 Git 学习笔记 17</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>首发于：<a href=\"https://juejin.im/post/5dc8fd92f265da4d287f4551\" target=\"_blank\" rel=\"noopener\">可视化配置系统页面批量更新工具的开发实践</a></p>\n</blockquote>\n<p>TotoroX 作为 PPmoney 集团内部集 UI 和业务逻辑于一体的前端页面可视化配置系统，为运营部门提供快速构建前端页面的解决方案。该系统为页面开发及运营人员提供了强大的组件市场，通过拖拽、表单配置等方式实现专题页面的业务需求。目前已支撑集团 850+营销活动页面。</p>\n<h2 id=\"业务痛点\"><a href=\"#业务痛点\" class=\"headerlink\" title=\"业务痛点\"></a>业务痛点</h2><p>在产品设计阶段，产品经理会根据对用户的调研，借助用户画像理解用户的需求，想想用户使用的场景，以及他们可能会遇到的困难。随着产品上线后，运营团队通过转化漏斗分析用户交互行为以及最终的转化的实际效果。所以这个阶段，随着真实用户群体的积累，在设计阶段虚构的用户画像需要重新调研、设想。</p>\n<p>而在技术的角度，我们也希望通过用户行为数据，为产品运营提供更好的支撑，例如为不同的用户提供不同 UI 的前端页面，通过对比的方法观察数据变化，以此作为对用户行为的准确判断。</p>\n<p>以下面的营销活动页为例，我们会在既有的页面配置中生成新的页面，并根据设计要求进行局部的调整，除了 UI 部分，内部逻辑包括埋点数据、事件链条关系等也会进行相关的修正。在此需求背景之下，如果需要人工手动对每个配置页面进行修改，这将会耗费大量的人力资源。而且，上文提到会涉及逻辑的修改，配置人员不易发现变更的地方，无法对修改后的页面进行校验。综上所述，我们需要一款对比前后变化的工具，能够可视化地对不同的配置数据进行对比，并通过图形绘制的形式清晰知道配置数据树中哪些节点没有修改，哪些节点修改了，修改前后的值又是什么，就好像我们进行代码协助时通过 <code>git diff</code> 能够知道文件中哪行代码发生了冲突，通过人工判断对冲突进行修改合并，并最终达到我们需要的效果。</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-abtest.jpg\" alt=\"AB Test\"></p>\n<p>TotoroX 基于用户配置的数据组装生成页面，配置数据均由组件市场的物料支撑，单个组件的配置数据结构基本相同，包括但不限于：唯一标识、组件名称、组件属性、组件样式、组件事件链以及动画相关配置等。组件间在配置数据的集合中是扁平化的，通过各组件配置数据中的标识集合相互关联起来，这样的数据结构设计避免了因为嵌套层级过深而产生的问题。基于这些条件，为多路差异化对比以及合并提供了可能。</p>","more":"<h2 id=\"差异化配置数据结构的设计\"><a href=\"#差异化配置数据结构的设计\" class=\"headerlink\" title=\"差异化配置数据结构的设计\"></a>差异化配置数据结构的设计</h2><p>在进行配置数据的对比合并前，需要设计出能够准确描述数据变化前后的数据结构。</p>\n<p>在 TotoroX 中，配置数据的结构模式与 JSON 的结构模式一致，因此数据结构的设计应以 JSON 的数据结构为基础。</p>\n<p>而在 JSON 中值存在以下几种数据类型：</p>\n<ul>\n<li>null</li>\n<li>字符串</li>\n<li>布尔值</li>\n<li>数值</li>\n<li>数组</li>\n<li>对象</li>\n</ul>\n<p>因此，我们不用考虑诸如 Date、Function、Symbol、Set 等数据类型的值。</p>\n<p>同时，在设定的配置数据中不能存在空值 <code>null</code>，如果要表示不对某配置项作配置，实际上会采用默认的配置属性，所以在实际配置数据中，是不会存在空值存在，可以忽略这种情况。</p>\n<p>综合上述，从大致上能分为两大类数据类型：</p>\n<ul>\n<li>基本数据类型：字符串、布尔值、数值</li>\n<li>引用数据类型：数组、对象</li>\n</ul>\n<p>那么我们是怎样去描述 JSON 对比前后变更状态呢？</p>\n<p>JSON 是目前应用广泛的数据交换格式，那么交换双方肯定需要对数据进行约定和校验，而 JSON Schema 就是扮演定义 JSON 数据约束的标准。因此，我们尝试引入 JSON Schema 的概念，并结合实际功用进行改造。</p>\n<p>传统的 JSON Schema 表现为这样：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"$schema\"</span>: <span class=\"string\">\"http://json-schema.org/draft-07/schema#\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"$id\"</span>: <span class=\"string\">\"http://example.com/product.schema.json\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Product\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"A product from Acme's catalog\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"object\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"properties\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"productId\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"The unique identifier for a product\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"integer\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"productName\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"Name of the product\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"string\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"price\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"The price of the product\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"number\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"exclusiveMinimum\"</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"tags\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"Tags for the product\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"array\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"items\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"string\"</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"minItems\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"uniqueItems\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"dimensions\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"object\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"properties\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"length\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"number\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"width\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"number\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"height\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"number\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"required\"</span>: [<span class=\"string\">\"length\"</span>, <span class=\"string\">\"width\"</span>, <span class=\"string\">\"height\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"required\"</span>: [<span class=\"string\">\"productId\"</span>, <span class=\"string\">\"productName\"</span>, <span class=\"string\">\"price\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从形式上来讲，JSON Schema 还是 JSON 的格式，但不同的是，JSON Schema 会在原来的 JSON 基础上在每个层级的数据外包装了一层用以描述对应层级值的相关信息，包括对应层级的值、描述、数据类型以及其它额外配置的信息。</p>\n<p>在结构上，我们沿用了 JSON Schema 的一套标准，在源数据基础上通过遍历递归的方法对数据进行描述。而在描述的信息上，我们针对实际的应用场景进行了定制。</p>\n<p>描述信息中必不可少的就是对数据变化信息的描述，我们参考了 Git 管理代码变更的策略，在两两对比下，我们梳理出可能产生的四种值比较情况：</p>\n<ul>\n<li><strong>相等（Equal）</strong>：当两个基本数据类型的值严格相等时，则为相等状态；而对于引用数据类型，需要提供额外的手段进行匹配</li>\n<li><strong>新增（Add）</strong>：当对象间对比时，目标对象存在新增的键时，描述该键值为新增状态；同理，当数组中无对应的匹配项时，则为新增状态</li>\n<li><strong>删除（Delete）</strong>：与新增状态类似，当对象间对比时，目标对象存在删除的键时，描述该键值为删除状态，而数组中对应的匹配项不存在时，则为删除状态</li>\n<li><strong>冲突（Conflict）</strong>：当两个基本数据类型的值不严格相等时，则为冲突状态</li>\n</ul>\n<p>举个例子，如下为两个个仅有一个按钮组件的配置页数据集合：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-data-structure-comparation-.jpg\" alt=\"修改前后的配置数据\"></p>\n<p>通过 diff 后预设能产生的数据结构：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-result-data-structure.jpg\" alt=\"对比后产生的数据结构\"></p>\n<p>我们对描述变化的数据结构进行了约定：</p>\n<ul>\n<li>对象类型和数组类型的值使用 <code>_properties</code> 字段描述，对应值被源数据对应的数据类型包裹</li>\n<li>基本数据类型的值根据具体值的状态 <code>_status</code> 决定展示的字段<ul>\n<li>相等（Equal）：使用 <code>_origin</code> 表示值</li>\n<li>新增（Add）：使用 <code>_target</code> 表示新增的值</li>\n<li>删除（Delete）：使用 <code>_origin</code> 表示删除的值</li>\n<li>冲突（Conflict）：使用 <code>_orign</code> 表示更改前的值，<code>_target</code> 表示更改后的值</li>\n</ul>\n</li>\n</ul>\n<p>你也许会发现即便是对象类型和数组类型，也会有 <code>_status</code> 字段描述更改状态。这是因为我们在交互界面上采取了<strong>自底向上</strong>的状态变更显示策略。例如，当一个组件配置数据大部分保持不变的情况下，样式配置字段 <code>style</code> 中的 <code>height</code> 配置项改变了值，那么除了描述该字段的 Schema 结构中状态字段 <code>_status</code> 会显示为冲突（Conflict）外，在递归返回的过程中，亦会将层级更高的对象或数组状态标记为冲突（Conflict）。</p>\n<blockquote>\n<p>需要特别说明的是，如果下层结构仅有一种变化状态时，上层结构会显示该变化状态，而下层结构存在不只一种变化状态时，则上层会统一表示为冲突状态。</p>\n</blockquote>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-status-display-tatics.jpg\" alt=\"状态自底向上传递显示策略\"></p>\n<p>这样处理的目的，是为了树结构在可视化视图组装渲染后能够更清晰地让配置人员知道各节点的状态。树状的图形能够让开发人员快速知道哪些组件配置项发生了变更，并能沿着路径找到变化的根源。</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-path-to-root.jpg\" alt=\"可视化冲突解决界面\"></p>\n<h2 id=\"Diff-功能实现\"><a href=\"#Diff-功能实现\" class=\"headerlink\" title=\"Diff 功能实现\"></a>Diff 功能实现</h2><p>约定好对比后的数据结构后，那么就要通过方法封装对变化前后的页面配置数据进行比较。</p>\n<p>在实现 diff 方法前，就设想实现的方法应该能保证在不同的配置数据结构下也能使用。也就是说，实现过程需要脱离业务相关的代码，尽可能保证方法通用性。</p>\n<p>而在实现过程中，我们遇到的其中一个问题就是当对比双方的数组类型且其数组成员为对象类型时，我们需要为此类情况提供用于匹配的方法。</p>\n<p>我们以 TotoroX 的配置为例来解释为什么需要为数组结构的比较提供匹配方法。例如 TotoroX 的配置数据中 <code>eventList</code> 字段表示组件相关的事件列表，每个事件（对象）之间的 <code>name</code> 字段是唯一的，因此我们在对比 <code>eventList</code> 数组时，需要明确对象数组中各成员的 <code>name</code> 键值为严格相等，才能对双方进行后续的 diff。而实际上，并非所有对象数组都通过 <code>name</code> 字段进行匹配，将类似的代码参杂到通用类型方法中显然是不恰当的。因此，我们需要提高类库的可拓展性，将用于对象数组匹配的方法抽离，并通过配置的形式植入。</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-button-data.jpeg\" alt=\"Button组件配置\"></p>\n<h3 id=\"数组辅助方法\"><a href=\"#数组辅助方法\" class=\"headerlink\" title=\"数组辅助方法\"></a>数组辅助方法</h3><p>对象数组间的匹配筛选在实现中应用的场景是较多的，因此我们封装了一系列的辅助方法减少重复的代码，包括：</p>\n<p><strong>数组差集函数</strong></p>\n<p>通过数组成员间逐一对比，筛选出两数组中所有成员的差集集合并返回（仅限于数组成员为基本类型值）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDifference</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [...new <span class=\"built_in\">Set</span>(a.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(b).has(x)))];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>功能同上，当对象数组成员为对象类型时使用，需要提供用于匹配的比较器函数，返回结果只保留以参数 <code>a</code> 传入的数组的成员项</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDifferenceWith</span>(<span class=\"params\">a, b, comparator = (x, y</span>) =&gt; <span class=\"title\">x</span> === <span class=\"title\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.findIndex(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> comparator(x, y)) === <span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>数组交集函数</strong></p>\n<p>通过数组成员间逐一对比，筛选出两数组中所有成员的交集集合并返回（仅限于数组成员为基本类型值）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getIntersection</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [...new <span class=\"built_in\">Set</span>(a.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(b).has(x)))];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>功能同上，当对象数组成员为对象类型时使用，需要提供用于匹配的比较器函数，返回结果只保留以参数 <code>a</code> 传入的数组的的成员项</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getIntersectionWith</span>(<span class=\"params\">a, b, comparator = (x, y</span>) =&gt; <span class=\"title\">x</span> === <span class=\"title\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.findIndex(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> comparator(x, y)) !== <span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>数组并集函数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUnionWith</span>(<span class=\"params\">a, b, comparator = (x, y</span>) =&gt; <span class=\"title\">x</span> === <span class=\"title\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a, ...b.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> a.findIndex(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> comparator(x, y)) === <span class=\"number\">-1</span>)]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>数组去重函数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDedupeBy</span>(<span class=\"params\">arr, comparator = (x, y</span>) =&gt; <span class=\"title\">x</span> === <span class=\"title\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">acc, v</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!acc.some(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> comparator(v, x))) &#123;</span><br><span class=\"line\">      acc.push(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以留意到，上述辅助函数除了用于匹配的两个数组类型的参数外，还需要提供一个 <code>comparator</code> 的参数。<code>comparator</code> 意为比较器，类型为函数类型，用于封装方法内部 <code>filter</code> 函数对应的回调函数，从而筛选出用以匹配数组的对象成员。如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> comparator = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x.id === y.id;</span><br></pre></td></tr></table></figure>\n<p>表示为 <code>x</code> 对象的 <code>id</code> 字段与 <code>y</code> 对象的 <code>id</code> 字段完全相等时，表示 <code>x</code> 对象和 <code>y</code> 对象为匹配的双方。</p>\n<p>通过这样的形式，我们能够将配置中数组形式存在的配置项的匹配字段以 <code>comparator</code> 的形式配置植入，而不必在实现的代码中植入业务相关的代码。当然，仅仅如此并不够的，因为还无法解决到底配置结构中到底哪个层级是数组类型的值，下面会详细解析如何解决这个问题。</p>\n<h3 id=\"差异化流程实现\"><a href=\"#差异化流程实现\" class=\"headerlink\" title=\"差异化流程实现\"></a>差异化流程实现</h3><p>根据 JSON 的不同类型的处理方式的不同，我们实现了三个方法：</p>\n<ul>\n<li><code>diffObject</code>：用于对象类型值之间的对比方法，通过 <code>Object.keys</code> 获取各自对象的键名集合，配合数组差集函数和数组交集函数，可以筛选出新对象中新增的字段集合、旧对象中删除的字段集合以及新对象和旧对象共有的字段集合</li>\n<li><code>diffArray</code>：用于数组类型值之间的对比方法，通过 <code>comparator</code> 比较函数入参，同样利用差集函数和交集函数，分别筛选出新数组中新增的数组成员、旧数组中删除的数组成员以及各自数组中共有的数组成员</li>\n<li><code>diffValue</code>：用于基本数据类型值的对比方法，采用严格相等的对比方式，若相等则为相等（Equal）状态，否则为冲突状态（Conflict）</li>\n</ul>\n<p>引用类型的值比较（也就是 <code>diffObject</code> 和 <code>diffArray</code>）在匹配到键值或数组成员时，会利用调和函数作为匹配跳板，根据传入数据源类型不同继续对下层结构的值递归执行上述三种不同数据类型的方法。</p>\n<p>而旧对象/旧数组中删除的值或新对象/新数组中新增的值，则不会再进行深层次的递归，会直接投放到另一个处理方法 <code>getRecursion</code> 中递归修改下层结构中的变化状态。</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-workflow.jpg\" alt=\"diff结构流程图\"></p>\n<p>对象类型值之间的比较，我们会使用 <code>Object.keys()</code> 方法分别获取两个对比对象的键名，并通过数组辅助方法拆分为三组：共同拥有的键名的集合、仅有 <code>origin</code> 对象（理解为变化前的配置对象）拥有的键名的集合和 <code>target</code> 对象（理解为变化后的配置对象）拥有的键名集合。</p>\n<p>由此可得，共同拥有的键名集合需要通过比较得出变化状态。而 <code>origin</code> 对象拥有的键名，则表示 <code>target</code> 对象没有，也就是 <code>origin</code> 对象集合中的键值被删除了，会被标记为删除状态。相似地，仅 <code>target</code> 对象拥有的键名表示 <code>origin</code> 没有该键名，则 <code>target</code> 的键值为新增配置项，会被标记为新增状态。</p>\n<p>刚才提到对象数组类型之间需要通过比较器函数 <code>comparator</code> 用于匹配，但是需要提供一种让运行机制知道什么样的数组对比需要用怎样的 <code>comparator</code>。在运行 diff 前，我们通过以递归路径为键名，以 <code>comparator</code> 为键值组成的配置对象传入 <code>diff</code> 函数。</p>\n<p>在向下递归进行配置项比较时，遇到对象类型的值，会将键名传入调和函数。在函数内部，会被推入一个已声明的面包屑栈（也称为递归路径，以数组形式表示），当返回值时，又会退栈。当检查到下层结构为数组类型时，会通过 <code>Array.prototype.join()</code> 方法将面包屑栈中的值合成键名路径，匹配外部传入的比较器配置后，将下层数组结构匹配所需的 <code>comparator</code> 传入 <code>diffArray</code> 中。这样就解决了对象数组匹配的问题，同时也将相关的业务代码抽离至外部，提升了方法的通用性和可配置性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> comparator = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果原始数据为数组类型（也就是传入数据最外层为数组类型），必须有 init 字段作为 comparator 函数</span></span><br><span class=\"line\">  init: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.name === b.name &amp;&amp; a.id === b.id,</span><br><span class=\"line\">  eventList: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.name === b.name,</span><br><span class=\"line\">  <span class=\"string\">'eventList.value'</span>: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a === b,</span><br><span class=\"line\">  <span class=\"string\">'eventList.subEvents'</span>: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.id === b.id,</span><br><span class=\"line\">  <span class=\"string\">'eventList.subEvents.actions'</span>: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.id === b.id,</span><br><span class=\"line\">  animation: <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.antType === b.antType,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>⚠️<strong>注意</strong>：如果原始数据为数组类型，则必须提供 <code>init</code> 作为根（顶层）结构的比较器函数。</p>\n<p>上述就是 diff 功能实现过程中遇到的主要问题的解决方案，但是仅对两路的配置数据进行 diff 是不够的，这主要是从我们本身 TotoroX 的业务考虑。如前文所述 <code>origin</code> 可以为用于创建页面的模版，<code>target</code> 为基于模版创建的页面，但后续需求变更时会对模版数据进行修改，而在我们的系统中并不会同步到创建的页面，那么模版修改后需要将修改的内容同步到之前创建的页面，就需要提供一个用于合并新模版与旧页面的方法，下面我们就聊聊 merge 功能的实现。</p>\n<h2 id=\"Merge-功能实现\"><a href=\"#Merge-功能实现\" class=\"headerlink\" title=\"Merge 功能实现\"></a>Merge 功能实现</h2><p>在对 merge 功能实现过程进行讲解前，我们需要对 git 的合并策略进行一定程度的了解。</p>\n<p>git 采用三路合并策略：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B - C - D master(*)</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  E - F dev</span><br></pre></td></tr></table></figure>\n<p>以我们日常的开发协作流程为例，当前分支也就是主分支为 <code>master</code>，当尝试把 <code>dev</code> 开发分支合并到 <code>master</code> 时，两个分支共同拥有的提交就是 commitB，我们将该提交 commit 称为 <code>base</code>，<code>master</code> 分支最新的提交 commitD 称为 <code>ours</code>，而 <code>dev</code> 分支最新的提交 commitF 称为 <code>theirs</code>。</p>\n<p>那么 git 是怎样合并 <code>ours</code> 和 <code>theirs</code> 的呢？</p>\n<p>在合并时，会参考他们的共同祖先 <code>base</code>，并根据下面策略进行合并。</p>\n<table>\n<thead>\n<tr>\n<th>祖先（base）</th>\n<th>HEAD（ours）</th>\n<th>分支（theirs）</th>\n<th>结果</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n<td>A</td>\n<td></td>\n</tr>\n<tr>\n<td>A</td>\n<td>A</td>\n<td>B</td>\n<td>B</td>\n<td>如果一方修改了一行，那么这一行选择修改版的</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B</td>\n<td>A</td>\n<td>B</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B</td>\n<td>B</td>\n<td>B</td>\n<td>如果某一行双方拥有相同的变更，则选择修改过的行</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B</td>\n<td>C</td>\n<td>conflict</td>\n<td>如果某一行双方都修改了，且修改得不一样，则报告冲突，需要用户解决</td>\n</tr>\n</tbody>\n</table>\n<p>根据上表规则，合并过程类似这样：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-merge-strategy.png\" alt=\"合并过程\"></p>\n<p>可以看到，第四行，双方都修改了，且各自修改的内容不一样，所以 git 不知道怎么解决，所以就把问题抛给用户了。</p>\n<h3 id=\"根节点层级筛选合并\"><a href=\"#根节点层级筛选合并\" class=\"headerlink\" title=\"根节点层级筛选合并\"></a>根节点层级筛选合并</h3><p>我们在实现 merge 功能时，正是采用了与此种合并策略一致的方式。在 merge 的合并流程中，原始数据即为<strong>祖先</strong>（base），而实际需要合并的两份数据分别为 <strong>Head</strong>（ours）和<strong>分支</strong>（theirs）。我们将 <code>base</code> 作为中间者，以此判断两份配置数据哪些部分是属于原始数据的，哪些部分又是新数据。</p>\n<p>首先，我们分别将新数据与共同组件 <code>base</code> 进行 diff 操作，获得分别的 JSON Schema 结构的结果，后续再对结果进行 mergeBranch 的操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">base, ours, theirs, diffComparator, mergeComparator</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> originDiff = diff(base, ours, diffComparator);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> targetDiff = diff(base, theris, diffComparator);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newDataSchema = mergeBranch(originDiff, targetDiff, mergeComparator);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> newDataSchema;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而由于 merge 是根据两两 diff 后的 Schema 结构的 JSON，我们先从<strong>根节点</strong>的 <code>_status</code> 字段匹配进行区分，共有五种情况：</p>\n<table>\n<thead>\n<tr>\n<th>源配置数据根节点状态</th>\n<th>变更配置数据根节点状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Equal</td>\n<td>Equal</td>\n<td>表示 <code>base</code> 和 <code>ours</code> 完全相等，<code>base</code> 和 <code>theirs</code> 完全相等，即表示三路完全相等</td>\n</tr>\n<tr>\n<td>Equal</td>\n<td>Updated</td>\n<td>表示 <code>base</code> 和 <code>ours</code> 完全相等，<code>base</code> 和 <code>theirs</code> 存在变更，即单路变更，最终给你会采用变更路数据</td>\n</tr>\n<tr>\n<td>Updated</td>\n<td>Equal</td>\n<td>表示 <code>base</code> 和 <code>ours</code> 存在变更，<code>base</code> 和 <code>theirs</code> 完全相等，即单路变更，最终给你会采用变更路数据</td>\n</tr>\n<tr>\n<td>Updated</td>\n<td>Updated</td>\n<td>表示 <code>base</code> 和 <code>ours</code> 存在变更，<code>base</code> 和 <code>theirs</code> 也存在变更，但是变更对应的值不相等，即三路冲突</td>\n</tr>\n<tr>\n<td>Updated</td>\n<td>Updated</td>\n<td>表示 <code>base</code> 和 <code>ours</code> 存在变更，<code>base</code> 和 <code>theirs</code> 也存在变更，但是变更对应的值相等，实际上 <code>ours</code> 和 <code>theirs</code> 变更值与 <code>base</code> 值冲突</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-merge-venn-diagram.jpg\" alt=\"变更状态韦恩图\"></p>\n<p>对上述五种情况进行分析归纳后，在代码实现层面上可以大致分为三个方向处理：</p>\n<ol>\n<li>三路相等（A-A-A）=&gt; <code>mergeUnmodified</code>（相当于上文韦恩图天蓝色部分中状态为 <code>equal</code> 的部分）</li>\n<li>单路变更，采用变更路数据（A-A-B、A-B-A）=&gt; <code>mergeUpdated</code>（相当于上文韦恩图紫色和橙色部分，表示的是 <code>base</code> 存在但是存在变更的状态，可以是完全或局部的删除和冲突，也可以是局部配置项的新增，但是不可能是完全的新增）</li>\n<li>两路变更，根据变更情况选择或保留冲突状态并提供手动处理方式，变更又分为新增、删除和修改（A-B-B、A-B-C）=&gt; <code>mergeConflict</code>（相当于上文韦恩图绿色、红色和蓝灰色）</li>\n</ol>\n<p>三路相等的情况是最好处理的，在对根节点进行遍历时匹配两者的 <code>_status</code> 变化状态为相等状态（<code>equal</code>）时即表明三路相等。</p>\n<p>单路变更的情况，在对根节点进行遍历时匹配两者的 <code>_status</code> 为相等（<code>equal</code>）而另一方为不相等，即为需要采用变更路数据。</p>\n<p>而对于两路变更的情况，我们不能单纯地以根节点的状态作为区分，这是因为我们采用了上文提及过的<strong>自底向上的状态变更显示策略</strong>，所以根节点呈现为变更状态，不代表整个结构内部的属性均为变更状态，也可能因为某个配置项的变更，导致结构树上层的状态改变。所以对于这种情况，我们又能细分为两种情况进行处理：</p>\n<ol>\n<li>通过 <code>comparator</code> 比较函数能两两匹配的节点树，实际上为 <code>base</code>、<code>ours</code> 和 <code>theirs</code> 三路均存在该根节点的，则需要对双方子孙层级的节点进行递归遍历并逐一对比（相当于上文韦恩图中蓝色 <code>conflict</code> 的部分）</li>\n<li>在对比双方的配置数据中，根节点状态 <code>_status</code> 为新增状态（<code>add</code>）且子孙层级的配置属性值也为新增状态时，则可判断该配置树为完全新增（相当于上文韦恩图中绿色 <code>add</code> 的部分），按照约定的合并策略，需要保留整个配置树</li>\n</ol>\n<h3 id=\"子孙层级筛选合并\"><a href=\"#子孙层级筛选合并\" class=\"headerlink\" title=\"子孙层级筛选合并\"></a>子孙层级筛选合并</h3><p>下面我们把重点聚焦于两路变更的情况下子孙层级筛选合并的实现。</p>\n<p>从根节点的变更状态的角度分析（已排除完全新增的配置节点树），可以大致分为五种情况：</p>\n<table>\n<thead>\n<tr>\n<th>base_ours 根节点状态</th>\n<th>base_theirs 根节点状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Add</td>\n<td>Add</td>\n<td>表示 <code>base</code> 没有某项配置项，而 <code>ours</code> 和 <code>theris</code> 新增了某项配置项</td>\n</tr>\n<tr>\n<td>Conflict</td>\n<td>Conflict</td>\n<td>表示 <code>base</code> 存在某项配置项，<code>ours</code> 也存在该项配置项但是值与 <code>base</code> 不同，<code>theris</code> 也存在该项配置项但是值与 <code>base</code> 也不同（未必与 <code>ours</code> 相同/不同）</td>\n</tr>\n<tr>\n<td>Conflict</td>\n<td>Delete</td>\n<td>表示 <code>base</code> 存在某项配置项，<code>ours</code> 也存在该项配置项但是值与 <code>base</code> 不同，而 <code>theris</code> 则不存在该项配置项</td>\n</tr>\n<tr>\n<td>Delete</td>\n<td>Conflict</td>\n<td>表示 <code>base</code> 存在某项配置项，<code>ours</code> 不存在该项配置项，而 <code>theris</code> 存在该项配置项且值与 <code>base</code> 不同</td>\n</tr>\n<tr>\n<td>Delete</td>\n<td>Delete</td>\n<td>表示 base 存在某项配置项，<code>ours</code> 和 <code>theris</code> 均不存在该配置项</td>\n</tr>\n</tbody>\n</table>\n<p>我们以一个简单的代码示例说明：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-merge-code-demo.jpg\" alt=\"三路合并配置代码示例\"></p>\n<p>结合上文提及五种两两比对存在变更状态时的情况，并结合代码示例得出以下结论：</p>\n<ul>\n<li><code>color</code> 对应第一种情况，<code>base</code> 没有该配置项，而 <code>ours</code> 和 <code>theirs</code> 则有</li>\n<li><code>width</code> 对应第二种情况，<code>base</code> 有该配置项，而 <code>ours</code> 和 <code>theirs</code> 同样有该配置项，但是 <code>ours</code> 和 <code>theirs</code> 的值存在差异</li>\n<li><code>height</code> 同样对应第二种情况，与 <code>width</code> 配置项不同的是，<code>ours</code> 和 <code>theirs</code> 的值严格相等</li>\n<li><code>translateX</code> 对应第三种情况，<code>base</code> 与 <code>ours</code> 有该配置，且值冲突，而 <code>theirs</code> 则删除了该配置项</li>\n<li><code>translateX</code> 对应第四种情况，<code>base</code> 与 <code>theirs</code> 有该配置，且值冲突，而 <code>ours</code> 则删除了该配置项</li>\n<li><code>line-height</code> 对应第五种情况，仅 <code>base</code> 存在该配置项，<code>ours</code> 和 <code>theirs</code> 均删除了该配置项</li>\n</ul>\n<blockquote>\n<p>这里提及的新增或删除字段只为覆盖更完整的功能，实际的可视化配置业务中，因为组件的配置项基本固定且均提供了默认值，所以出现新增或删除字段的情况较少。</p>\n</blockquote>\n<p>最后基于 <code>base</code> 进行 diff 后得出如下两份 JSON Schema 结构差异化数据：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-between-base-and-ours.jpg\" alt=\"diff-between-base-and-ours\"></p>\n<p><img src=\"http://img.mrsingsing.com/diff-between-base-and-theirs.jpg\" alt=\"diff-between-base-and-theirs\"></p>\n<p>基于三路合并的策略，当三路值均不同时会保留差异让用户手动解决，当变更两路值相同或新增时则保留相同值，最后合并后得出新的 JSON Schema 配置数据：</p>\n<p><img src=\"http://img.mrsingsing.com/diff-tool-merge-base-ours-and-theirs.jpeg\" alt=\"Merge base and ours and theirs\"></p>\n<h2 id=\"Revert-功能实现\"><a href=\"#Revert-功能实现\" class=\"headerlink\" title=\"Revert 功能实现\"></a>Revert 功能实现</h2><p>最终通过自动合并和手动解决冲突，完整的配置数据应该所有节点都表示为相等状态。通过对返还的 JSON Schema 结构的数据递归还原，自动新建页面即完成整个批量更新页面的功能。</p>\n<hr>\n<p><strong>参考资料</strong>：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/longintchar/article/details/83049840\" target=\"_blank\" rel=\"noopener\">三路合并 Git 学习笔记 17</a></li>\n</ul>"},{"title":"前端开发登录鉴权方案完全梳理","date":"2020-06-25T00:00:00.000Z","_content":"\n登录鉴权是互联网信息交互中永恒的话题，毕竟在工作中几乎每天都会接触到，适逢最近需要对现有的系统平台进行 SSO 的流程改造，所以趁这个机会好好总结前端工程师接触到的登录方式。\n\n鉴权也叫身份验证（Authentication），是指验证用户是否拥有访问系统的权利。在日常的生活中，身份验证随处可见，比如：进入高铁站候车室、机场候机楼需要检查票据和身份证件；游玩主题乐园、名胜风景区需要购买门票，并由入口处人员鉴定有效后方可拥有进入园区游玩的权利。\n\n而在计算机领域中，身份验证的方法有很多种：基于共享密钥的身份验证、基于生物学特征的身份验证和基于公开密钥加密算法的身份验证。不同的身份验证方法，安全性也各自不同。\n\n下面我将从前端开发工程师的角度出发，梳理 Web 应用前后端数据交互中的各种鉴权方案。\n\n<!-- more -->\n\n以下为本文大纲：\n\n- HTTP 基本认证\n- Session-Cookie 认证\n  - koa-session\n- Token 认证\n  - JWT 认证\n  - koa-jwt\n- OAuth2 开放授权\n- SSO 单点登录\n- LDAP 认证登录\n- 扫码登录\n- 联合登录\n- 信任登录\n- 易混淆概念分析\n\n## HTTP 基本认证\n\n在 HTTP 中，基本认证方案（Basic Access Authentication）是允许 HTTP 用户代理（通常指的就是网页浏览器）在请求时，通过用户提供用户名和密码的方式，实现对用户身份的验证。\n\n基本认证中，最关键的是四个要素：\n\n1. `uid`：用户的 ID，也就是我们常说的用户名\n2. `password`：密码\n3. `realm`：领域，其实就是指当前认证的保护范围\n\n在进行基本认证的过程中，HTTP 的请求头字段会包含 Authorization 字段，`Authorization: Basic <用户凭证>`，该用户凭证是 `用户名` 和 `密码` 的组合而成的 **Base64 编码**。\n\n```\nGET /securefiles/ HTTP/1.1\nHost: www.example.com\nAuthorization: Basic aHR0cHdhdGNoOmY=\n```\n\n![HTTP 基本认证流程图](http://img.mrsingsing.com/authentication-http-basic-access-authentication.jpg)\n\n1. 用户在浏览器中访问了受限制的网页资源，但是没有提供用户的身份信息\n2. 服务端接收到请求后返回 401 应答码（Unauthorized，未被授权的）要求进行身份验证，并附带提供了一个认证域（Access Authentication）`WWW-Authenticate` 说明如何进行验证的方法，例如 `WWW-Authenticate: Basic realm=\"Secure Area\"`，`Basic` 就是验证的模式，而 `realm=\"Secure Area\"` 则为保护域（告知认证的范围），用于与其他请求 URI 作区别\n3. 浏览器收到应答后，会显示该认证域给用户并提示输入用户名和密码，此时用户可以选择录入信息后确定或取消操作\n4. 用户输入了用户名和密码后，浏览器会在原请求头新增认证消息字段 `Authorization` 并重新发送请求，过程如下：\n\n- 将用户名和密码拼接为 `用户名:密码` 格式的字符串\n- 如果服务器 `WWW-Authenticate` 字段有指定编码，则将字符串编译成对应的编码\n- 将字符串编码为 Base64\n- 拼接 `Basic`，设置为 `Authorization` 字段，假设用户名为 `admin`，密码为 `password`，则拼接后为 `admin:password`，使用 Base64 编码后为 `YWRtaW46cGFzc3dvcmQ=`，那么最终在 HTTP 头部里会是这样：`Authorization: Basic YWRtaW46cGFzc3dvcmQ=`\n\n```js\nBuffer.from('admin:password').toString('base64');\n// YWRtaW46cGFzc3dvcmQ=\n```\n\n5. 服务端接收了该认证后并返回了用户请求的网页资源。如果用户凭证非法或无效，服务器可能会再次返回 401 应答码，客户端就需要再次输入用户名和密码\n\n服务端验证的步骤：\n\n1. 根据用户请求资源的地址，确定资源对应的 `realm`\n2. 解析 Authorization 请求首部，获得用户名和密码\n3. 判断用户是否有访问该 `realm` 的权限\n4. 验证用户名、密码是否匹配\n\n> 当然，也有可能在首次请求中，在请求头附带了认证消息头，那么就不需要再作身份信息的录入步骤\n\n优点：\n\n- 唯一的优点是实现简单，被广泛支持\n\n缺点：\n\n- 由于用户名和密码是以明文的形式在网络中进行传输，容易被嗅探器探测到，所以基本验证方案并不安全\n- 除此之外，Base64 编码并非加密算法，其无法保证安全与隐私，这里仅用于将用户名和密码中的不兼容的字符转换为均与 HTTP 协议兼容的字符集\n- 即使认证内容无法被解码为原始的用户名和密码也是不安全的，恶意用户可以再获取了认证内容后使用其不断的享服务器发起请求，这就是所谓的重放攻击\n- 该方案除了存在安全缺陷外，Basic 认证还存在无法吊销认证的情况\n\n> HTTP 的基本验证方案应与 HTTPS / TLS 协议搭配使用。加入没有这些安全方面的增强，那么基本验证方案不应该被用来保护敏感或者极具价值的信息。\n\n应用场景：内部网络，或者对安全要求不是很高的网络\n\n## Session-Cookie 认证\n\n`Session-Cookie` 认证是利用服务端的 Session（会话）和浏览器（客户端）的 Cookie 来实现的前后端通信认证模式。\n\n由于 HTTP 请求时是无状态的，服务端正常情况下无法得知请求发送者的身份，这个时候我们如果要记录状态，就需要在服务端创建 Session 会话，将相同客户端的请求都维护在各自的会话记录中，每当请求到达服务端时，先校验请求中的用户标识是否存在于 Session 中，如果有则表示已经认证成功，否则表示认证失败。\n\nCookie 主要用于以下三个方面：\n\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）\n- 个性化设置（如用户自定义设置、主题等）\n- 浏览器行为追踪（如跟踪分析用户行为等）\n\n下图为 Session-Cookie 认证的工作流程图：\n\n![Session-Cookie 认证流程图](http://img.mrsingsing.com/authentication-session-cookie.jpg)\n\n1. 服务端在接收到来自客户端的首次访问时，会自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证 `session_id`（通常称为 `sid`），并在响应头 `Set-Cookie` 中设置这个唯一标识符\n2. 签名，对 `sid` 进行加密处理，服务端会根据这个 `secret` 密钥进行解密（非必需步骤）\n3. 浏览器收到请求响应后会解析响应头，并自动将 `sid` 保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息\n4. 服务端在接收客户端请求时会去解析请求头 Cookie 中的 `sid`，然后根据这个 `sid` 去找服务端保存的该客户端的 `sid`，然后判断该请求是否合法\n5. 一旦用户登出，服务端和浏览器将会同时销毁各自保存的会话 ID，服务端会根据数据库验证会话身份凭证，如果验证通过，则继续处理\n\n> ⚠️ 注意，这里相对于使用服务端，在另一端我使用了 `浏览器` 而非客户端，主要是因为 Cookie 是仅在浏览器中存在的报文字段，诸如移动原生 APP 是无法解析存储 Cookie 请求/响应头的。\n\n优点：\n\n1. Cookie 简单易用，在不受用户干预或过期处理的情况下，Cookie 通常是客户端上持续时间最长的数据保留形式\n2. Session 数据存储在服务端，相较于 JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的 Session 就可以了，方便管理\n\n缺点：\n\n1. 非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被 CSRF 等攻击）\n2. Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能\n3. 用户认证后，服务端做认证记录，如果认证的记录被保存在内存中，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权资源，这样在分布式的应用上，相应的限制了负载均衡的能力，也意味着限制了应用的扩展能力\n\n### koa-session\n\n没有代码谈再多都是空中楼阁，下面尝试在 Koa 中使用 `koa-session2` 中间件实现 Session-Cookie 这种鉴权方式。\n\n在实际项目中，与客户端的会话信息往往需要在服务外再设立额外的外部存储机制，外部存储可以是任何的存储机制，例如内存数据结构，也可以是本地的文件系统，或是使用诸如 Redis 等 NoSQL 数据库。\n\n`koa-session2` 自身实现的存储方式为保存在内存中的，而下面我们就介绍一种拓展 `koa-session2` 结合 Redis 实现 Session-Cookie 认证方式的方案：\n\n```js\nconst Redis = require('ioredis');\nconst { Store } = require('koa-session2');\n\nclass RedisStore extends Store {\n  constructor() {\n    super();\n    // 初始化 Redis\n    this.redis = new Redis();\n  }\n\n  // 根据 sid 获取用户信息\n  async get(sid, ctx) {\n    let data = await this.redis.get(`SESSION: ${sid}`);\n    return JSON.parse(data);\n  }\n\n  // 更新 sid 的用户信息\n  async set(session, { sid = this.getID(24), maxAge = 1000000 } = {}, ctx) {\n    try {\n      await this.redis.set(`SESSION: ${sid}`, JSON.stringfy(session));\n    } catch (e) {}\n\n    return sid;\n  }\n\n  // 销毁会话信息\n  async destroy(sid, ctx) {\n    return await this.redis.del(`SESSION: ${sid}`);\n  }\n}\n\nmodule.exports = RedisStore;\n```\n\n```js\n// app.js\nconst Koa = require('koa');\nconst session = require('koa-session2');\nconst Store = require('./Store.js');\n\nconst app = new Koa();\n\napp.use(\n  session({\n    // 种下 Cookie 的键名\n    key: 'SESSIONID',\n    // 禁止浏览器中 JS 脚本修改 Cookie\n    httpOnly: true,\n    // Cookie 加密签名机制\n    signed: true,\n    store: new Store(),\n  })\n);\n\napp.use(ctx => {\n  // Ignore favicon.ico\n  if (ctx.path === '/favicon.ico') return;\n\n  let user = this.session.user;\n\n  ctx.session.view = 'index';\n});\n\napp.use(ctx => {\n  // 如果设置了会话有效期刷新会话有效期\n  ctx.session.refresh();\n});\n```\n\n在 `koa-session` 中会话标识的实现仅是根据时间戳生成的随机字符串，如果担心 Cookie 传输中被恶意篡改或暴露信息，可以通过加入更多标识元素，例如 IP 地址、设备 ID 等。\n\nKoa 的 Cookie 实现默认带了安全机制，就是 `signed` 选项为 `true` 时，会自动给 Cookie 添加一个 SHA256 的签名，类似 `koa:sess=pjadZtLAVtiO6-Haw1vnZZWrRm8`，从而防止 Cookie 被篡改。\n\n至于担心的 Session 信息泄漏问题，`koa-session` 允许用户自定义编解码方法，例如：\n\n```js\nconst encode = json => CrytoJS.AES.encrypt(json, 'Secret Passphrase');\n\nconst decode = encrypted => CryptoJS.AES.decrypt(encrypted, 'Secret Passphrase');\n```\n\n`koa-session` 为 Koa 官方实现的中间件，功能强大，考虑的情况比较多，所以实现相对复杂。\n\n而 `koa-session2` 是社区实现的中间件，简洁易用。如果对实现有兴趣的同学可以在 Github 找到源码阅读。\n\n- [koa-session](https://github.com/koajs/session)\n- [koa-session2](https://github.com/Secbone/koa-session2)\n- [koa-session 学习笔记](https://segmentfault.com/a/1190000013039187)\n- [koa-session 的内部实现](https://www.jianshu.com/p/c1eff1b50d23)\n- [从 koa-session 源码解读 session 原理](https://juejin.im/post/5c148fd551882530544f341f)\n- [从 koa-session 中间件源码学习 cookie 与 session](https://segmentfault.com/a/1190000012412299)\n\n## Token 认证\n\n随着 Restful API、微服务的兴起，基于 Token 的认证现在已经越来越普遍。Token 和 Session-Cookie 认证方式中的 Session ID 不同，并非只是一个标识符。Token 一般会包含 `用户的相关信息`，通过验证 Token 不仅可以完成身份校验，还可以获取预设的信息。像 Twitter、微信、QQ、Github 等公有 API 都是基于这种方式进行认证的，一些开发框架如 OpenStack、Kubernetes 内部 API 调用也是基于 Token 的认证。\n\n![Token 认证流程图](http://img.mrsingsing.com/authentication-token-authencation.jpg)\n\n基于 Token 的身份验证方法：\n\n1. 用户输入登录信息并请求登录\n2. 服务端收到请求，验证用户输入的登录信息\n3. 验证成功后，服务端会 `签发`一个 Token（通常包含用户基础信息、权限范围和有效时间等），并把这个 Token 返回给客户端\n4. 客户端收到 Token 后需要把它存储起来，比如放在 localStorage 或 sessionStorage 里（一般不放 Cookie 因为可能会有跨域问题，以及安全性问题）\n5. 后续客户端每次向服务端请求资源的时候，将 Token 附带于 HTTP 请求头 Authorization 字段中发送请求\n6. 服务端收到请求后，去校验客户端请求中 Token，如果验证成功，就向客户端返回请求的数据，否则拒绝返还\n\n优点：\n\n- **服务端无状态**：Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态\n- **性能相对较好**：因为在验证 Token 时不用再去访问数据库或远程服务进行权限校验，自然可以提升不少性能\n- 支持移动设备\n- 支持跨域跨程序调用，因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题\n- 有效避免 CSRF 攻击（因为不需要 Cookie），但是会存在 XSS 攻击中被盗的风险，但是可选择 Token 存储在标记为 `httpOnly` 的 Cookie 中，能够有效避免浏览器中的 JS 脚本对 Cookie 的修改\n\n缺点：\n\n- 占带宽：正常情况下比 `sid` 更大，消耗更多流量，挤占更多宽带\n- 性能问题：相比较于 Session-Cookie 认证来说，Token 需要服务端花费更多时间和性能来对 Token 进行解密验证，其实 Token 相较于 Session—Cookie 来说就是一个时间换空间的方案\n\n> Session-Cookie 认证和 Token 认证的比较\n\nSession-Cookie 认证和 Token 认证有很多类似的地方，但是 Token 认证更像是 Session-Cookie 认证的升级改良版。\n\nSession-Cookie 认证仅仅靠的是 `sid` 这个生成的唯一标识符，服务端需要根据客户端传来的 `sid` 查询保存在服务端 Session 里保存的登录状态，当存储的信息数据量超过一定量时会影响服务端的处理效能。而且 Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的。\n\n而 Token 认证机制特别的是，实质上登录状态是用户登录后存放在客户端的，服务端不会充当保存 `用户信息凭证` 的角色，当每次客户端请求时附带该凭证，只要服务端根据定义的规则校验是否匹配和合法即可，客户端存储的手段也不限于 Cookie，可以使用 Web Storage 等其他缓存方式。简单来说，Session-Cookie 机制限制了客户端的类型，而 Token 验证机制丰富了客户端类型。\n\n除此之外，Token 验证比较灵活，除了常见的 JWT 外，可以基于 Token 构建专门用于鉴权的微服务，用它向多个服务的请求进行统一鉴权。\n\n### JWT 认证\n\nJWT（JSON Web Token）是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登录成功后将相关信息组成 JSON 对象，然后对这个对象进行某种方式的加密，返回给客户端，客户端在下次请求时带上这个 Token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。\n\nJWT 是 JSON 格式的被加密了的字符串：\n\n```\nJSON Data + Signature = JWT\n```\n\nJWT 对象通常由三部分组成：\n\n1. 头部（Headers）：包括类别（typ）、加密算法（alg）\n\n头部用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等。\n\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n这里我们说明了这是一个 JWT，并且我们所使用的签名算法是 HS256 算法。\n\n2. Claims：包括需要传递的用户信息\n\n载荷可以用来存放一些不敏感的信息\n\n```json\n{\n  \"iss\": \"Jehoshaphat Tse\",\n  \"iat\": 1441593502,\n  \"exp\": 1441594722,\n  \"aud\": \"www.example.com\",\n  \"sub\": \"mrsingsing@example.com\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\n这里面的前五个字段都是由 JWT 的标准所定义的:\n\n- `iss`：该 JWT 的签发者\n- `sub`：该 JWT 所面向的用户\n- `aud`：接收该 JWT 的一方\n- `exp`（expires）：什么时候过期，这是 Unix 时间戳\n- `iat`（issued at）：在什么时候签发的。把头部和载荷分别进行 Base64 编码后得到两个字符串，然后再将这两个编码后的字符串用英文句号连接起来（头部在前），形成新的字符\n\n3. Signature：\n\n最后，将上述拼接后的字符串，用 `alg` 指定的算法（HS256）与私有密钥（Secret）进行加密。加密后的内容也是字符串，最后这个字符串就是签名，把这个签名拼接在刚才的字符串后面就能得到完整的 JWT。Header 部分和 Claims 部分如果被篡改，由于篡改者不知道密钥是什么，也无法生成新的 Signature 部分，服务端也就无法通过，在 JWT 中，消息体是透明的，使用签名可以保证消息不被篡改。\n\n```js\nHMACSHA256(base64UrlEncode(Headers) + '.' + base64UrlEncode(Claims), SECREATE_KEY);\n```\n\n优点：\n\n1. 不需要在服务端保存会话信息（RESTful API 的原则之一就是无状态），所以易于应用的扩展，即信息不保存在服务端，不会存在 Session 扩展不方便的情况\n2. JWT 中的载荷可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数\n\n缺点：\n\n1. **过期时间问题**：由于服务端不保存 Session 状态，因此无法在使用过程中废止某个 Token，或是更改 Token 的权限。也就是说，一旦 JWT 签发，在到期之前就会始终有效，除非服务端部署额外的逻辑。因此如果是浏览器端应用的话，使用 JWT 认证机制还需要设计一套 JWT 的主动更新删除的机制，这样就增加了系统的复杂性。\n2. **安全性**：由于 JWT 的 Claims 是 Base64 编码的，并没有加密，因此 JWT 中不能存储敏感数据\n3. **性能问题**：JWT 占用空间过大，Cookie 限制一般是 4k，可能会无法容纳，所以 JWT 一般放 LocalStorage 里面，并且用户在系统的每次 HTTP 请求都会把 JWT 携带在 Header 里面，HTTP 请求的 Header 可能比 Body 还要大。\n\n### koa-jwt\n\n下面介绍 Koa 中使用 `koa-jwt` 进行颁发、校验 Token 的使用方法。\n\n服务端生成 Token\n\n```js\nconst router = require('koa-router')();\nconst jwt = require('koa-jwt');\n// 这里使用的是 MongoDB 数据库\nconst userModel = require('../model/userModel');\n\nconst secretOrPublicKey = 'TOKEN_EXAMPLE';\n\nrouter.post('/login', async ctx => {\n  const data = ctx.request.body;\n\n  // 根据用户提供的用户名和密码查询数据库中是否存在对应的用户信息\n  const userInfo = await userModel.findOne({ name: data.name, password: data.password });\n\n  let result = null;\n  if (userInfo !== null) {\n    // 根据用户信息签发 Token，设定有效时间为 2h\n    const token = jwt.sign({ name: userInfo.name, _id: userInfo._id }, secretOrPublicKey, {\n      expiresIn: '2h',\n    });\n\n    result = {\n      code: 200,\n      token: token,\n      msg: '登录成功',\n    };\n  } else {\n    result = {\n      code: 400,\n      token: null,\n      msg: '登录失败',\n    };\n  }\n\n  return (ctx.body = result);\n});\n```\n\n前端获取 Token：\n\n```js\n// 请求登录\nfunction login(userName, password) {\n  return axios\n    .post('/login', {\n      name: userName,\n      password: password,\n    })\n    .then(res => {\n      if (res.code === 200) {\n        localStorage.setItem('access_token', res.data.token);\n      } else {\n        console.log('登录失败');\n      }\n    })\n    .catch(e => console.error(e));\n}\n\n// 后续获取 Token 后续的 API 请求\n// 通过 Axios 拦截器加上 Authorization 请求头部字段\naxios.interceptors.request.use(config => {\n  const token = localStorage.getItem('token');\n\n  config.headers.common['Authorization'] = 'Bearer ' + token;\n\n  return config;\n});\n```\n\n服务端校验前端发送来的请求：\n\n```js\nconst koa = require('koa');\nconst jwt = require('koa-jwt');\nconst app = new Koa();\nconst secretOrPublicKey = 'TOKEN_EXAMPLE';\n\napp\n  .use(\n    jwt({\n      secret: secretOrPublicKey,\n    })\n  )\n  .unless({\n    path: [/\\register/, /\\/login/],\n  });\n```\n\n在 `koa-jwt` 的源码实现中，我们可以知道 Token 的鉴定是先判断请求头中是否带了 Authorization：\n\n- 有，则通过正则将 `token` 从 Authorization 中分离出来，Token 中是带有 Bearer 这个单词\n- 没有，则代表了客户端没有传 Token 到服务器，这时候就抛出 401 错误状态\n\n源码文件中的 `verify.js` 中，调用了 `jsonwebtoken` 库原生提供的 `verify()` 方法进行验证返回结果。\n\n[jsonwebtoken](https://github.com/auth0/node-jsonwebtoken) 的 `sign()` 用于生成 `token`，而 `verify()` 方法当然则是用来解析 `token`。属于 JWT 配对生产的两个方法，所以 `koa-jwt` 这个中间件也没做什么事，无非就是用正则解析请求头，调用 `jsonwebtoken` 的 `verify()` 验证 `token`，在 `koa-jwt` 文件夹的 `index.js` 中，`koa-jwt` 还调用 `koa-unless` 进行路由权限分发。\n\n- [Koa2 服务端使用 JWT 进行鉴权及路由权限分发的流程分析](http://www.uxys.com/html/JavaScript/20190722/52733.html)\n\n### Token 认证常见问题及解决方案\n\n#### 注销登录\n\n注销登录等场景下 Token 仍有效类似的场景：\n\n- 退出登录\n- 修改密码\n- 服务端修改了某个用户具有的权限或角色\n- 用户的账户被删除/暂停\n- 用户由管理员注销\n\n这个问题仅存在于 Token 认证中，因为 Session-Cookie 认证模式中，这些情况能够通过删除服务端 Session 中对应的记录解决，而 Token 认证中，如果服务端不增加其他逻辑的话，在失效前 Token 都是有效的。\n\n下面列出几种针对这些场景的解决方案：\n\n- **将 Token 存储在内存数据库**：将 Token 存入类似于 Redis 的内存数据库中。如果需要让某个 Token 失效就直接从 Redis 中删除这个 Token 即可。但是这样会导致每次使用 Token 发送请求都要先从 DB 中查询 Token 是否存在的步骤，而且违背了 JWT 无状态原则。\n- **黑名单机制**：和上述方案类似，使用内存数据库维护一份黑名单，如果想让某个 Token 失效的话就直接将这个 Token 放入到黑名单内即可。每次使用 Token 进行请求时都会先判断 Token 是否存在于黑名单中。\n- **修改密钥 Secret**：为每个用户创建专属密钥，如果想让某个 Token 失效，我们直接修改对应用户的密钥即可。但是，这样相较于前两种引入内存数据带入的危害更大：\n  - 如果服务是分布式的，每次发出新的 Token 时都必须在多台及其同步密钥。为此，你需要将机密存在数据库或其他外部服务中，这样和 Session 认证就没有太大区别了\n  - 如果用户同时在两个浏览器打开系统，或者在移动设备上打开系统，当它从一个地方将账号退出时，那么其他终端都需要重新登录认证，这是不可取的\n- **保持令牌的有效期限短并经常轮换**\n  - 很简单的方式，但是会导致用户登录状态不会被持久记录，而且需要用户经常登录\n\n#### 续签问题\n\nToken 的续签问题：\n\nToken 有效期一般不建议设置过长，而 Token 过期后如何认证，如何 `动态刷新` Token 等需要有效的方案解决。\n\n在 Session-Cookie 认证中，假设 Session 有效期为 30 分钟，如果 30 分钟内有资源请求访问，那么就把 Session 的有效期自动延长 30 分钟。\n\n- **类似于 Session 人中的做法**：当客户端访问服务端，发现 Token 即将过期时，服务端重新颁发新的 Token 给客户端\n- **每次请求都返回新 Token**：实现思路简单明了，但是开销较大\n- **Token 有效期设置到半夜**：折衷方案，保证大部分用户正常工作时间可以正常登录，适用于安全性要求不高的系统\n- **用户登录返回两个 Token**：第一个是 `accessToken`，它的过期时间设置比如半个小时，另一个是 `refreshToken`，它的过期时间更长一点，例如 1 天。客户端登录后，将 `accessToken` 和 `refreshToken` 保存在本地，每次访问将 `accessToken` 传给服务端。服务端校验 `accessToken` 的有效性，如果过期的话，就将 `refreshToken` 传给服务端。如果有效，服务端就生成新的 `accessToken` 给客户端。否则，客户端就重新登录即可。该方案不足的是：\n  - 需要客户端配合\n  - 用户注销的时候需要同时保证两个 Token 都无效\n  - 重新请求获取 Token 的过程中会有短暂 Token 不可用的情况（可以通过在客户端设置定时器，当 `accessToken` 快过期的时候，提前去通过 `refreshToken` 获取新的 `accessToken`）\n\nJWT 最适合的场景是不需要服务端保存用户状态的场景，如果考虑到 Token 注销和续签等场景的话，目前来说没有特别好的解决方案，大部分解决方案都给 Token 加上状态，这实际上就有点类似 Session-Cookie 认证了。\n\n## 单点登录\n\n**单点登录**（Single Sign-on）又称 SSO，是指在多系统应用群中登录单个系统，便可在其他所有系统中得到授权而无需再次登录。\n\n传统的 All-in-one 型应用的认证系统和业务系统集合在一起的，当用户认证通过时，将用户信息存入 Session 中。其他业务只需要从业务中通过对应会话身份凭证取到用户信息进行相关业务处理即可。\n\n传统的 Session 是将用户信息存入内存，维护一个哈希表。每次请求携带会话身份凭证 SessionID（Tomcat 中是 `JSESSIONID`）到服务端，根据此 SessionID 查找到对应的用户信息。\n\n利用 Redis 等内存数据库进行用户信息的存储，自定义 Token 生成规则将用户信息写入 Redis 中。这样将用户信息的存储和业务系统进行拆分，使系统更加健壮，更易于扩展。新增系统只需要从 SSO 中获取相关的认证即可进行横向的业务扩展。而且 Redis 本身的性质也易于进行 `集群化` 的部署。\n\n下面详述各种场景下 SSO 的实现方案。\n\n### 同域 SSO\n\n当存在两个相同域名下的系统 A `a.abc.com` 和系统 B `b.abc.com` 时，以下为他们实现 SSO 的步骤：\n\n1. 用户访问某个子系统时（例如 `a.abc.com`），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录\n2. 登录认证后，服务端把登录用户的信息存储于 Session 中，并为用户生成对应的会话身份凭证附加在响应头的 `Set-Cookie` 字段中，随着请求返回写入浏览器中，并回跳到设定的子系统链接中\n3. 下次发送请求时，当用户访问同域名的系统 B 时，由于 A 和 B 在相同域名下，也是 `abc.com`，浏览器会自动带上之前的 Cookie。此时服务端就可以通过该 Cookie 来验证登录状态了。\n\n这实际上使用的就是 Session-Cookie 认证的登录方式。\n\n### 跨域 SSO\n\n上述所提及的同域名 SSO 并不支持跨域名的登录认证，这显然不符合当今互联网发展潮流，毕竟大多数中大型企业内外部的系统都是部署在不同的域名下，下面我们介绍实现单点登录的标准流程。\n\n**CAS**（Central Authentication Service）中央授权服务，本身是一个开源协议，分为 1.0 版本和 2.0 版本。1.0 称为基础模式，2.0 称为代理模式，适用于存在非 Web 应用之间的单点登录。\n\nCAS 的实现需要三方角色：\n\n- Client：用户\n- Server：中央授权服务，也是 SSO 中心负责单点登录的服务器\n- Service：需要使用单点登录鉴权的各个业务服务，相当于上文中的系统 A / B\n\nCAS 的实现需要提供以下四个接口：\n\n- `/login`：登录接口，用于登录到中央授权服务\n- `/logout`：登出接口，用于从中央授权服务中登出\n- `/validate`：用于验证用户是否登录中央授权服务\n- `/serviceValidate`：用于让各个 Service 验证用户是否登录中央授权服务\n\nCAS 票据：\n\n- **TGT（Ticket Grangting Ticket）**：TGT 是 CAS 为用户签发的 `登录票据`，拥有了 TGT，用户就可以证明自己在 CAS 成功登录过。TGT 封装了 Cookie 值以及此 Cookie 值对应的用户信息。当 HTTP 请求到来时，CAS 以此 Cookie 值（TGC）为 `key` 查询缓存中是否有 TGT，如果有，则表示用户已登录过。\n- **TGC（Ticket Granting Cookie）**：CAS Service 生成 TGC 放入自己的 Session 中，而 TGC 就是这个 Session 的唯一标识（SessionID），以 Cookie 形式放到浏览器端，是 CAS Service 用来明确用户身份的凭证\n- **ST（Service Ticket）**：ST 是 CAS 为用户签发的访问某个 Service 的票据。用户访问 Service 时，Service 发现用户没有 ST，则要求用户去 CAS 获取 ST。用户向 CAS 发出 ST 的请求，CAS 发现用户有 TGT，则签发一个 ST，返回给用户。用户拿着 ST 去访问 Service，Service 拿 ST 去 CAS 验证，验证通过后，允许用户访问资源。\n\n这里可能概念太多会非常难理解，简单说明下，客户端需要各自维护与不同系统的登录状态，包括与中央授权服务的登录状态。所以，实际上 TGC 和 TGT 是维护客户端与中央授权服务登录状态的会话身份凭证的 `key-value` 键名值，而 ST 票据则是资源服务向中央授权服务获取用户登录状态、信息的交换凭证，只不过资源服务需要经用户的“手”上才能获取到该票据。\n\n详细步骤：\n\n![CAS 验证流程时序图](http://img.mrsingsing.com/authentication-cas-workflow.png)\n\n1. 用户访问系统 A 的受保护资源（域名是 `a.abc.com`），系统 A 检测出用户处于 `未登录` 状态，重定向（应答码 302）至 SSO 服务认证中心的登录接口，同时地址参数携带登录成功后回跳到系统 A 的页面链接（跳转的链接形如 `sso.abc.com/login?service=https%3A%2F%2Fwww.a.abc.com`）\n2. 由于请求没有携带 SSO 服务器上登录的票据凭证（TGC），所以 SSO 认证中心判定用户处于 `未登录` 状态，重定向用户页面至 SSO 的登录界面，用户在 SSO 的登录页面上进行登录操作。\n3. SSO 认证中心校验用户身份，创建用户与 SSO 认证中心之间的会话，称为 `全局会话`，同时创建 `授权令牌`（ST），SSO 带着授权令牌跳转回最初的系统 A 的请求地址：\n\n- 重定向地址为之前写在 `query` 中的系统 A 的页面地址\n- 重定向地址的 `query` 中包含 SSO 服务器派发的 ST\n- 重定向的 HTTP 响应中包含写 Cookie 的 Header。这个 Cookie 代表用户在 SSO 中的登录状态，它的值就是 TGC\n\n5. 浏览器重定向至系统 A 服务地址，此时重定向的 URL 中携带着 SSO 服务器生成的 ST\n6. 系统 A 拿着 ST 向 SSO 服务器发送请求，SSO 服务器验证票据的有效性。验证成功后，系统 A 知道用户已经在 SSO 登录了，于是系统 A 服务器使用该令牌创建与用户的会话，称为 `局部会话`，返回受保护网页资源\n7. 之后用户访问系统 B 受保护资源（域名 `b.abc.com`），系统 B 检测出用户处于 `未登录` 状态，跳转至 SSO 服务认证中心，同时地址参数携带授权令牌 ST（每次生成的 ST 都是不一样的）登录成功后回跳的链接\n8. SSO 认证中心发现用户已登录，跳转回系统 B 的地址，并附上令牌\n9. 系统 B 拿到令牌，去 SSO 认证中心校验令牌是否有效，SSO 认证中心校验令牌，返回有效，注册系统 B\n10. 系统 B 使用该令牌创建与用户的局部会话，返回受保护资源\n\n至此整个登录流程结束，而在实际开发中，基本上都会根据 CAS 增加更多的判断逻辑，比如，在收到 CAS Server 签发的 ST 后，如果 ST 被 Hacker 窃取，并且 Client 本身没来得及去验证 ST，被 Hacker 抢先一步验证 ST，怎么解决。此时就可以在申请 ST 时添加额外验证因子（如 IP、SessionID 等）。\n\n### LDAP 认证登录\n\nLDAP 的全称是 Lightweight Directory Access Protocol，即**轻量目录访问协议**，是一个开放、广泛被使用的工业标准（IEFT、RFC）。企业级软件也通常具备 \\*_支持 LDAP_- 的功能，比如 Jira、Confluence、OpenVPN 等，企业也经常采用 LDAP 服务器来作为企业的认证源和数据源。但是大家比较常见的误区是，可以使用 LDAP 来实现 SSO。我们可以先分析以下它的主要功能点或场景。\n\n- 作为数据源它可以用于存储\n  - 企业的组织架构树\n  - 企业员工信息\n  - 证书信息\n  - 会议室，打印机等等资源\n- 作为认证源，它也有多种用途\n  - 存储用户的密码\n  - 对外提供 LDAP 协议的认证方式（通过 LDAP BIND 协议来校验用户名和密码）\n  - 密码策略（密码复杂度，历史密码记录，用户锁定等等）\n\n## 信任登录\n\n信任登录是指所有不需要用户主动参与的登录，例如建立在私有设备与用户之间的绑定关系，凭证就是私有设备的信息，此时不需要用户再提供额外的凭证。信任登录又指用第三方比较成熟的用户库来校验凭证，并登录当前访问的网站。\n\n1. 登录服务 \\*_信任业务系统_- 的凭证校验结果\n2. 登录服务 \\*_信任第三方登录系统_- 的凭证校验结果，前提是必须又本站点的账号体系下的账号与第三方账号的一对一绑定关系，现在流行的授权方式也属于这个模式。\n\n目前比较常见的第三方信任登录帐号如：QQ 号淘宝帐号、支付宝帐号、微博帐号等。\n\n信任登录的好处是可以利用第三方庞大的用户群来推广、营销网站，同时减少用户的注册、登录时间。\n\n提到信任登录，我们就不得不提到 OAuth，正是有了 OAuth，我们的信任登录才得以实现。下面我们就来看下关于 OAuth 的一些介绍。\n\n## OAuth2 开发授权\n\nOAuth（开放授权）是一个开发标准，允许用户授权 `第三方网站` 访问他们存储在另外的服务提供商中的信息，而不需要接触到用户名和密码。为了保护数据的安全和隐私，第三方网站访问用户数据前都需要 `显式地向用户征求授权`。我们常见的 OAuth 认证服务的厂商有微信、QQ、支付宝等。\n\nOAuth 协议又有 1.0 和 2.0 两个版本，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。\n\n应用场景有：第三方应用的接入、微服务鉴权互信、接入第三方平台、第一方密码登录等。\n\n授权模式：\n\n- 授权码模式（Authorization Code Grant）\n- 隐式授权模式（Implicit Grant）\n- 密码模式（Resource Owner Password Credentials Grant）\n- 客户端模式（Client Credentials Grant）\n\n无论哪种授权模式，都必须拥有四种必要的角色参与：`客户端`、`授权服务器`、`资源服务器`，有的还有 `用户（资源拥有者）`。我们以微信开发平台的授权登录为例解释这四种角色：\n\n- 资源拥有者（Resource Owner）：这里指微信用户\n- 第三方应用（Third-party Application）：指内嵌在微信应用内的第三方应用，形式不限于 Web App、公众号 Web 网页、小程序等等\n- 授权服务器（Authorization Server）：这里指微信开发平台的授权服务\n- 资源服务器（Resource Server）：用于存储、获取用户资源，这里指的是微信开放平台的服务器\n\n### 授权码模式\n\n授权码模式是 OAuth 2.0 目前最安全最复杂的授权流程。\n\n![授权码模式](http://img.mrsingsing.com/authentication-authorization-code-grant.jpg)\n\n授权码模式的授权流程可以分为三个部分：\n\n1. Client Side：用户+客户端与授权服务端的交互\n2. Server Side：客户端与授权服务端之间的交互\n3. Check Access Token'：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互\n\n整个流程就是：客户端换取授权码，客户端使用授权码换取 Token，客户端使用 Token 访问资源\n\n> 前提条件：\n>\n> - 第三方客户端需要提前与资源拥有方（同时也是授权所有方）协商客户端 ID（client_id）以及客户端密钥（client_secret）\n> - 上述流程暂未将 `scope`、`state` 等依赖具体框架的内容写进来，这里可以参考 Spring Security OAuth2 的实现\n\n**Client Server 客户端换取授权码**\n\n这个客户端可以是浏览器\n\n1. 客户端将 `client_id + client_secret + 授权模式标识（grant_type）+ 回调地址（redirect_uri）` 拼接成 URL 访问授权服务器\n2. 授权服务端返回登录界面，要求 `用户登录`（此时用户提交的账号密码等直接发送到授权服务端，进行校验）\n3. 授权服务端返回授权审批界面，`用户授权` 完成\n4. 授权服务端 `返回授权码到回调地址`\n\n**Server Side 客户端使用授权码换取 Token**\n\n1. 客户端接收到授权码，并使用 `授权码 + client_id + client_secret` 访问授权服务端颁发 Token 令牌\n2. 授权服务端校验通过，颁发 Token 返回给客户端\n3. 客户端保存 Token 到存储器\n\n**Check Access Token 客户端使用 Token 访问资源**\n\n1. 客户端在请求头带上 Token，访问资源服务端\n2. 资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）\n3. 资源服务端校验成功，返回资源\n\n移动应用微信登录是基于 OAuth2.0 协议标准构建的微信 OAuth2.0 授权登录系统，在微信开放平台注册开发者账号，并拥有已审核通过的移动应用，并获得相应的 AppID 和 AppSecret，申请微信登录且通过审核后，可开始接入流程。\n\n```\n1. 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据 code 参数\n2. 通过 code 参数加上 AppId 和 AppSecret 等，通过 API 换取 access_token\n3. 通过 access_token 进行接口调用，获取用户基本数据资源或帮助用户实现基本操作\n```\n\n![微信 OAuth2.0 获取 access_token 时序图](http://img.mrsingsing.com/authentication-wx-oauth2-access-token.png)\n\n详情可以参阅 [微信登录功能 - 移动应用微信登录开发指南](https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html)，这里的实现就是授权码模式。\n\n### 隐式授权模式\n\n![隐式授权模式流程图](http://img.mrsingsing.com/authentication-implicit-grant.jpg)\n\n隐式授权模式大致可以分为两部分：\n\n1. Client Side：用户+客户端与授权服务端的交互\n2. Check Access Token：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互\n\n整个流程就是：客户端让用户登录授权服务端换取 Token，客户端使用 Token 访问资源\n\n**Client Side 客户端让用户登录授权服务端换 Token**\n\n1. 客户端（浏览器或单页应用）将 `client_id + 授权模式标识（grant_type）+ 回调地址（redirect_url）` 拼成 URL 访问授权服务端\n2. 授权服务端跳转用户登录界面，用户登录\n3. 用户授权\n4. 授权服务端 `访问回调地址` 返回 Token 给客户端\n\n**Check Access Token 客户端使用 Token 访问资源**\n\n1. 客户端在请求头附带 Token 访问资源服务端\n2. 资源服务端收到请求，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）\n3. 资源服务端校验成功，返回资源\n\n### 密码模式\n\n![密码模式流程图](http://img.mrsingsing.com/authentication-resource-owner-password-credentials-grant.jpg)\n\n密码模式的授权流程可以分为两部分：\n\n1. Client Side：用户与客户端的交互，客户端与授权服务端的交互\n2. Check Access Token'：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互\n\n整个流程就是：用户在客户端提交账号密码换取 Token，客户端使用 Token 访问资源\n\n**Client Server 用户在客户端提交账号密码换取 Token**\n\n1. 客户端要求用户登录\n2. 用户输入密码，客户端将表单中添加客户端的 `client_id + client_secret` 发送给授权服务端颁发 Token 令牌\n3. 授权服务端校验用户名、用户密码、`client_id` 和 `client_secret`，均通过后返回 Token 给客户端\n4. 客户端保存 Token\n\n**Check Access Token 客户端使用 Token 访问资源**\n\n1. 客户端在请求头带上 Token，访问资源服务端\n2. 资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）\n3. 资源服务端校验成功，返回资源\n\n### 客户端模式\n\n![客户端模式流程图](http://img.mrsingsing.com/authentication-client-credentials-grant.jpg)\n\n客户端模式的授权流程可以分为两部分：\n\n1. Server Side：客户端与授权服务端之间的交互\n2. Check Access Token'：客户端与资源服务端，资源服务端与授权服务端之间的交互\n\n整个流程就是：客户端使用自己的标识换取 Token，客户端使用 Token 访问资源\n\n**Client Server 客户端使用自己的标识换取 Token**\n\n1. 客户端使用 `client_id + client_secret + 授权模式标识` 发送给授权服务端颁发 Token 令牌\n2. 授权服务端校验通过后返回 Token 给客户端\n3. 客户端保存 Token\n\n**Check Access Token 客户端使用 Token 访问资源**\n\n1. 客户端在请求头带上 Token，访问资源服务端\n2. 资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）\n3. 资源服务端校验成功，返回资源\n\n### 授权模式选型\n\n考虑到授权场景的多样性，可以参考以下两种选型方式：\n\n- 按授权需要的多端情况\n- 按客户端类型与所有者\n\n按授权需要的多端情况：\n\n| 模式                              | 需要前端 | 需要后端 | 需要用户响应 | 需要客户端密钥 |\n| :-------------------------------- | :------- | :------- | :----------- | :------------- |\n| 授权码模式 Authorization Code     | ✓        | ✓        | ✓            | ✓              |\n| 隐式授权模式 Implicit Grant       | ✓        | ✗        | ✓            | ✗              |\n| 密码授权模式 Password Grant       | ✓        | ✓        | ✓            | ✓              |\n| 客户端授权模式 Client Credentials | ✗        | ✓        | ✗            | ✓              |\n\n按照客户端类型与访问令牌所有者分类：\n\n![OAuth2.0 模式选型](http://img.mrsingsing.com/authentication-oauth2-mode-selection.jpg)\n\n## 联合登录\n\n联合登录指同时包含多种凭证校验的登录服务，同时，也可以理解为使用第三方凭证进行校验的登录服务。这个概念有点像 OAuth2.0 的认证方式。\n\n最经典的莫过于 APP 内嵌 H5 的使用场景，当用户从 APP 进入内嵌的 H5 时，我们希望 APP 内已登录的用户能够访问到 H5 内受限的资源，而未登录的用户则需要登录后访问。\n\n这里思路主要有两种，一种是原生跳转内嵌 H5 页面时，将登录态 Token 附加在 URL 参数上，另一种则是内嵌 H5 主动通过与原生客户端制定的协议获取应用内的登录状态。\n\n## 扫码登录\n\n二维码也称为二维条码，是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。一维条码的宽度记载着数据，而其长度没有记载数据。二维码的长度、宽度均记载着数据。二维码有一维条码没有的 **定位点\\*- 和 **容错机制\\*\\*。容错机制在即使没有识别到全部的条码、或是说条码有污损时，也可以正确地还原条码上的信息。\n\n扫码登录通常见于移动端 APP 中，基本操作流程是让已登录用户主动扫描二维码，以使 PC 端的同款应用得以快速登录的方式，常见的具备扫码登录的应用有微信、钉钉、支付宝等。\n\n![扫码登录流程图](http://img.mrsingsing.com/authentication-scan-qrcode-login-workflow.jpg)\n\n扫码登录可以分为三个阶段：待扫码、已扫码待确认和已确认。\n\n### 待扫码阶段\n\n**待扫码阶段**即上述流程图中 1~5 的阶段，亦即生成二维码阶段，这个阶段与移动端没有关系，主要是 PC 端与服务端进行交互的过程。\n\n首先 PC 端携带设备信息向服务端发起了生成二维码请求，服务端接收到请求后生成 `UUID` 作为二维码 ID，并将 UUID 与 `PC 端的设备信息` 关联起来存储在 Redis 服务器中，然后返回给 PC 端。\n\n当 PC 端收到二维码 ID 之后，将二维码 ID 以 `二维码的形式` 展示，等待移动端扫码。此时 PC 端开始轮询查询二维码状态，直到登录成功。当然除了使用轮询查询，也能使用 WebSocket 实现查询/推送二维码状态的需求。如果移动端未扫描，那么一段时间后二维码会自动失效。\n\n### 已扫码待确认阶段\n\n**已扫码待确认阶段**亦即流程图中的 6~10 的阶段，在 PC 端登录微信时，手机扫码后，PC 端的二维码会显示为已扫码，并提示需要在手机上确认，这个阶段是移动端与服务端交互的过程。\n\n移动端扫描二维码后，会自动获取到二维码 ID，并将移动端登录的信息凭证（Token）和二维码 ID 作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。\n\n服务端接受请求后，会将 `Token 与二维码 ID` 关联，为什么需要关联呢？因为，当我们在使用微信时，移动端退出时，PC 端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个一次性 Token，这个 Token 会返回给移动端，一次性 Token 用作确认时的凭证。\n\nPC 端轮询到二维码的状态已经发生变化，会将 PC 端的二维码更新为已扫描，请确认。\n\n### 已确认阶段\n\n**已确认阶段**为流程图中的步骤 11~15，这是扫码登录的最后阶段，用户确认登录，移动端携带上一步中获取的 `临时 Token` 发送给服务端校验。服务端校验完成后，会更新二维码状态，并且给 PC 端生成一个 `正式的 Token`，后续 PC 端就是持有这个 Token 访问服务端。\n\nPC 端的定时器，轮询到二维码状态为已登录状态，并且会获取到了生成的 Token，完成登录，后续访问都基于 Token 完成。\n\n在服务端会跟移动端一样，维护着 Token 跟二维码、PC 设备信息、账号等信息。\n\n## 一键登录\n\n最传统的登录方式莫过于提供账号密码校验，但这毫无疑问需要消耗用户的记忆成本。随着无线互联的发展以及手机卡实名制的推广，手机号俨然已成为特别的身份证明，与账号密码相比，手机号可以更好地验证用户的身份，防止恶意注册。\n\n但是手机号注册还是需要一系列繁琐的操作：输入手机号、等待短信验证码、输入验证码、点击登录。整个流程少说二十秒，而且如果收不到短信，也就登录补了，这类问题有可能导致潜在的用户流失。\n\n短信验证码的作用就是证明当前操作页面的用户与输入手机号的用户为相同的人，那么实际上只要我们能够获取到当前手机的手机号并与输入的手机号对比匹配后便能达到校验的功能。但是，无论是原生 APP 还是 H5 网页都是不具备直接获取用户手机号的功能的，而这种需求运营商能够通过手机 SIM 卡的流量数据查询。随着运营商开放了相关的服务，我们能够接入运营商提供的 SDK 并付费使用相关的服务。\n\n下图为一键登录的流程图：\n\n![一键登录流程图](http://img.mrsingsing.com/authentication-one-click-login-workflow.png)\n\n主要步骤：\n\n1. SDK 初始化：调用 SDK 方法，传入平台配置的 AppKey 和 AppSecret\n2. 唤起授权页：调用 SDK 唤起授权接口，SDK 会先向运营商发起获取手机号掩码的请求，请求成功后跳到授权页。授权页会显示手机号掩码以及运营商协议给用户确认。\n3. 同意授权并登录：用户同意相关协议，点击授权页面的登录按钮，SDK 会请求本次取号的 Token，请求成功后将 Token 返回给客户端\n4. 取号：将获取到的 Token 发送到自己的服务器，由服务端携带 Token 调用运营商一键登录的接口，调用陈工就返回手机号码。服务端用手机号进行登录或注册操作，返回操作结果给客户端，完成一键登录。\n\n由于国内三大运营商各自有独立的 SDK，所以会导致兼容方面的工作会特别繁琐。如果要采用一键登录的方案，不妨采用第三方提供了号码认证服务，下列几家供应商都拥有手机号码认证能力：\n\n- [阿里 - 号码认证服务](https://help.aliyun.com/product/75010.html)\n- [创蓝 - 闪验](http://shanyan.253.com/)\n- [极光 - 极光认证](https://www.jiguang.cn/identify)\n- [mob - 秒验](https://www.mob.com/mobService/secverify)\n\n在认证过程中，需要用户打开蜂窝网络，如果手机设备没有插入 SIM 卡、或者关闭蜂窝网络的情况下，是无法完成认证的。所以就算接入一键登录，还是要兼容传统的登录方式，允许用户在失败的情况下，仍能正常完成登录流程。\n\n## 总结\n\n鉴权授权是计算机领域无法躲避的技术议题，认证、授权、鉴权和权限控制是围绕这个议题的几个关键概念：认证（Identification）是指根据声明者提供的资料，确认声明者身份；授权（Authorization）则是资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作；鉴权（Authentication）指的对声明者所声明的真实性进行校验。从授权角度出发，会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。\n\n- Authorization 决定你是否有权限去获取资源\n- Authentication 校验你说你是谁\n\n```\n授权 -> 鉴权 -> 权限控制\n```\n\n花了一周时间将登录鉴权授权方面的知识总结了一番，确认对各种方案的实施细节，以及设计原理、方案优劣都有了更深一层的了解，在学习的过程中不免会联想到无论是生活中各种类似的场景，也会想到计算机领域中诸如 Linux 系统、数据库等权限控制相关机制。这是个融汇贯通的学习过程，发现这种针对某个议题的体系式整理，对前端技术体系中各个独立的点连通起到了不错的效果。\n\n---\n\n**参考资料：**\n\n- [📖 Wikipedia：Basic Access Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication)\n- [📖 HTTP 身份验证 Authentication](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication)\n- [📖 RFC 7019 - JSON Web Token（JWT）](https://tools.ietf.org/html/rfc7519)\n- [📖 CAS 官方文档](https://apereo.github.io/cas/4.2.x/index.html)\n- [📝 一文读懂 HTTP Basic 身份认证](https://juejin.im/entry/5ac175baf265da239e4e3999)\n- [📝 你在用 JWT 代替 Session？](https://zhuanlan.zhihu.com/p/43527568)\n- [📝 用户认证：基于 JWT 和 Session 的区别和优缺点](https://juejin.im/post/5cefad23e51d4510774a87f4#heading-4)\n- [📝 JWT 身份认证优缺点分析以及常见问题解决方案](https://zhuanlan.zhihu.com/p/85873228)\n- [📝 前端需要了解的 SSO 与 CAS 知识](https://juejin.im/post/5a002b536fb9a045132a1727)\n- [📝 不务正业的前端之 SSO（单点登录）实践](https://juejin.im/post/5b51f39b5188251a9f24a264)\n- [📝 面试题：给我说一下你项目中的单点登录是如何实现的](https://zhuanlan.zhihu.com/p/102898335)\n- [📝 单点登录系统](https://zhuanlan.zhihu.com/p/60376970)\n- [📝 单点登录原理与简单实现](https://www.cnblogs.com/ywlaker/p/6113927.html)\n- [📝 单点登录 LDAP 协议](https://zhuanlan.zhihu.com/p/92263756)\n- [📝 信任登录与联合登录有什么差异？](https://www.zhihu.com/question/21387523)\n- [📝 OAuth2.0 深入了解：以微信开发平台统一登录为例](https://juejin.im/entry/5a93506e6fb9a0634c268da8)\n- [📝 OAuth 2.0 概念及授权流程梳理](https://www.cnblogs.com/hellxz/p/oauth2_process.html)\n- [📝 论 H5 嵌入 APP 的联合登录的解决方案](https://juejin.im/post/5d15d3336fb9a07efb69994f)\n- [📝 聊一聊二维码扫描登录原理](https://juejin.im/post/5e83e716e51d4546c27bb559)\n- [📝 阿里面试官：分别说说微信和淘宝扫码登录背后的实现原理](https://mp.weixin.qq.com/s/gA0JQp4j2ym9qOyQkC3qkA)\n- [📝 用户一键登录，如何实现](https://juejin.im/post/5d197adff265da1bb31c4fa9)\n- [📝 微服务架构下的鉴权，怎么做更优雅？](https://learnku.com/articles/30704)\n- [📝 认证、授权、鉴权和权限控制](http://www.hyhblog.cn/2018/04/25/user_login_auth_terms/)\n","source":"_posts/authentication.md","raw":"---\ntitle: 前端开发登录鉴权方案完全梳理\ndate: '2020-06-25'\n---\n\n登录鉴权是互联网信息交互中永恒的话题，毕竟在工作中几乎每天都会接触到，适逢最近需要对现有的系统平台进行 SSO 的流程改造，所以趁这个机会好好总结前端工程师接触到的登录方式。\n\n鉴权也叫身份验证（Authentication），是指验证用户是否拥有访问系统的权利。在日常的生活中，身份验证随处可见，比如：进入高铁站候车室、机场候机楼需要检查票据和身份证件；游玩主题乐园、名胜风景区需要购买门票，并由入口处人员鉴定有效后方可拥有进入园区游玩的权利。\n\n而在计算机领域中，身份验证的方法有很多种：基于共享密钥的身份验证、基于生物学特征的身份验证和基于公开密钥加密算法的身份验证。不同的身份验证方法，安全性也各自不同。\n\n下面我将从前端开发工程师的角度出发，梳理 Web 应用前后端数据交互中的各种鉴权方案。\n\n<!-- more -->\n\n以下为本文大纲：\n\n- HTTP 基本认证\n- Session-Cookie 认证\n  - koa-session\n- Token 认证\n  - JWT 认证\n  - koa-jwt\n- OAuth2 开放授权\n- SSO 单点登录\n- LDAP 认证登录\n- 扫码登录\n- 联合登录\n- 信任登录\n- 易混淆概念分析\n\n## HTTP 基本认证\n\n在 HTTP 中，基本认证方案（Basic Access Authentication）是允许 HTTP 用户代理（通常指的就是网页浏览器）在请求时，通过用户提供用户名和密码的方式，实现对用户身份的验证。\n\n基本认证中，最关键的是四个要素：\n\n1. `uid`：用户的 ID，也就是我们常说的用户名\n2. `password`：密码\n3. `realm`：领域，其实就是指当前认证的保护范围\n\n在进行基本认证的过程中，HTTP 的请求头字段会包含 Authorization 字段，`Authorization: Basic <用户凭证>`，该用户凭证是 `用户名` 和 `密码` 的组合而成的 **Base64 编码**。\n\n```\nGET /securefiles/ HTTP/1.1\nHost: www.example.com\nAuthorization: Basic aHR0cHdhdGNoOmY=\n```\n\n![HTTP 基本认证流程图](http://img.mrsingsing.com/authentication-http-basic-access-authentication.jpg)\n\n1. 用户在浏览器中访问了受限制的网页资源，但是没有提供用户的身份信息\n2. 服务端接收到请求后返回 401 应答码（Unauthorized，未被授权的）要求进行身份验证，并附带提供了一个认证域（Access Authentication）`WWW-Authenticate` 说明如何进行验证的方法，例如 `WWW-Authenticate: Basic realm=\"Secure Area\"`，`Basic` 就是验证的模式，而 `realm=\"Secure Area\"` 则为保护域（告知认证的范围），用于与其他请求 URI 作区别\n3. 浏览器收到应答后，会显示该认证域给用户并提示输入用户名和密码，此时用户可以选择录入信息后确定或取消操作\n4. 用户输入了用户名和密码后，浏览器会在原请求头新增认证消息字段 `Authorization` 并重新发送请求，过程如下：\n\n- 将用户名和密码拼接为 `用户名:密码` 格式的字符串\n- 如果服务器 `WWW-Authenticate` 字段有指定编码，则将字符串编译成对应的编码\n- 将字符串编码为 Base64\n- 拼接 `Basic`，设置为 `Authorization` 字段，假设用户名为 `admin`，密码为 `password`，则拼接后为 `admin:password`，使用 Base64 编码后为 `YWRtaW46cGFzc3dvcmQ=`，那么最终在 HTTP 头部里会是这样：`Authorization: Basic YWRtaW46cGFzc3dvcmQ=`\n\n```js\nBuffer.from('admin:password').toString('base64');\n// YWRtaW46cGFzc3dvcmQ=\n```\n\n5. 服务端接收了该认证后并返回了用户请求的网页资源。如果用户凭证非法或无效，服务器可能会再次返回 401 应答码，客户端就需要再次输入用户名和密码\n\n服务端验证的步骤：\n\n1. 根据用户请求资源的地址，确定资源对应的 `realm`\n2. 解析 Authorization 请求首部，获得用户名和密码\n3. 判断用户是否有访问该 `realm` 的权限\n4. 验证用户名、密码是否匹配\n\n> 当然，也有可能在首次请求中，在请求头附带了认证消息头，那么就不需要再作身份信息的录入步骤\n\n优点：\n\n- 唯一的优点是实现简单，被广泛支持\n\n缺点：\n\n- 由于用户名和密码是以明文的形式在网络中进行传输，容易被嗅探器探测到，所以基本验证方案并不安全\n- 除此之外，Base64 编码并非加密算法，其无法保证安全与隐私，这里仅用于将用户名和密码中的不兼容的字符转换为均与 HTTP 协议兼容的字符集\n- 即使认证内容无法被解码为原始的用户名和密码也是不安全的，恶意用户可以再获取了认证内容后使用其不断的享服务器发起请求，这就是所谓的重放攻击\n- 该方案除了存在安全缺陷外，Basic 认证还存在无法吊销认证的情况\n\n> HTTP 的基本验证方案应与 HTTPS / TLS 协议搭配使用。加入没有这些安全方面的增强，那么基本验证方案不应该被用来保护敏感或者极具价值的信息。\n\n应用场景：内部网络，或者对安全要求不是很高的网络\n\n## Session-Cookie 认证\n\n`Session-Cookie` 认证是利用服务端的 Session（会话）和浏览器（客户端）的 Cookie 来实现的前后端通信认证模式。\n\n由于 HTTP 请求时是无状态的，服务端正常情况下无法得知请求发送者的身份，这个时候我们如果要记录状态，就需要在服务端创建 Session 会话，将相同客户端的请求都维护在各自的会话记录中，每当请求到达服务端时，先校验请求中的用户标识是否存在于 Session 中，如果有则表示已经认证成功，否则表示认证失败。\n\nCookie 主要用于以下三个方面：\n\n- 会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）\n- 个性化设置（如用户自定义设置、主题等）\n- 浏览器行为追踪（如跟踪分析用户行为等）\n\n下图为 Session-Cookie 认证的工作流程图：\n\n![Session-Cookie 认证流程图](http://img.mrsingsing.com/authentication-session-cookie.jpg)\n\n1. 服务端在接收到来自客户端的首次访问时，会自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证 `session_id`（通常称为 `sid`），并在响应头 `Set-Cookie` 中设置这个唯一标识符\n2. 签名，对 `sid` 进行加密处理，服务端会根据这个 `secret` 密钥进行解密（非必需步骤）\n3. 浏览器收到请求响应后会解析响应头，并自动将 `sid` 保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息\n4. 服务端在接收客户端请求时会去解析请求头 Cookie 中的 `sid`，然后根据这个 `sid` 去找服务端保存的该客户端的 `sid`，然后判断该请求是否合法\n5. 一旦用户登出，服务端和浏览器将会同时销毁各自保存的会话 ID，服务端会根据数据库验证会话身份凭证，如果验证通过，则继续处理\n\n> ⚠️ 注意，这里相对于使用服务端，在另一端我使用了 `浏览器` 而非客户端，主要是因为 Cookie 是仅在浏览器中存在的报文字段，诸如移动原生 APP 是无法解析存储 Cookie 请求/响应头的。\n\n优点：\n\n1. Cookie 简单易用，在不受用户干预或过期处理的情况下，Cookie 通常是客户端上持续时间最长的数据保留形式\n2. Session 数据存储在服务端，相较于 JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的 Session 就可以了，方便管理\n\n缺点：\n\n1. 非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被 CSRF 等攻击）\n2. Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能\n3. 用户认证后，服务端做认证记录，如果认证的记录被保存在内存中，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权资源，这样在分布式的应用上，相应的限制了负载均衡的能力，也意味着限制了应用的扩展能力\n\n### koa-session\n\n没有代码谈再多都是空中楼阁，下面尝试在 Koa 中使用 `koa-session2` 中间件实现 Session-Cookie 这种鉴权方式。\n\n在实际项目中，与客户端的会话信息往往需要在服务外再设立额外的外部存储机制，外部存储可以是任何的存储机制，例如内存数据结构，也可以是本地的文件系统，或是使用诸如 Redis 等 NoSQL 数据库。\n\n`koa-session2` 自身实现的存储方式为保存在内存中的，而下面我们就介绍一种拓展 `koa-session2` 结合 Redis 实现 Session-Cookie 认证方式的方案：\n\n```js\nconst Redis = require('ioredis');\nconst { Store } = require('koa-session2');\n\nclass RedisStore extends Store {\n  constructor() {\n    super();\n    // 初始化 Redis\n    this.redis = new Redis();\n  }\n\n  // 根据 sid 获取用户信息\n  async get(sid, ctx) {\n    let data = await this.redis.get(`SESSION: ${sid}`);\n    return JSON.parse(data);\n  }\n\n  // 更新 sid 的用户信息\n  async set(session, { sid = this.getID(24), maxAge = 1000000 } = {}, ctx) {\n    try {\n      await this.redis.set(`SESSION: ${sid}`, JSON.stringfy(session));\n    } catch (e) {}\n\n    return sid;\n  }\n\n  // 销毁会话信息\n  async destroy(sid, ctx) {\n    return await this.redis.del(`SESSION: ${sid}`);\n  }\n}\n\nmodule.exports = RedisStore;\n```\n\n```js\n// app.js\nconst Koa = require('koa');\nconst session = require('koa-session2');\nconst Store = require('./Store.js');\n\nconst app = new Koa();\n\napp.use(\n  session({\n    // 种下 Cookie 的键名\n    key: 'SESSIONID',\n    // 禁止浏览器中 JS 脚本修改 Cookie\n    httpOnly: true,\n    // Cookie 加密签名机制\n    signed: true,\n    store: new Store(),\n  })\n);\n\napp.use(ctx => {\n  // Ignore favicon.ico\n  if (ctx.path === '/favicon.ico') return;\n\n  let user = this.session.user;\n\n  ctx.session.view = 'index';\n});\n\napp.use(ctx => {\n  // 如果设置了会话有效期刷新会话有效期\n  ctx.session.refresh();\n});\n```\n\n在 `koa-session` 中会话标识的实现仅是根据时间戳生成的随机字符串，如果担心 Cookie 传输中被恶意篡改或暴露信息，可以通过加入更多标识元素，例如 IP 地址、设备 ID 等。\n\nKoa 的 Cookie 实现默认带了安全机制，就是 `signed` 选项为 `true` 时，会自动给 Cookie 添加一个 SHA256 的签名，类似 `koa:sess=pjadZtLAVtiO6-Haw1vnZZWrRm8`，从而防止 Cookie 被篡改。\n\n至于担心的 Session 信息泄漏问题，`koa-session` 允许用户自定义编解码方法，例如：\n\n```js\nconst encode = json => CrytoJS.AES.encrypt(json, 'Secret Passphrase');\n\nconst decode = encrypted => CryptoJS.AES.decrypt(encrypted, 'Secret Passphrase');\n```\n\n`koa-session` 为 Koa 官方实现的中间件，功能强大，考虑的情况比较多，所以实现相对复杂。\n\n而 `koa-session2` 是社区实现的中间件，简洁易用。如果对实现有兴趣的同学可以在 Github 找到源码阅读。\n\n- [koa-session](https://github.com/koajs/session)\n- [koa-session2](https://github.com/Secbone/koa-session2)\n- [koa-session 学习笔记](https://segmentfault.com/a/1190000013039187)\n- [koa-session 的内部实现](https://www.jianshu.com/p/c1eff1b50d23)\n- [从 koa-session 源码解读 session 原理](https://juejin.im/post/5c148fd551882530544f341f)\n- [从 koa-session 中间件源码学习 cookie 与 session](https://segmentfault.com/a/1190000012412299)\n\n## Token 认证\n\n随着 Restful API、微服务的兴起，基于 Token 的认证现在已经越来越普遍。Token 和 Session-Cookie 认证方式中的 Session ID 不同，并非只是一个标识符。Token 一般会包含 `用户的相关信息`，通过验证 Token 不仅可以完成身份校验，还可以获取预设的信息。像 Twitter、微信、QQ、Github 等公有 API 都是基于这种方式进行认证的，一些开发框架如 OpenStack、Kubernetes 内部 API 调用也是基于 Token 的认证。\n\n![Token 认证流程图](http://img.mrsingsing.com/authentication-token-authencation.jpg)\n\n基于 Token 的身份验证方法：\n\n1. 用户输入登录信息并请求登录\n2. 服务端收到请求，验证用户输入的登录信息\n3. 验证成功后，服务端会 `签发`一个 Token（通常包含用户基础信息、权限范围和有效时间等），并把这个 Token 返回给客户端\n4. 客户端收到 Token 后需要把它存储起来，比如放在 localStorage 或 sessionStorage 里（一般不放 Cookie 因为可能会有跨域问题，以及安全性问题）\n5. 后续客户端每次向服务端请求资源的时候，将 Token 附带于 HTTP 请求头 Authorization 字段中发送请求\n6. 服务端收到请求后，去校验客户端请求中 Token，如果验证成功，就向客户端返回请求的数据，否则拒绝返还\n\n优点：\n\n- **服务端无状态**：Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态\n- **性能相对较好**：因为在验证 Token 时不用再去访问数据库或远程服务进行权限校验，自然可以提升不少性能\n- 支持移动设备\n- 支持跨域跨程序调用，因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题\n- 有效避免 CSRF 攻击（因为不需要 Cookie），但是会存在 XSS 攻击中被盗的风险，但是可选择 Token 存储在标记为 `httpOnly` 的 Cookie 中，能够有效避免浏览器中的 JS 脚本对 Cookie 的修改\n\n缺点：\n\n- 占带宽：正常情况下比 `sid` 更大，消耗更多流量，挤占更多宽带\n- 性能问题：相比较于 Session-Cookie 认证来说，Token 需要服务端花费更多时间和性能来对 Token 进行解密验证，其实 Token 相较于 Session—Cookie 来说就是一个时间换空间的方案\n\n> Session-Cookie 认证和 Token 认证的比较\n\nSession-Cookie 认证和 Token 认证有很多类似的地方，但是 Token 认证更像是 Session-Cookie 认证的升级改良版。\n\nSession-Cookie 认证仅仅靠的是 `sid` 这个生成的唯一标识符，服务端需要根据客户端传来的 `sid` 查询保存在服务端 Session 里保存的登录状态，当存储的信息数据量超过一定量时会影响服务端的处理效能。而且 Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的。\n\n而 Token 认证机制特别的是，实质上登录状态是用户登录后存放在客户端的，服务端不会充当保存 `用户信息凭证` 的角色，当每次客户端请求时附带该凭证，只要服务端根据定义的规则校验是否匹配和合法即可，客户端存储的手段也不限于 Cookie，可以使用 Web Storage 等其他缓存方式。简单来说，Session-Cookie 机制限制了客户端的类型，而 Token 验证机制丰富了客户端类型。\n\n除此之外，Token 验证比较灵活，除了常见的 JWT 外，可以基于 Token 构建专门用于鉴权的微服务，用它向多个服务的请求进行统一鉴权。\n\n### JWT 认证\n\nJWT（JSON Web Token）是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登录成功后将相关信息组成 JSON 对象，然后对这个对象进行某种方式的加密，返回给客户端，客户端在下次请求时带上这个 Token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。\n\nJWT 是 JSON 格式的被加密了的字符串：\n\n```\nJSON Data + Signature = JWT\n```\n\nJWT 对象通常由三部分组成：\n\n1. 头部（Headers）：包括类别（typ）、加密算法（alg）\n\n头部用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等。\n\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n这里我们说明了这是一个 JWT，并且我们所使用的签名算法是 HS256 算法。\n\n2. Claims：包括需要传递的用户信息\n\n载荷可以用来存放一些不敏感的信息\n\n```json\n{\n  \"iss\": \"Jehoshaphat Tse\",\n  \"iat\": 1441593502,\n  \"exp\": 1441594722,\n  \"aud\": \"www.example.com\",\n  \"sub\": \"mrsingsing@example.com\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\n这里面的前五个字段都是由 JWT 的标准所定义的:\n\n- `iss`：该 JWT 的签发者\n- `sub`：该 JWT 所面向的用户\n- `aud`：接收该 JWT 的一方\n- `exp`（expires）：什么时候过期，这是 Unix 时间戳\n- `iat`（issued at）：在什么时候签发的。把头部和载荷分别进行 Base64 编码后得到两个字符串，然后再将这两个编码后的字符串用英文句号连接起来（头部在前），形成新的字符\n\n3. Signature：\n\n最后，将上述拼接后的字符串，用 `alg` 指定的算法（HS256）与私有密钥（Secret）进行加密。加密后的内容也是字符串，最后这个字符串就是签名，把这个签名拼接在刚才的字符串后面就能得到完整的 JWT。Header 部分和 Claims 部分如果被篡改，由于篡改者不知道密钥是什么，也无法生成新的 Signature 部分，服务端也就无法通过，在 JWT 中，消息体是透明的，使用签名可以保证消息不被篡改。\n\n```js\nHMACSHA256(base64UrlEncode(Headers) + '.' + base64UrlEncode(Claims), SECREATE_KEY);\n```\n\n优点：\n\n1. 不需要在服务端保存会话信息（RESTful API 的原则之一就是无状态），所以易于应用的扩展，即信息不保存在服务端，不会存在 Session 扩展不方便的情况\n2. JWT 中的载荷可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数\n\n缺点：\n\n1. **过期时间问题**：由于服务端不保存 Session 状态，因此无法在使用过程中废止某个 Token，或是更改 Token 的权限。也就是说，一旦 JWT 签发，在到期之前就会始终有效，除非服务端部署额外的逻辑。因此如果是浏览器端应用的话，使用 JWT 认证机制还需要设计一套 JWT 的主动更新删除的机制，这样就增加了系统的复杂性。\n2. **安全性**：由于 JWT 的 Claims 是 Base64 编码的，并没有加密，因此 JWT 中不能存储敏感数据\n3. **性能问题**：JWT 占用空间过大，Cookie 限制一般是 4k，可能会无法容纳，所以 JWT 一般放 LocalStorage 里面，并且用户在系统的每次 HTTP 请求都会把 JWT 携带在 Header 里面，HTTP 请求的 Header 可能比 Body 还要大。\n\n### koa-jwt\n\n下面介绍 Koa 中使用 `koa-jwt` 进行颁发、校验 Token 的使用方法。\n\n服务端生成 Token\n\n```js\nconst router = require('koa-router')();\nconst jwt = require('koa-jwt');\n// 这里使用的是 MongoDB 数据库\nconst userModel = require('../model/userModel');\n\nconst secretOrPublicKey = 'TOKEN_EXAMPLE';\n\nrouter.post('/login', async ctx => {\n  const data = ctx.request.body;\n\n  // 根据用户提供的用户名和密码查询数据库中是否存在对应的用户信息\n  const userInfo = await userModel.findOne({ name: data.name, password: data.password });\n\n  let result = null;\n  if (userInfo !== null) {\n    // 根据用户信息签发 Token，设定有效时间为 2h\n    const token = jwt.sign({ name: userInfo.name, _id: userInfo._id }, secretOrPublicKey, {\n      expiresIn: '2h',\n    });\n\n    result = {\n      code: 200,\n      token: token,\n      msg: '登录成功',\n    };\n  } else {\n    result = {\n      code: 400,\n      token: null,\n      msg: '登录失败',\n    };\n  }\n\n  return (ctx.body = result);\n});\n```\n\n前端获取 Token：\n\n```js\n// 请求登录\nfunction login(userName, password) {\n  return axios\n    .post('/login', {\n      name: userName,\n      password: password,\n    })\n    .then(res => {\n      if (res.code === 200) {\n        localStorage.setItem('access_token', res.data.token);\n      } else {\n        console.log('登录失败');\n      }\n    })\n    .catch(e => console.error(e));\n}\n\n// 后续获取 Token 后续的 API 请求\n// 通过 Axios 拦截器加上 Authorization 请求头部字段\naxios.interceptors.request.use(config => {\n  const token = localStorage.getItem('token');\n\n  config.headers.common['Authorization'] = 'Bearer ' + token;\n\n  return config;\n});\n```\n\n服务端校验前端发送来的请求：\n\n```js\nconst koa = require('koa');\nconst jwt = require('koa-jwt');\nconst app = new Koa();\nconst secretOrPublicKey = 'TOKEN_EXAMPLE';\n\napp\n  .use(\n    jwt({\n      secret: secretOrPublicKey,\n    })\n  )\n  .unless({\n    path: [/\\register/, /\\/login/],\n  });\n```\n\n在 `koa-jwt` 的源码实现中，我们可以知道 Token 的鉴定是先判断请求头中是否带了 Authorization：\n\n- 有，则通过正则将 `token` 从 Authorization 中分离出来，Token 中是带有 Bearer 这个单词\n- 没有，则代表了客户端没有传 Token 到服务器，这时候就抛出 401 错误状态\n\n源码文件中的 `verify.js` 中，调用了 `jsonwebtoken` 库原生提供的 `verify()` 方法进行验证返回结果。\n\n[jsonwebtoken](https://github.com/auth0/node-jsonwebtoken) 的 `sign()` 用于生成 `token`，而 `verify()` 方法当然则是用来解析 `token`。属于 JWT 配对生产的两个方法，所以 `koa-jwt` 这个中间件也没做什么事，无非就是用正则解析请求头，调用 `jsonwebtoken` 的 `verify()` 验证 `token`，在 `koa-jwt` 文件夹的 `index.js` 中，`koa-jwt` 还调用 `koa-unless` 进行路由权限分发。\n\n- [Koa2 服务端使用 JWT 进行鉴权及路由权限分发的流程分析](http://www.uxys.com/html/JavaScript/20190722/52733.html)\n\n### Token 认证常见问题及解决方案\n\n#### 注销登录\n\n注销登录等场景下 Token 仍有效类似的场景：\n\n- 退出登录\n- 修改密码\n- 服务端修改了某个用户具有的权限或角色\n- 用户的账户被删除/暂停\n- 用户由管理员注销\n\n这个问题仅存在于 Token 认证中，因为 Session-Cookie 认证模式中，这些情况能够通过删除服务端 Session 中对应的记录解决，而 Token 认证中，如果服务端不增加其他逻辑的话，在失效前 Token 都是有效的。\n\n下面列出几种针对这些场景的解决方案：\n\n- **将 Token 存储在内存数据库**：将 Token 存入类似于 Redis 的内存数据库中。如果需要让某个 Token 失效就直接从 Redis 中删除这个 Token 即可。但是这样会导致每次使用 Token 发送请求都要先从 DB 中查询 Token 是否存在的步骤，而且违背了 JWT 无状态原则。\n- **黑名单机制**：和上述方案类似，使用内存数据库维护一份黑名单，如果想让某个 Token 失效的话就直接将这个 Token 放入到黑名单内即可。每次使用 Token 进行请求时都会先判断 Token 是否存在于黑名单中。\n- **修改密钥 Secret**：为每个用户创建专属密钥，如果想让某个 Token 失效，我们直接修改对应用户的密钥即可。但是，这样相较于前两种引入内存数据带入的危害更大：\n  - 如果服务是分布式的，每次发出新的 Token 时都必须在多台及其同步密钥。为此，你需要将机密存在数据库或其他外部服务中，这样和 Session 认证就没有太大区别了\n  - 如果用户同时在两个浏览器打开系统，或者在移动设备上打开系统，当它从一个地方将账号退出时，那么其他终端都需要重新登录认证，这是不可取的\n- **保持令牌的有效期限短并经常轮换**\n  - 很简单的方式，但是会导致用户登录状态不会被持久记录，而且需要用户经常登录\n\n#### 续签问题\n\nToken 的续签问题：\n\nToken 有效期一般不建议设置过长，而 Token 过期后如何认证，如何 `动态刷新` Token 等需要有效的方案解决。\n\n在 Session-Cookie 认证中，假设 Session 有效期为 30 分钟，如果 30 分钟内有资源请求访问，那么就把 Session 的有效期自动延长 30 分钟。\n\n- **类似于 Session 人中的做法**：当客户端访问服务端，发现 Token 即将过期时，服务端重新颁发新的 Token 给客户端\n- **每次请求都返回新 Token**：实现思路简单明了，但是开销较大\n- **Token 有效期设置到半夜**：折衷方案，保证大部分用户正常工作时间可以正常登录，适用于安全性要求不高的系统\n- **用户登录返回两个 Token**：第一个是 `accessToken`，它的过期时间设置比如半个小时，另一个是 `refreshToken`，它的过期时间更长一点，例如 1 天。客户端登录后，将 `accessToken` 和 `refreshToken` 保存在本地，每次访问将 `accessToken` 传给服务端。服务端校验 `accessToken` 的有效性，如果过期的话，就将 `refreshToken` 传给服务端。如果有效，服务端就生成新的 `accessToken` 给客户端。否则，客户端就重新登录即可。该方案不足的是：\n  - 需要客户端配合\n  - 用户注销的时候需要同时保证两个 Token 都无效\n  - 重新请求获取 Token 的过程中会有短暂 Token 不可用的情况（可以通过在客户端设置定时器，当 `accessToken` 快过期的时候，提前去通过 `refreshToken` 获取新的 `accessToken`）\n\nJWT 最适合的场景是不需要服务端保存用户状态的场景，如果考虑到 Token 注销和续签等场景的话，目前来说没有特别好的解决方案，大部分解决方案都给 Token 加上状态，这实际上就有点类似 Session-Cookie 认证了。\n\n## 单点登录\n\n**单点登录**（Single Sign-on）又称 SSO，是指在多系统应用群中登录单个系统，便可在其他所有系统中得到授权而无需再次登录。\n\n传统的 All-in-one 型应用的认证系统和业务系统集合在一起的，当用户认证通过时，将用户信息存入 Session 中。其他业务只需要从业务中通过对应会话身份凭证取到用户信息进行相关业务处理即可。\n\n传统的 Session 是将用户信息存入内存，维护一个哈希表。每次请求携带会话身份凭证 SessionID（Tomcat 中是 `JSESSIONID`）到服务端，根据此 SessionID 查找到对应的用户信息。\n\n利用 Redis 等内存数据库进行用户信息的存储，自定义 Token 生成规则将用户信息写入 Redis 中。这样将用户信息的存储和业务系统进行拆分，使系统更加健壮，更易于扩展。新增系统只需要从 SSO 中获取相关的认证即可进行横向的业务扩展。而且 Redis 本身的性质也易于进行 `集群化` 的部署。\n\n下面详述各种场景下 SSO 的实现方案。\n\n### 同域 SSO\n\n当存在两个相同域名下的系统 A `a.abc.com` 和系统 B `b.abc.com` 时，以下为他们实现 SSO 的步骤：\n\n1. 用户访问某个子系统时（例如 `a.abc.com`），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录\n2. 登录认证后，服务端把登录用户的信息存储于 Session 中，并为用户生成对应的会话身份凭证附加在响应头的 `Set-Cookie` 字段中，随着请求返回写入浏览器中，并回跳到设定的子系统链接中\n3. 下次发送请求时，当用户访问同域名的系统 B 时，由于 A 和 B 在相同域名下，也是 `abc.com`，浏览器会自动带上之前的 Cookie。此时服务端就可以通过该 Cookie 来验证登录状态了。\n\n这实际上使用的就是 Session-Cookie 认证的登录方式。\n\n### 跨域 SSO\n\n上述所提及的同域名 SSO 并不支持跨域名的登录认证，这显然不符合当今互联网发展潮流，毕竟大多数中大型企业内外部的系统都是部署在不同的域名下，下面我们介绍实现单点登录的标准流程。\n\n**CAS**（Central Authentication Service）中央授权服务，本身是一个开源协议，分为 1.0 版本和 2.0 版本。1.0 称为基础模式，2.0 称为代理模式，适用于存在非 Web 应用之间的单点登录。\n\nCAS 的实现需要三方角色：\n\n- Client：用户\n- Server：中央授权服务，也是 SSO 中心负责单点登录的服务器\n- Service：需要使用单点登录鉴权的各个业务服务，相当于上文中的系统 A / B\n\nCAS 的实现需要提供以下四个接口：\n\n- `/login`：登录接口，用于登录到中央授权服务\n- `/logout`：登出接口，用于从中央授权服务中登出\n- `/validate`：用于验证用户是否登录中央授权服务\n- `/serviceValidate`：用于让各个 Service 验证用户是否登录中央授权服务\n\nCAS 票据：\n\n- **TGT（Ticket Grangting Ticket）**：TGT 是 CAS 为用户签发的 `登录票据`，拥有了 TGT，用户就可以证明自己在 CAS 成功登录过。TGT 封装了 Cookie 值以及此 Cookie 值对应的用户信息。当 HTTP 请求到来时，CAS 以此 Cookie 值（TGC）为 `key` 查询缓存中是否有 TGT，如果有，则表示用户已登录过。\n- **TGC（Ticket Granting Cookie）**：CAS Service 生成 TGC 放入自己的 Session 中，而 TGC 就是这个 Session 的唯一标识（SessionID），以 Cookie 形式放到浏览器端，是 CAS Service 用来明确用户身份的凭证\n- **ST（Service Ticket）**：ST 是 CAS 为用户签发的访问某个 Service 的票据。用户访问 Service 时，Service 发现用户没有 ST，则要求用户去 CAS 获取 ST。用户向 CAS 发出 ST 的请求，CAS 发现用户有 TGT，则签发一个 ST，返回给用户。用户拿着 ST 去访问 Service，Service 拿 ST 去 CAS 验证，验证通过后，允许用户访问资源。\n\n这里可能概念太多会非常难理解，简单说明下，客户端需要各自维护与不同系统的登录状态，包括与中央授权服务的登录状态。所以，实际上 TGC 和 TGT 是维护客户端与中央授权服务登录状态的会话身份凭证的 `key-value` 键名值，而 ST 票据则是资源服务向中央授权服务获取用户登录状态、信息的交换凭证，只不过资源服务需要经用户的“手”上才能获取到该票据。\n\n详细步骤：\n\n![CAS 验证流程时序图](http://img.mrsingsing.com/authentication-cas-workflow.png)\n\n1. 用户访问系统 A 的受保护资源（域名是 `a.abc.com`），系统 A 检测出用户处于 `未登录` 状态，重定向（应答码 302）至 SSO 服务认证中心的登录接口，同时地址参数携带登录成功后回跳到系统 A 的页面链接（跳转的链接形如 `sso.abc.com/login?service=https%3A%2F%2Fwww.a.abc.com`）\n2. 由于请求没有携带 SSO 服务器上登录的票据凭证（TGC），所以 SSO 认证中心判定用户处于 `未登录` 状态，重定向用户页面至 SSO 的登录界面，用户在 SSO 的登录页面上进行登录操作。\n3. SSO 认证中心校验用户身份，创建用户与 SSO 认证中心之间的会话，称为 `全局会话`，同时创建 `授权令牌`（ST），SSO 带着授权令牌跳转回最初的系统 A 的请求地址：\n\n- 重定向地址为之前写在 `query` 中的系统 A 的页面地址\n- 重定向地址的 `query` 中包含 SSO 服务器派发的 ST\n- 重定向的 HTTP 响应中包含写 Cookie 的 Header。这个 Cookie 代表用户在 SSO 中的登录状态，它的值就是 TGC\n\n5. 浏览器重定向至系统 A 服务地址，此时重定向的 URL 中携带着 SSO 服务器生成的 ST\n6. 系统 A 拿着 ST 向 SSO 服务器发送请求，SSO 服务器验证票据的有效性。验证成功后，系统 A 知道用户已经在 SSO 登录了，于是系统 A 服务器使用该令牌创建与用户的会话，称为 `局部会话`，返回受保护网页资源\n7. 之后用户访问系统 B 受保护资源（域名 `b.abc.com`），系统 B 检测出用户处于 `未登录` 状态，跳转至 SSO 服务认证中心，同时地址参数携带授权令牌 ST（每次生成的 ST 都是不一样的）登录成功后回跳的链接\n8. SSO 认证中心发现用户已登录，跳转回系统 B 的地址，并附上令牌\n9. 系统 B 拿到令牌，去 SSO 认证中心校验令牌是否有效，SSO 认证中心校验令牌，返回有效，注册系统 B\n10. 系统 B 使用该令牌创建与用户的局部会话，返回受保护资源\n\n至此整个登录流程结束，而在实际开发中，基本上都会根据 CAS 增加更多的判断逻辑，比如，在收到 CAS Server 签发的 ST 后，如果 ST 被 Hacker 窃取，并且 Client 本身没来得及去验证 ST，被 Hacker 抢先一步验证 ST，怎么解决。此时就可以在申请 ST 时添加额外验证因子（如 IP、SessionID 等）。\n\n### LDAP 认证登录\n\nLDAP 的全称是 Lightweight Directory Access Protocol，即**轻量目录访问协议**，是一个开放、广泛被使用的工业标准（IEFT、RFC）。企业级软件也通常具备 \\*_支持 LDAP_- 的功能，比如 Jira、Confluence、OpenVPN 等，企业也经常采用 LDAP 服务器来作为企业的认证源和数据源。但是大家比较常见的误区是，可以使用 LDAP 来实现 SSO。我们可以先分析以下它的主要功能点或场景。\n\n- 作为数据源它可以用于存储\n  - 企业的组织架构树\n  - 企业员工信息\n  - 证书信息\n  - 会议室，打印机等等资源\n- 作为认证源，它也有多种用途\n  - 存储用户的密码\n  - 对外提供 LDAP 协议的认证方式（通过 LDAP BIND 协议来校验用户名和密码）\n  - 密码策略（密码复杂度，历史密码记录，用户锁定等等）\n\n## 信任登录\n\n信任登录是指所有不需要用户主动参与的登录，例如建立在私有设备与用户之间的绑定关系，凭证就是私有设备的信息，此时不需要用户再提供额外的凭证。信任登录又指用第三方比较成熟的用户库来校验凭证，并登录当前访问的网站。\n\n1. 登录服务 \\*_信任业务系统_- 的凭证校验结果\n2. 登录服务 \\*_信任第三方登录系统_- 的凭证校验结果，前提是必须又本站点的账号体系下的账号与第三方账号的一对一绑定关系，现在流行的授权方式也属于这个模式。\n\n目前比较常见的第三方信任登录帐号如：QQ 号淘宝帐号、支付宝帐号、微博帐号等。\n\n信任登录的好处是可以利用第三方庞大的用户群来推广、营销网站，同时减少用户的注册、登录时间。\n\n提到信任登录，我们就不得不提到 OAuth，正是有了 OAuth，我们的信任登录才得以实现。下面我们就来看下关于 OAuth 的一些介绍。\n\n## OAuth2 开发授权\n\nOAuth（开放授权）是一个开发标准，允许用户授权 `第三方网站` 访问他们存储在另外的服务提供商中的信息，而不需要接触到用户名和密码。为了保护数据的安全和隐私，第三方网站访问用户数据前都需要 `显式地向用户征求授权`。我们常见的 OAuth 认证服务的厂商有微信、QQ、支付宝等。\n\nOAuth 协议又有 1.0 和 2.0 两个版本，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。\n\n应用场景有：第三方应用的接入、微服务鉴权互信、接入第三方平台、第一方密码登录等。\n\n授权模式：\n\n- 授权码模式（Authorization Code Grant）\n- 隐式授权模式（Implicit Grant）\n- 密码模式（Resource Owner Password Credentials Grant）\n- 客户端模式（Client Credentials Grant）\n\n无论哪种授权模式，都必须拥有四种必要的角色参与：`客户端`、`授权服务器`、`资源服务器`，有的还有 `用户（资源拥有者）`。我们以微信开发平台的授权登录为例解释这四种角色：\n\n- 资源拥有者（Resource Owner）：这里指微信用户\n- 第三方应用（Third-party Application）：指内嵌在微信应用内的第三方应用，形式不限于 Web App、公众号 Web 网页、小程序等等\n- 授权服务器（Authorization Server）：这里指微信开发平台的授权服务\n- 资源服务器（Resource Server）：用于存储、获取用户资源，这里指的是微信开放平台的服务器\n\n### 授权码模式\n\n授权码模式是 OAuth 2.0 目前最安全最复杂的授权流程。\n\n![授权码模式](http://img.mrsingsing.com/authentication-authorization-code-grant.jpg)\n\n授权码模式的授权流程可以分为三个部分：\n\n1. Client Side：用户+客户端与授权服务端的交互\n2. Server Side：客户端与授权服务端之间的交互\n3. Check Access Token'：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互\n\n整个流程就是：客户端换取授权码，客户端使用授权码换取 Token，客户端使用 Token 访问资源\n\n> 前提条件：\n>\n> - 第三方客户端需要提前与资源拥有方（同时也是授权所有方）协商客户端 ID（client_id）以及客户端密钥（client_secret）\n> - 上述流程暂未将 `scope`、`state` 等依赖具体框架的内容写进来，这里可以参考 Spring Security OAuth2 的实现\n\n**Client Server 客户端换取授权码**\n\n这个客户端可以是浏览器\n\n1. 客户端将 `client_id + client_secret + 授权模式标识（grant_type）+ 回调地址（redirect_uri）` 拼接成 URL 访问授权服务器\n2. 授权服务端返回登录界面，要求 `用户登录`（此时用户提交的账号密码等直接发送到授权服务端，进行校验）\n3. 授权服务端返回授权审批界面，`用户授权` 完成\n4. 授权服务端 `返回授权码到回调地址`\n\n**Server Side 客户端使用授权码换取 Token**\n\n1. 客户端接收到授权码，并使用 `授权码 + client_id + client_secret` 访问授权服务端颁发 Token 令牌\n2. 授权服务端校验通过，颁发 Token 返回给客户端\n3. 客户端保存 Token 到存储器\n\n**Check Access Token 客户端使用 Token 访问资源**\n\n1. 客户端在请求头带上 Token，访问资源服务端\n2. 资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）\n3. 资源服务端校验成功，返回资源\n\n移动应用微信登录是基于 OAuth2.0 协议标准构建的微信 OAuth2.0 授权登录系统，在微信开放平台注册开发者账号，并拥有已审核通过的移动应用，并获得相应的 AppID 和 AppSecret，申请微信登录且通过审核后，可开始接入流程。\n\n```\n1. 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据 code 参数\n2. 通过 code 参数加上 AppId 和 AppSecret 等，通过 API 换取 access_token\n3. 通过 access_token 进行接口调用，获取用户基本数据资源或帮助用户实现基本操作\n```\n\n![微信 OAuth2.0 获取 access_token 时序图](http://img.mrsingsing.com/authentication-wx-oauth2-access-token.png)\n\n详情可以参阅 [微信登录功能 - 移动应用微信登录开发指南](https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html)，这里的实现就是授权码模式。\n\n### 隐式授权模式\n\n![隐式授权模式流程图](http://img.mrsingsing.com/authentication-implicit-grant.jpg)\n\n隐式授权模式大致可以分为两部分：\n\n1. Client Side：用户+客户端与授权服务端的交互\n2. Check Access Token：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互\n\n整个流程就是：客户端让用户登录授权服务端换取 Token，客户端使用 Token 访问资源\n\n**Client Side 客户端让用户登录授权服务端换 Token**\n\n1. 客户端（浏览器或单页应用）将 `client_id + 授权模式标识（grant_type）+ 回调地址（redirect_url）` 拼成 URL 访问授权服务端\n2. 授权服务端跳转用户登录界面，用户登录\n3. 用户授权\n4. 授权服务端 `访问回调地址` 返回 Token 给客户端\n\n**Check Access Token 客户端使用 Token 访问资源**\n\n1. 客户端在请求头附带 Token 访问资源服务端\n2. 资源服务端收到请求，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）\n3. 资源服务端校验成功，返回资源\n\n### 密码模式\n\n![密码模式流程图](http://img.mrsingsing.com/authentication-resource-owner-password-credentials-grant.jpg)\n\n密码模式的授权流程可以分为两部分：\n\n1. Client Side：用户与客户端的交互，客户端与授权服务端的交互\n2. Check Access Token'：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互\n\n整个流程就是：用户在客户端提交账号密码换取 Token，客户端使用 Token 访问资源\n\n**Client Server 用户在客户端提交账号密码换取 Token**\n\n1. 客户端要求用户登录\n2. 用户输入密码，客户端将表单中添加客户端的 `client_id + client_secret` 发送给授权服务端颁发 Token 令牌\n3. 授权服务端校验用户名、用户密码、`client_id` 和 `client_secret`，均通过后返回 Token 给客户端\n4. 客户端保存 Token\n\n**Check Access Token 客户端使用 Token 访问资源**\n\n1. 客户端在请求头带上 Token，访问资源服务端\n2. 资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）\n3. 资源服务端校验成功，返回资源\n\n### 客户端模式\n\n![客户端模式流程图](http://img.mrsingsing.com/authentication-client-credentials-grant.jpg)\n\n客户端模式的授权流程可以分为两部分：\n\n1. Server Side：客户端与授权服务端之间的交互\n2. Check Access Token'：客户端与资源服务端，资源服务端与授权服务端之间的交互\n\n整个流程就是：客户端使用自己的标识换取 Token，客户端使用 Token 访问资源\n\n**Client Server 客户端使用自己的标识换取 Token**\n\n1. 客户端使用 `client_id + client_secret + 授权模式标识` 发送给授权服务端颁发 Token 令牌\n2. 授权服务端校验通过后返回 Token 给客户端\n3. 客户端保存 Token\n\n**Check Access Token 客户端使用 Token 访问资源**\n\n1. 客户端在请求头带上 Token，访问资源服务端\n2. 资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）\n3. 资源服务端校验成功，返回资源\n\n### 授权模式选型\n\n考虑到授权场景的多样性，可以参考以下两种选型方式：\n\n- 按授权需要的多端情况\n- 按客户端类型与所有者\n\n按授权需要的多端情况：\n\n| 模式                              | 需要前端 | 需要后端 | 需要用户响应 | 需要客户端密钥 |\n| :-------------------------------- | :------- | :------- | :----------- | :------------- |\n| 授权码模式 Authorization Code     | ✓        | ✓        | ✓            | ✓              |\n| 隐式授权模式 Implicit Grant       | ✓        | ✗        | ✓            | ✗              |\n| 密码授权模式 Password Grant       | ✓        | ✓        | ✓            | ✓              |\n| 客户端授权模式 Client Credentials | ✗        | ✓        | ✗            | ✓              |\n\n按照客户端类型与访问令牌所有者分类：\n\n![OAuth2.0 模式选型](http://img.mrsingsing.com/authentication-oauth2-mode-selection.jpg)\n\n## 联合登录\n\n联合登录指同时包含多种凭证校验的登录服务，同时，也可以理解为使用第三方凭证进行校验的登录服务。这个概念有点像 OAuth2.0 的认证方式。\n\n最经典的莫过于 APP 内嵌 H5 的使用场景，当用户从 APP 进入内嵌的 H5 时，我们希望 APP 内已登录的用户能够访问到 H5 内受限的资源，而未登录的用户则需要登录后访问。\n\n这里思路主要有两种，一种是原生跳转内嵌 H5 页面时，将登录态 Token 附加在 URL 参数上，另一种则是内嵌 H5 主动通过与原生客户端制定的协议获取应用内的登录状态。\n\n## 扫码登录\n\n二维码也称为二维条码，是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。一维条码的宽度记载着数据，而其长度没有记载数据。二维码的长度、宽度均记载着数据。二维码有一维条码没有的 **定位点\\*- 和 **容错机制\\*\\*。容错机制在即使没有识别到全部的条码、或是说条码有污损时，也可以正确地还原条码上的信息。\n\n扫码登录通常见于移动端 APP 中，基本操作流程是让已登录用户主动扫描二维码，以使 PC 端的同款应用得以快速登录的方式，常见的具备扫码登录的应用有微信、钉钉、支付宝等。\n\n![扫码登录流程图](http://img.mrsingsing.com/authentication-scan-qrcode-login-workflow.jpg)\n\n扫码登录可以分为三个阶段：待扫码、已扫码待确认和已确认。\n\n### 待扫码阶段\n\n**待扫码阶段**即上述流程图中 1~5 的阶段，亦即生成二维码阶段，这个阶段与移动端没有关系，主要是 PC 端与服务端进行交互的过程。\n\n首先 PC 端携带设备信息向服务端发起了生成二维码请求，服务端接收到请求后生成 `UUID` 作为二维码 ID，并将 UUID 与 `PC 端的设备信息` 关联起来存储在 Redis 服务器中，然后返回给 PC 端。\n\n当 PC 端收到二维码 ID 之后，将二维码 ID 以 `二维码的形式` 展示，等待移动端扫码。此时 PC 端开始轮询查询二维码状态，直到登录成功。当然除了使用轮询查询，也能使用 WebSocket 实现查询/推送二维码状态的需求。如果移动端未扫描，那么一段时间后二维码会自动失效。\n\n### 已扫码待确认阶段\n\n**已扫码待确认阶段**亦即流程图中的 6~10 的阶段，在 PC 端登录微信时，手机扫码后，PC 端的二维码会显示为已扫码，并提示需要在手机上确认，这个阶段是移动端与服务端交互的过程。\n\n移动端扫描二维码后，会自动获取到二维码 ID，并将移动端登录的信息凭证（Token）和二维码 ID 作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。\n\n服务端接受请求后，会将 `Token 与二维码 ID` 关联，为什么需要关联呢？因为，当我们在使用微信时，移动端退出时，PC 端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个一次性 Token，这个 Token 会返回给移动端，一次性 Token 用作确认时的凭证。\n\nPC 端轮询到二维码的状态已经发生变化，会将 PC 端的二维码更新为已扫描，请确认。\n\n### 已确认阶段\n\n**已确认阶段**为流程图中的步骤 11~15，这是扫码登录的最后阶段，用户确认登录，移动端携带上一步中获取的 `临时 Token` 发送给服务端校验。服务端校验完成后，会更新二维码状态，并且给 PC 端生成一个 `正式的 Token`，后续 PC 端就是持有这个 Token 访问服务端。\n\nPC 端的定时器，轮询到二维码状态为已登录状态，并且会获取到了生成的 Token，完成登录，后续访问都基于 Token 完成。\n\n在服务端会跟移动端一样，维护着 Token 跟二维码、PC 设备信息、账号等信息。\n\n## 一键登录\n\n最传统的登录方式莫过于提供账号密码校验，但这毫无疑问需要消耗用户的记忆成本。随着无线互联的发展以及手机卡实名制的推广，手机号俨然已成为特别的身份证明，与账号密码相比，手机号可以更好地验证用户的身份，防止恶意注册。\n\n但是手机号注册还是需要一系列繁琐的操作：输入手机号、等待短信验证码、输入验证码、点击登录。整个流程少说二十秒，而且如果收不到短信，也就登录补了，这类问题有可能导致潜在的用户流失。\n\n短信验证码的作用就是证明当前操作页面的用户与输入手机号的用户为相同的人，那么实际上只要我们能够获取到当前手机的手机号并与输入的手机号对比匹配后便能达到校验的功能。但是，无论是原生 APP 还是 H5 网页都是不具备直接获取用户手机号的功能的，而这种需求运营商能够通过手机 SIM 卡的流量数据查询。随着运营商开放了相关的服务，我们能够接入运营商提供的 SDK 并付费使用相关的服务。\n\n下图为一键登录的流程图：\n\n![一键登录流程图](http://img.mrsingsing.com/authentication-one-click-login-workflow.png)\n\n主要步骤：\n\n1. SDK 初始化：调用 SDK 方法，传入平台配置的 AppKey 和 AppSecret\n2. 唤起授权页：调用 SDK 唤起授权接口，SDK 会先向运营商发起获取手机号掩码的请求，请求成功后跳到授权页。授权页会显示手机号掩码以及运营商协议给用户确认。\n3. 同意授权并登录：用户同意相关协议，点击授权页面的登录按钮，SDK 会请求本次取号的 Token，请求成功后将 Token 返回给客户端\n4. 取号：将获取到的 Token 发送到自己的服务器，由服务端携带 Token 调用运营商一键登录的接口，调用陈工就返回手机号码。服务端用手机号进行登录或注册操作，返回操作结果给客户端，完成一键登录。\n\n由于国内三大运营商各自有独立的 SDK，所以会导致兼容方面的工作会特别繁琐。如果要采用一键登录的方案，不妨采用第三方提供了号码认证服务，下列几家供应商都拥有手机号码认证能力：\n\n- [阿里 - 号码认证服务](https://help.aliyun.com/product/75010.html)\n- [创蓝 - 闪验](http://shanyan.253.com/)\n- [极光 - 极光认证](https://www.jiguang.cn/identify)\n- [mob - 秒验](https://www.mob.com/mobService/secverify)\n\n在认证过程中，需要用户打开蜂窝网络，如果手机设备没有插入 SIM 卡、或者关闭蜂窝网络的情况下，是无法完成认证的。所以就算接入一键登录，还是要兼容传统的登录方式，允许用户在失败的情况下，仍能正常完成登录流程。\n\n## 总结\n\n鉴权授权是计算机领域无法躲避的技术议题，认证、授权、鉴权和权限控制是围绕这个议题的几个关键概念：认证（Identification）是指根据声明者提供的资料，确认声明者身份；授权（Authorization）则是资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作；鉴权（Authentication）指的对声明者所声明的真实性进行校验。从授权角度出发，会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。\n\n- Authorization 决定你是否有权限去获取资源\n- Authentication 校验你说你是谁\n\n```\n授权 -> 鉴权 -> 权限控制\n```\n\n花了一周时间将登录鉴权授权方面的知识总结了一番，确认对各种方案的实施细节，以及设计原理、方案优劣都有了更深一层的了解，在学习的过程中不免会联想到无论是生活中各种类似的场景，也会想到计算机领域中诸如 Linux 系统、数据库等权限控制相关机制。这是个融汇贯通的学习过程，发现这种针对某个议题的体系式整理，对前端技术体系中各个独立的点连通起到了不错的效果。\n\n---\n\n**参考资料：**\n\n- [📖 Wikipedia：Basic Access Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication)\n- [📖 HTTP 身份验证 Authentication](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication)\n- [📖 RFC 7019 - JSON Web Token（JWT）](https://tools.ietf.org/html/rfc7519)\n- [📖 CAS 官方文档](https://apereo.github.io/cas/4.2.x/index.html)\n- [📝 一文读懂 HTTP Basic 身份认证](https://juejin.im/entry/5ac175baf265da239e4e3999)\n- [📝 你在用 JWT 代替 Session？](https://zhuanlan.zhihu.com/p/43527568)\n- [📝 用户认证：基于 JWT 和 Session 的区别和优缺点](https://juejin.im/post/5cefad23e51d4510774a87f4#heading-4)\n- [📝 JWT 身份认证优缺点分析以及常见问题解决方案](https://zhuanlan.zhihu.com/p/85873228)\n- [📝 前端需要了解的 SSO 与 CAS 知识](https://juejin.im/post/5a002b536fb9a045132a1727)\n- [📝 不务正业的前端之 SSO（单点登录）实践](https://juejin.im/post/5b51f39b5188251a9f24a264)\n- [📝 面试题：给我说一下你项目中的单点登录是如何实现的](https://zhuanlan.zhihu.com/p/102898335)\n- [📝 单点登录系统](https://zhuanlan.zhihu.com/p/60376970)\n- [📝 单点登录原理与简单实现](https://www.cnblogs.com/ywlaker/p/6113927.html)\n- [📝 单点登录 LDAP 协议](https://zhuanlan.zhihu.com/p/92263756)\n- [📝 信任登录与联合登录有什么差异？](https://www.zhihu.com/question/21387523)\n- [📝 OAuth2.0 深入了解：以微信开发平台统一登录为例](https://juejin.im/entry/5a93506e6fb9a0634c268da8)\n- [📝 OAuth 2.0 概念及授权流程梳理](https://www.cnblogs.com/hellxz/p/oauth2_process.html)\n- [📝 论 H5 嵌入 APP 的联合登录的解决方案](https://juejin.im/post/5d15d3336fb9a07efb69994f)\n- [📝 聊一聊二维码扫描登录原理](https://juejin.im/post/5e83e716e51d4546c27bb559)\n- [📝 阿里面试官：分别说说微信和淘宝扫码登录背后的实现原理](https://mp.weixin.qq.com/s/gA0JQp4j2ym9qOyQkC3qkA)\n- [📝 用户一键登录，如何实现](https://juejin.im/post/5d197adff265da1bb31c4fa9)\n- [📝 微服务架构下的鉴权，怎么做更优雅？](https://learnku.com/articles/30704)\n- [📝 认证、授权、鉴权和权限控制](http://www.hyhblog.cn/2018/04/25/user_login_auth_terms/)\n","slug":"authentication","published":1,"updated":"2021-08-18T03:27:22.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99z3000bv31pjclouwqx","content":"<p>登录鉴权是互联网信息交互中永恒的话题，毕竟在工作中几乎每天都会接触到，适逢最近需要对现有的系统平台进行 SSO 的流程改造，所以趁这个机会好好总结前端工程师接触到的登录方式。</p>\n<p>鉴权也叫身份验证（Authentication），是指验证用户是否拥有访问系统的权利。在日常的生活中，身份验证随处可见，比如：进入高铁站候车室、机场候机楼需要检查票据和身份证件；游玩主题乐园、名胜风景区需要购买门票，并由入口处人员鉴定有效后方可拥有进入园区游玩的权利。</p>\n<p>而在计算机领域中，身份验证的方法有很多种：基于共享密钥的身份验证、基于生物学特征的身份验证和基于公开密钥加密算法的身份验证。不同的身份验证方法，安全性也各自不同。</p>\n<p>下面我将从前端开发工程师的角度出发，梳理 Web 应用前后端数据交互中的各种鉴权方案。</p>\n<a id=\"more\"></a>\n<p>以下为本文大纲：</p>\n<ul>\n<li>HTTP 基本认证</li>\n<li>Session-Cookie 认证<ul>\n<li>koa-session</li>\n</ul>\n</li>\n<li>Token 认证<ul>\n<li>JWT 认证</li>\n<li>koa-jwt</li>\n</ul>\n</li>\n<li>OAuth2 开放授权</li>\n<li>SSO 单点登录</li>\n<li>LDAP 认证登录</li>\n<li>扫码登录</li>\n<li>联合登录</li>\n<li>信任登录</li>\n<li>易混淆概念分析</li>\n</ul>\n<h2 id=\"HTTP-基本认证\"><a href=\"#HTTP-基本认证\" class=\"headerlink\" title=\"HTTP 基本认证\"></a>HTTP 基本认证</h2><p>在 HTTP 中，基本认证方案（Basic Access Authentication）是允许 HTTP 用户代理（通常指的就是网页浏览器）在请求时，通过用户提供用户名和密码的方式，实现对用户身份的验证。</p>\n<p>基本认证中，最关键的是四个要素：</p>\n<ol>\n<li><code>uid</code>：用户的 ID，也就是我们常说的用户名</li>\n<li><code>password</code>：密码</li>\n<li><code>realm</code>：领域，其实就是指当前认证的保护范围</li>\n</ol>\n<p>在进行基本认证的过程中，HTTP 的请求头字段会包含 Authorization 字段，<code>Authorization: Basic &lt;用户凭证&gt;</code>，该用户凭证是 <code>用户名</code> 和 <code>密码</code> 的组合而成的 <strong>Base64 编码</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /securefiles/ HTTP/1.1</span><br><span class=\"line\">Host: www.example.com</span><br><span class=\"line\">Authorization: Basic aHR0cHdhdGNoOmY=</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.mrsingsing.com/authentication-http-basic-access-authentication.jpg\" alt=\"HTTP 基本认证流程图\"></p>\n<ol>\n<li>用户在浏览器中访问了受限制的网页资源，但是没有提供用户的身份信息</li>\n<li>服务端接收到请求后返回 401 应答码（Unauthorized，未被授权的）要求进行身份验证，并附带提供了一个认证域（Access Authentication）<code>WWW-Authenticate</code> 说明如何进行验证的方法，例如 <code>WWW-Authenticate: Basic realm=&quot;Secure Area&quot;</code>，<code>Basic</code> 就是验证的模式，而 <code>realm=&quot;Secure Area&quot;</code> 则为保护域（告知认证的范围），用于与其他请求 URI 作区别</li>\n<li>浏览器收到应答后，会显示该认证域给用户并提示输入用户名和密码，此时用户可以选择录入信息后确定或取消操作</li>\n<li>用户输入了用户名和密码后，浏览器会在原请求头新增认证消息字段 <code>Authorization</code> 并重新发送请求，过程如下：</li>\n</ol>\n<ul>\n<li>将用户名和密码拼接为 <code>用户名:密码</code> 格式的字符串</li>\n<li>如果服务器 <code>WWW-Authenticate</code> 字段有指定编码，则将字符串编译成对应的编码</li>\n<li>将字符串编码为 Base64</li>\n<li>拼接 <code>Basic</code>，设置为 <code>Authorization</code> 字段，假设用户名为 <code>admin</code>，密码为 <code>password</code>，则拼接后为 <code>admin:password</code>，使用 Base64 编码后为 <code>YWRtaW46cGFzc3dvcmQ=</code>，那么最终在 HTTP 头部里会是这样：<code>Authorization: Basic YWRtaW46cGFzc3dvcmQ=</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Buffer.from(<span class=\"string\">'admin:password'</span>).toString(<span class=\"string\">'base64'</span>);</span><br><span class=\"line\"><span class=\"comment\">// YWRtaW46cGFzc3dvcmQ=</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>服务端接收了该认证后并返回了用户请求的网页资源。如果用户凭证非法或无效，服务器可能会再次返回 401 应答码，客户端就需要再次输入用户名和密码</li>\n</ol>\n<p>服务端验证的步骤：</p>\n<ol>\n<li>根据用户请求资源的地址，确定资源对应的 <code>realm</code></li>\n<li>解析 Authorization 请求首部，获得用户名和密码</li>\n<li>判断用户是否有访问该 <code>realm</code> 的权限</li>\n<li>验证用户名、密码是否匹配</li>\n</ol>\n<blockquote>\n<p>当然，也有可能在首次请求中，在请求头附带了认证消息头，那么就不需要再作身份信息的录入步骤</p>\n</blockquote>\n<p>优点：</p>\n<ul>\n<li>唯一的优点是实现简单，被广泛支持</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>由于用户名和密码是以明文的形式在网络中进行传输，容易被嗅探器探测到，所以基本验证方案并不安全</li>\n<li>除此之外，Base64 编码并非加密算法，其无法保证安全与隐私，这里仅用于将用户名和密码中的不兼容的字符转换为均与 HTTP 协议兼容的字符集</li>\n<li>即使认证内容无法被解码为原始的用户名和密码也是不安全的，恶意用户可以再获取了认证内容后使用其不断的享服务器发起请求，这就是所谓的重放攻击</li>\n<li>该方案除了存在安全缺陷外，Basic 认证还存在无法吊销认证的情况</li>\n</ul>\n<blockquote>\n<p>HTTP 的基本验证方案应与 HTTPS / TLS 协议搭配使用。加入没有这些安全方面的增强，那么基本验证方案不应该被用来保护敏感或者极具价值的信息。</p>\n</blockquote>\n<p>应用场景：内部网络，或者对安全要求不是很高的网络</p>\n<h2 id=\"Session-Cookie-认证\"><a href=\"#Session-Cookie-认证\" class=\"headerlink\" title=\"Session-Cookie 认证\"></a>Session-Cookie 认证</h2><p><code>Session-Cookie</code> 认证是利用服务端的 Session（会话）和浏览器（客户端）的 Cookie 来实现的前后端通信认证模式。</p>\n<p>由于 HTTP 请求时是无状态的，服务端正常情况下无法得知请求发送者的身份，这个时候我们如果要记录状态，就需要在服务端创建 Session 会话，将相同客户端的请求都维护在各自的会话记录中，每当请求到达服务端时，先校验请求中的用户标识是否存在于 Session 中，如果有则表示已经认证成功，否则表示认证失败。</p>\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为追踪（如跟踪分析用户行为等）</li>\n</ul>\n<p>下图为 Session-Cookie 认证的工作流程图：</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-session-cookie.jpg\" alt=\"Session-Cookie 认证流程图\"></p>\n<ol>\n<li>服务端在接收到来自客户端的首次访问时，会自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证 <code>session_id</code>（通常称为 <code>sid</code>），并在响应头 <code>Set-Cookie</code> 中设置这个唯一标识符</li>\n<li>签名，对 <code>sid</code> 进行加密处理，服务端会根据这个 <code>secret</code> 密钥进行解密（非必需步骤）</li>\n<li>浏览器收到请求响应后会解析响应头，并自动将 <code>sid</code> 保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息</li>\n<li>服务端在接收客户端请求时会去解析请求头 Cookie 中的 <code>sid</code>，然后根据这个 <code>sid</code> 去找服务端保存的该客户端的 <code>sid</code>，然后判断该请求是否合法</li>\n<li>一旦用户登出，服务端和浏览器将会同时销毁各自保存的会话 ID，服务端会根据数据库验证会话身份凭证，如果验证通过，则继续处理</li>\n</ol>\n<blockquote>\n<p>⚠️ 注意，这里相对于使用服务端，在另一端我使用了 <code>浏览器</code> 而非客户端，主要是因为 Cookie 是仅在浏览器中存在的报文字段，诸如移动原生 APP 是无法解析存储 Cookie 请求/响应头的。</p>\n</blockquote>\n<p>优点：</p>\n<ol>\n<li>Cookie 简单易用，在不受用户干预或过期处理的情况下，Cookie 通常是客户端上持续时间最长的数据保留形式</li>\n<li>Session 数据存储在服务端，相较于 JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的 Session 就可以了，方便管理</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被 CSRF 等攻击）</li>\n<li>Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能</li>\n<li>用户认证后，服务端做认证记录，如果认证的记录被保存在内存中，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权资源，这样在分布式的应用上，相应的限制了负载均衡的能力，也意味着限制了应用的扩展能力</li>\n</ol>\n<h3 id=\"koa-session\"><a href=\"#koa-session\" class=\"headerlink\" title=\"koa-session\"></a>koa-session</h3><p>没有代码谈再多都是空中楼阁，下面尝试在 Koa 中使用 <code>koa-session2</code> 中间件实现 Session-Cookie 这种鉴权方式。</p>\n<p>在实际项目中，与客户端的会话信息往往需要在服务外再设立额外的外部存储机制，外部存储可以是任何的存储机制，例如内存数据结构，也可以是本地的文件系统，或是使用诸如 Redis 等 NoSQL 数据库。</p>\n<p><code>koa-session2</code> 自身实现的存储方式为保存在内存中的，而下面我们就介绍一种拓展 <code>koa-session2</code> 结合 Redis 实现 Session-Cookie 认证方式的方案：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Redis = <span class=\"built_in\">require</span>(<span class=\"string\">'ioredis'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; Store &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-session2'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisStore</span> <span class=\"keyword\">extends</span> <span class=\"title\">Store</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 Redis</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.redis = <span class=\"keyword\">new</span> Redis();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 根据 sid 获取用户信息</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"keyword\">get</span>(sid, ctx) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.redis.get(<span class=\"string\">`SESSION: <span class=\"subst\">$&#123;sid&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 更新 sid 的用户信息</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"keyword\">set</span>(session, &#123; sid = <span class=\"keyword\">this</span>.getID(<span class=\"number\">24</span>), maxAge = <span class=\"number\">1000000</span> &#125; = &#123;&#125;, ctx) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.redis.set(<span class=\"string\">`SESSION: <span class=\"subst\">$&#123;sid&#125;</span>`</span>, <span class=\"built_in\">JSON</span>.stringfy(session));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sid;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 销毁会话信息</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> destroy(sid, ctx) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.redis.del(<span class=\"string\">`SESSION: <span class=\"subst\">$&#123;sid&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = RedisStore;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> session = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-session2'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Store = <span class=\"built_in\">require</span>(<span class=\"string\">'./Store.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(</span><br><span class=\"line\">  session(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 种下 Cookie 的键名</span></span><br><span class=\"line\">    key: <span class=\"string\">'SESSIONID'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 禁止浏览器中 JS 脚本修改 Cookie</span></span><br><span class=\"line\">    httpOnly: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"comment\">// Cookie 加密签名机制</span></span><br><span class=\"line\">    signed: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    store: <span class=\"keyword\">new</span> Store(),</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Ignore favicon.ico</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.path === <span class=\"string\">'/favicon.ico'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> user = <span class=\"keyword\">this</span>.session.user;</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx.session.view = <span class=\"string\">'index'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果设置了会话有效期刷新会话有效期</span></span><br><span class=\"line\">  ctx.session.refresh();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在 <code>koa-session</code> 中会话标识的实现仅是根据时间戳生成的随机字符串，如果担心 Cookie 传输中被恶意篡改或暴露信息，可以通过加入更多标识元素，例如 IP 地址、设备 ID 等。</p>\n<p>Koa 的 Cookie 实现默认带了安全机制，就是 <code>signed</code> 选项为 <code>true</code> 时，会自动给 Cookie 添加一个 SHA256 的签名，类似 <code>koa:sess=pjadZtLAVtiO6-Haw1vnZZWrRm8</code>，从而防止 Cookie 被篡改。</p>\n<p>至于担心的 Session 信息泄漏问题，<code>koa-session</code> 允许用户自定义编解码方法，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> encode = <span class=\"function\"><span class=\"params\">json</span> =&gt;</span> CrytoJS.AES.encrypt(json, <span class=\"string\">'Secret Passphrase'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decode = <span class=\"function\"><span class=\"params\">encrypted</span> =&gt;</span> CryptoJS.AES.decrypt(encrypted, <span class=\"string\">'Secret Passphrase'</span>);</span><br></pre></td></tr></table></figure>\n<p><code>koa-session</code> 为 Koa 官方实现的中间件，功能强大，考虑的情况比较多，所以实现相对复杂。</p>\n<p>而 <code>koa-session2</code> 是社区实现的中间件，简洁易用。如果对实现有兴趣的同学可以在 Github 找到源码阅读。</p>\n<ul>\n<li><a href=\"https://github.com/koajs/session\" target=\"_blank\" rel=\"noopener\">koa-session</a></li>\n<li><a href=\"https://github.com/Secbone/koa-session2\" target=\"_blank\" rel=\"noopener\">koa-session2</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000013039187\" target=\"_blank\" rel=\"noopener\">koa-session 学习笔记</a></li>\n<li><a href=\"https://www.jianshu.com/p/c1eff1b50d23\" target=\"_blank\" rel=\"noopener\">koa-session 的内部实现</a></li>\n<li><a href=\"https://juejin.im/post/5c148fd551882530544f341f\" target=\"_blank\" rel=\"noopener\">从 koa-session 源码解读 session 原理</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000012412299\" target=\"_blank\" rel=\"noopener\">从 koa-session 中间件源码学习 cookie 与 session</a></li>\n</ul>\n<h2 id=\"Token-认证\"><a href=\"#Token-认证\" class=\"headerlink\" title=\"Token 认证\"></a>Token 认证</h2><p>随着 Restful API、微服务的兴起，基于 Token 的认证现在已经越来越普遍。Token 和 Session-Cookie 认证方式中的 Session ID 不同，并非只是一个标识符。Token 一般会包含 <code>用户的相关信息</code>，通过验证 Token 不仅可以完成身份校验，还可以获取预设的信息。像 Twitter、微信、QQ、Github 等公有 API 都是基于这种方式进行认证的，一些开发框架如 OpenStack、Kubernetes 内部 API 调用也是基于 Token 的认证。</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-token-authencation.jpg\" alt=\"Token 认证流程图\"></p>\n<p>基于 Token 的身份验证方法：</p>\n<ol>\n<li>用户输入登录信息并请求登录</li>\n<li>服务端收到请求，验证用户输入的登录信息</li>\n<li>验证成功后，服务端会 <code>签发</code>一个 Token（通常包含用户基础信息、权限范围和有效时间等），并把这个 Token 返回给客户端</li>\n<li>客户端收到 Token 后需要把它存储起来，比如放在 localStorage 或 sessionStorage 里（一般不放 Cookie 因为可能会有跨域问题，以及安全性问题）</li>\n<li>后续客户端每次向服务端请求资源的时候，将 Token 附带于 HTTP 请求头 Authorization 字段中发送请求</li>\n<li>服务端收到请求后，去校验客户端请求中 Token，如果验证成功，就向客户端返回请求的数据，否则拒绝返还</li>\n</ol>\n<p>优点：</p>\n<ul>\n<li><strong>服务端无状态</strong>：Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态</li>\n<li><strong>性能相对较好</strong>：因为在验证 Token 时不用再去访问数据库或远程服务进行权限校验，自然可以提升不少性能</li>\n<li>支持移动设备</li>\n<li>支持跨域跨程序调用，因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题</li>\n<li>有效避免 CSRF 攻击（因为不需要 Cookie），但是会存在 XSS 攻击中被盗的风险，但是可选择 Token 存储在标记为 <code>httpOnly</code> 的 Cookie 中，能够有效避免浏览器中的 JS 脚本对 Cookie 的修改</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>占带宽：正常情况下比 <code>sid</code> 更大，消耗更多流量，挤占更多宽带</li>\n<li>性能问题：相比较于 Session-Cookie 认证来说，Token 需要服务端花费更多时间和性能来对 Token 进行解密验证，其实 Token 相较于 Session—Cookie 来说就是一个时间换空间的方案</li>\n</ul>\n<blockquote>\n<p>Session-Cookie 认证和 Token 认证的比较</p>\n</blockquote>\n<p>Session-Cookie 认证和 Token 认证有很多类似的地方，但是 Token 认证更像是 Session-Cookie 认证的升级改良版。</p>\n<p>Session-Cookie 认证仅仅靠的是 <code>sid</code> 这个生成的唯一标识符，服务端需要根据客户端传来的 <code>sid</code> 查询保存在服务端 Session 里保存的登录状态，当存储的信息数据量超过一定量时会影响服务端的处理效能。而且 Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的。</p>\n<p>而 Token 认证机制特别的是，实质上登录状态是用户登录后存放在客户端的，服务端不会充当保存 <code>用户信息凭证</code> 的角色，当每次客户端请求时附带该凭证，只要服务端根据定义的规则校验是否匹配和合法即可，客户端存储的手段也不限于 Cookie，可以使用 Web Storage 等其他缓存方式。简单来说，Session-Cookie 机制限制了客户端的类型，而 Token 验证机制丰富了客户端类型。</p>\n<p>除此之外，Token 验证比较灵活，除了常见的 JWT 外，可以基于 Token 构建专门用于鉴权的微服务，用它向多个服务的请求进行统一鉴权。</p>\n<h3 id=\"JWT-认证\"><a href=\"#JWT-认证\" class=\"headerlink\" title=\"JWT 认证\"></a>JWT 认证</h3><p>JWT（JSON Web Token）是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登录成功后将相关信息组成 JSON 对象，然后对这个对象进行某种方式的加密，返回给客户端，客户端在下次请求时带上这个 Token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。</p>\n<p>JWT 是 JSON 格式的被加密了的字符串：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON Data + Signature = JWT</span><br></pre></td></tr></table></figure>\n<p>JWT 对象通常由三部分组成：</p>\n<ol>\n<li>头部（Headers）：包括类别（typ）、加密算法（alg）</li>\n</ol>\n<p>头部用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"alg\"</span>: <span class=\"string\">\"HS256\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"typ\"</span>: <span class=\"string\">\"JWT\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们说明了这是一个 JWT，并且我们所使用的签名算法是 HS256 算法。</p>\n<ol start=\"2\">\n<li>Claims：包括需要传递的用户信息</li>\n</ol>\n<p>载荷可以用来存放一些不敏感的信息</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"iss\"</span>: <span class=\"string\">\"Jehoshaphat Tse\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"iat\"</span>: <span class=\"number\">1441593502</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"exp\"</span>: <span class=\"number\">1441594722</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"aud\"</span>: <span class=\"string\">\"www.example.com\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"sub\"</span>: <span class=\"string\">\"mrsingsing@example.com\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"John Doe\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"admin\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面的前五个字段都是由 JWT 的标准所定义的:</p>\n<ul>\n<li><code>iss</code>：该 JWT 的签发者</li>\n<li><code>sub</code>：该 JWT 所面向的用户</li>\n<li><code>aud</code>：接收该 JWT 的一方</li>\n<li><code>exp</code>（expires）：什么时候过期，这是 Unix 时间戳</li>\n<li><code>iat</code>（issued at）：在什么时候签发的。把头部和载荷分别进行 Base64 编码后得到两个字符串，然后再将这两个编码后的字符串用英文句号连接起来（头部在前），形成新的字符</li>\n</ul>\n<ol start=\"3\">\n<li>Signature：</li>\n</ol>\n<p>最后，将上述拼接后的字符串，用 <code>alg</code> 指定的算法（HS256）与私有密钥（Secret）进行加密。加密后的内容也是字符串，最后这个字符串就是签名，把这个签名拼接在刚才的字符串后面就能得到完整的 JWT。Header 部分和 Claims 部分如果被篡改，由于篡改者不知道密钥是什么，也无法生成新的 Signature 部分，服务端也就无法通过，在 JWT 中，消息体是透明的，使用签名可以保证消息不被篡改。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HMACSHA256(base64UrlEncode(Headers) + <span class=\"string\">'.'</span> + base64UrlEncode(Claims), SECREATE_KEY);</span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>不需要在服务端保存会话信息（RESTful API 的原则之一就是无状态），所以易于应用的扩展，即信息不保存在服务端，不会存在 Session 扩展不方便的情况</li>\n<li>JWT 中的载荷可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><strong>过期时间问题</strong>：由于服务端不保存 Session 状态，因此无法在使用过程中废止某个 Token，或是更改 Token 的权限。也就是说，一旦 JWT 签发，在到期之前就会始终有效，除非服务端部署额外的逻辑。因此如果是浏览器端应用的话，使用 JWT 认证机制还需要设计一套 JWT 的主动更新删除的机制，这样就增加了系统的复杂性。</li>\n<li><strong>安全性</strong>：由于 JWT 的 Claims 是 Base64 编码的，并没有加密，因此 JWT 中不能存储敏感数据</li>\n<li><strong>性能问题</strong>：JWT 占用空间过大，Cookie 限制一般是 4k，可能会无法容纳，所以 JWT 一般放 LocalStorage 里面，并且用户在系统的每次 HTTP 请求都会把 JWT 携带在 Header 里面，HTTP 请求的 Header 可能比 Body 还要大。</li>\n</ol>\n<h3 id=\"koa-jwt\"><a href=\"#koa-jwt\" class=\"headerlink\" title=\"koa-jwt\"></a>koa-jwt</h3><p>下面介绍 Koa 中使用 <code>koa-jwt</code> 进行颁发、校验 Token 的使用方法。</p>\n<p>服务端生成 Token</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-router'</span>)();</span><br><span class=\"line\"><span class=\"keyword\">const</span> jwt = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-jwt'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 这里使用的是 MongoDB 数据库</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> userModel = <span class=\"built_in\">require</span>(<span class=\"string\">'../model/userModel'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> secretOrPublicKey = <span class=\"string\">'TOKEN_EXAMPLE'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/login'</span>, <span class=\"keyword\">async</span> ctx =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = ctx.request.body;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 根据用户提供的用户名和密码查询数据库中是否存在对应的用户信息</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> userInfo = <span class=\"keyword\">await</span> userModel.findOne(&#123; <span class=\"attr\">name</span>: data.name, <span class=\"attr\">password</span>: data.password &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (userInfo !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据用户信息签发 Token，设定有效时间为 2h</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> token = jwt.sign(&#123; <span class=\"attr\">name</span>: userInfo.name, <span class=\"attr\">_id</span>: userInfo._id &#125;, secretOrPublicKey, &#123;</span><br><span class=\"line\">      expiresIn: <span class=\"string\">'2h'</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    result = &#123;</span><br><span class=\"line\">      code: <span class=\"number\">200</span>,</span><br><span class=\"line\">      token: token,</span><br><span class=\"line\">      msg: <span class=\"string\">'登录成功'</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = &#123;</span><br><span class=\"line\">      code: <span class=\"number\">400</span>,</span><br><span class=\"line\">      token: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      msg: <span class=\"string\">'登录失败'</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (ctx.body = result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>前端获取 Token：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求登录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">login</span>(<span class=\"params\">userName, password</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios</span><br><span class=\"line\">    .post(<span class=\"string\">'/login'</span>, &#123;</span><br><span class=\"line\">      name: userName,</span><br><span class=\"line\">      password: password,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res.code === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        localStorage.setItem(<span class=\"string\">'access_token'</span>, res.data.token);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'登录失败'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.error(e));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后续获取 Token 后续的 API 请求</span></span><br><span class=\"line\"><span class=\"comment\">// 通过 Axios 拦截器加上 Authorization 请求头部字段</span></span><br><span class=\"line\">axios.interceptors.request.use(<span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = localStorage.getItem(<span class=\"string\">'token'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  config.headers.common[<span class=\"string\">'Authorization'</span>] = <span class=\"string\">'Bearer '</span> + token;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>服务端校验前端发送来的请求：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> jwt = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-jwt'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"><span class=\"keyword\">const</span> secretOrPublicKey = <span class=\"string\">'TOKEN_EXAMPLE'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">app</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    jwt(&#123;</span><br><span class=\"line\">      secret: secretOrPublicKey,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .unless(&#123;</span><br><span class=\"line\">    path: [<span class=\"regexp\">/\\register/</span>, /\\/login/],</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>在 <code>koa-jwt</code> 的源码实现中，我们可以知道 Token 的鉴定是先判断请求头中是否带了 Authorization：</p>\n<ul>\n<li>有，则通过正则将 <code>token</code> 从 Authorization 中分离出来，Token 中是带有 Bearer 这个单词</li>\n<li>没有，则代表了客户端没有传 Token 到服务器，这时候就抛出 401 错误状态</li>\n</ul>\n<p>源码文件中的 <code>verify.js</code> 中，调用了 <code>jsonwebtoken</code> 库原生提供的 <code>verify()</code> 方法进行验证返回结果。</p>\n<p><a href=\"https://github.com/auth0/node-jsonwebtoken\" target=\"_blank\" rel=\"noopener\">jsonwebtoken</a> 的 <code>sign()</code> 用于生成 <code>token</code>，而 <code>verify()</code> 方法当然则是用来解析 <code>token</code>。属于 JWT 配对生产的两个方法，所以 <code>koa-jwt</code> 这个中间件也没做什么事，无非就是用正则解析请求头，调用 <code>jsonwebtoken</code> 的 <code>verify()</code> 验证 <code>token</code>，在 <code>koa-jwt</code> 文件夹的 <code>index.js</code> 中，<code>koa-jwt</code> 还调用 <code>koa-unless</code> 进行路由权限分发。</p>\n<ul>\n<li><a href=\"http://www.uxys.com/html/JavaScript/20190722/52733.html\" target=\"_blank\" rel=\"noopener\">Koa2 服务端使用 JWT 进行鉴权及路由权限分发的流程分析</a></li>\n</ul>\n<h3 id=\"Token-认证常见问题及解决方案\"><a href=\"#Token-认证常见问题及解决方案\" class=\"headerlink\" title=\"Token 认证常见问题及解决方案\"></a>Token 认证常见问题及解决方案</h3><h4 id=\"注销登录\"><a href=\"#注销登录\" class=\"headerlink\" title=\"注销登录\"></a>注销登录</h4><p>注销登录等场景下 Token 仍有效类似的场景：</p>\n<ul>\n<li>退出登录</li>\n<li>修改密码</li>\n<li>服务端修改了某个用户具有的权限或角色</li>\n<li>用户的账户被删除/暂停</li>\n<li>用户由管理员注销</li>\n</ul>\n<p>这个问题仅存在于 Token 认证中，因为 Session-Cookie 认证模式中，这些情况能够通过删除服务端 Session 中对应的记录解决，而 Token 认证中，如果服务端不增加其他逻辑的话，在失效前 Token 都是有效的。</p>\n<p>下面列出几种针对这些场景的解决方案：</p>\n<ul>\n<li><strong>将 Token 存储在内存数据库</strong>：将 Token 存入类似于 Redis 的内存数据库中。如果需要让某个 Token 失效就直接从 Redis 中删除这个 Token 即可。但是这样会导致每次使用 Token 发送请求都要先从 DB 中查询 Token 是否存在的步骤，而且违背了 JWT 无状态原则。</li>\n<li><strong>黑名单机制</strong>：和上述方案类似，使用内存数据库维护一份黑名单，如果想让某个 Token 失效的话就直接将这个 Token 放入到黑名单内即可。每次使用 Token 进行请求时都会先判断 Token 是否存在于黑名单中。</li>\n<li><strong>修改密钥 Secret</strong>：为每个用户创建专属密钥，如果想让某个 Token 失效，我们直接修改对应用户的密钥即可。但是，这样相较于前两种引入内存数据带入的危害更大：<ul>\n<li>如果服务是分布式的，每次发出新的 Token 时都必须在多台及其同步密钥。为此，你需要将机密存在数据库或其他外部服务中，这样和 Session 认证就没有太大区别了</li>\n<li>如果用户同时在两个浏览器打开系统，或者在移动设备上打开系统，当它从一个地方将账号退出时，那么其他终端都需要重新登录认证，这是不可取的</li>\n</ul>\n</li>\n<li><strong>保持令牌的有效期限短并经常轮换</strong><ul>\n<li>很简单的方式，但是会导致用户登录状态不会被持久记录，而且需要用户经常登录</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"续签问题\"><a href=\"#续签问题\" class=\"headerlink\" title=\"续签问题\"></a>续签问题</h4><p>Token 的续签问题：</p>\n<p>Token 有效期一般不建议设置过长，而 Token 过期后如何认证，如何 <code>动态刷新</code> Token 等需要有效的方案解决。</p>\n<p>在 Session-Cookie 认证中，假设 Session 有效期为 30 分钟，如果 30 分钟内有资源请求访问，那么就把 Session 的有效期自动延长 30 分钟。</p>\n<ul>\n<li><strong>类似于 Session 人中的做法</strong>：当客户端访问服务端，发现 Token 即将过期时，服务端重新颁发新的 Token 给客户端</li>\n<li><strong>每次请求都返回新 Token</strong>：实现思路简单明了，但是开销较大</li>\n<li><strong>Token 有效期设置到半夜</strong>：折衷方案，保证大部分用户正常工作时间可以正常登录，适用于安全性要求不高的系统</li>\n<li><strong>用户登录返回两个 Token</strong>：第一个是 <code>accessToken</code>，它的过期时间设置比如半个小时，另一个是 <code>refreshToken</code>，它的过期时间更长一点，例如 1 天。客户端登录后，将 <code>accessToken</code> 和 <code>refreshToken</code> 保存在本地，每次访问将 <code>accessToken</code> 传给服务端。服务端校验 <code>accessToken</code> 的有效性，如果过期的话，就将 <code>refreshToken</code> 传给服务端。如果有效，服务端就生成新的 <code>accessToken</code> 给客户端。否则，客户端就重新登录即可。该方案不足的是：<ul>\n<li>需要客户端配合</li>\n<li>用户注销的时候需要同时保证两个 Token 都无效</li>\n<li>重新请求获取 Token 的过程中会有短暂 Token 不可用的情况（可以通过在客户端设置定时器，当 <code>accessToken</code> 快过期的时候，提前去通过 <code>refreshToken</code> 获取新的 <code>accessToken</code>）</li>\n</ul>\n</li>\n</ul>\n<p>JWT 最适合的场景是不需要服务端保存用户状态的场景，如果考虑到 Token 注销和续签等场景的话，目前来说没有特别好的解决方案，大部分解决方案都给 Token 加上状态，这实际上就有点类似 Session-Cookie 认证了。</p>\n<h2 id=\"单点登录\"><a href=\"#单点登录\" class=\"headerlink\" title=\"单点登录\"></a>单点登录</h2><p><strong>单点登录</strong>（Single Sign-on）又称 SSO，是指在多系统应用群中登录单个系统，便可在其他所有系统中得到授权而无需再次登录。</p>\n<p>传统的 All-in-one 型应用的认证系统和业务系统集合在一起的，当用户认证通过时，将用户信息存入 Session 中。其他业务只需要从业务中通过对应会话身份凭证取到用户信息进行相关业务处理即可。</p>\n<p>传统的 Session 是将用户信息存入内存，维护一个哈希表。每次请求携带会话身份凭证 SessionID（Tomcat 中是 <code>JSESSIONID</code>）到服务端，根据此 SessionID 查找到对应的用户信息。</p>\n<p>利用 Redis 等内存数据库进行用户信息的存储，自定义 Token 生成规则将用户信息写入 Redis 中。这样将用户信息的存储和业务系统进行拆分，使系统更加健壮，更易于扩展。新增系统只需要从 SSO 中获取相关的认证即可进行横向的业务扩展。而且 Redis 本身的性质也易于进行 <code>集群化</code> 的部署。</p>\n<p>下面详述各种场景下 SSO 的实现方案。</p>\n<h3 id=\"同域-SSO\"><a href=\"#同域-SSO\" class=\"headerlink\" title=\"同域 SSO\"></a>同域 SSO</h3><p>当存在两个相同域名下的系统 A <code>a.abc.com</code> 和系统 B <code>b.abc.com</code> 时，以下为他们实现 SSO 的步骤：</p>\n<ol>\n<li>用户访问某个子系统时（例如 <code>a.abc.com</code>），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录</li>\n<li>登录认证后，服务端把登录用户的信息存储于 Session 中，并为用户生成对应的会话身份凭证附加在响应头的 <code>Set-Cookie</code> 字段中，随着请求返回写入浏览器中，并回跳到设定的子系统链接中</li>\n<li>下次发送请求时，当用户访问同域名的系统 B 时，由于 A 和 B 在相同域名下，也是 <code>abc.com</code>，浏览器会自动带上之前的 Cookie。此时服务端就可以通过该 Cookie 来验证登录状态了。</li>\n</ol>\n<p>这实际上使用的就是 Session-Cookie 认证的登录方式。</p>\n<h3 id=\"跨域-SSO\"><a href=\"#跨域-SSO\" class=\"headerlink\" title=\"跨域 SSO\"></a>跨域 SSO</h3><p>上述所提及的同域名 SSO 并不支持跨域名的登录认证，这显然不符合当今互联网发展潮流，毕竟大多数中大型企业内外部的系统都是部署在不同的域名下，下面我们介绍实现单点登录的标准流程。</p>\n<p><strong>CAS</strong>（Central Authentication Service）中央授权服务，本身是一个开源协议，分为 1.0 版本和 2.0 版本。1.0 称为基础模式，2.0 称为代理模式，适用于存在非 Web 应用之间的单点登录。</p>\n<p>CAS 的实现需要三方角色：</p>\n<ul>\n<li>Client：用户</li>\n<li>Server：中央授权服务，也是 SSO 中心负责单点登录的服务器</li>\n<li>Service：需要使用单点登录鉴权的各个业务服务，相当于上文中的系统 A / B</li>\n</ul>\n<p>CAS 的实现需要提供以下四个接口：</p>\n<ul>\n<li><code>/login</code>：登录接口，用于登录到中央授权服务</li>\n<li><code>/logout</code>：登出接口，用于从中央授权服务中登出</li>\n<li><code>/validate</code>：用于验证用户是否登录中央授权服务</li>\n<li><code>/serviceValidate</code>：用于让各个 Service 验证用户是否登录中央授权服务</li>\n</ul>\n<p>CAS 票据：</p>\n<ul>\n<li><strong>TGT（Ticket Grangting Ticket）</strong>：TGT 是 CAS 为用户签发的 <code>登录票据</code>，拥有了 TGT，用户就可以证明自己在 CAS 成功登录过。TGT 封装了 Cookie 值以及此 Cookie 值对应的用户信息。当 HTTP 请求到来时，CAS 以此 Cookie 值（TGC）为 <code>key</code> 查询缓存中是否有 TGT，如果有，则表示用户已登录过。</li>\n<li><strong>TGC（Ticket Granting Cookie）</strong>：CAS Service 生成 TGC 放入自己的 Session 中，而 TGC 就是这个 Session 的唯一标识（SessionID），以 Cookie 形式放到浏览器端，是 CAS Service 用来明确用户身份的凭证</li>\n<li><strong>ST（Service Ticket）</strong>：ST 是 CAS 为用户签发的访问某个 Service 的票据。用户访问 Service 时，Service 发现用户没有 ST，则要求用户去 CAS 获取 ST。用户向 CAS 发出 ST 的请求，CAS 发现用户有 TGT，则签发一个 ST，返回给用户。用户拿着 ST 去访问 Service，Service 拿 ST 去 CAS 验证，验证通过后，允许用户访问资源。</li>\n</ul>\n<p>这里可能概念太多会非常难理解，简单说明下，客户端需要各自维护与不同系统的登录状态，包括与中央授权服务的登录状态。所以，实际上 TGC 和 TGT 是维护客户端与中央授权服务登录状态的会话身份凭证的 <code>key-value</code> 键名值，而 ST 票据则是资源服务向中央授权服务获取用户登录状态、信息的交换凭证，只不过资源服务需要经用户的“手”上才能获取到该票据。</p>\n<p>详细步骤：</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-cas-workflow.png\" alt=\"CAS 验证流程时序图\"></p>\n<ol>\n<li>用户访问系统 A 的受保护资源（域名是 <code>a.abc.com</code>），系统 A 检测出用户处于 <code>未登录</code> 状态，重定向（应答码 302）至 SSO 服务认证中心的登录接口，同时地址参数携带登录成功后回跳到系统 A 的页面链接（跳转的链接形如 <code>sso.abc.com/login?service=https%3A%2F%2Fwww.a.abc.com</code>）</li>\n<li>由于请求没有携带 SSO 服务器上登录的票据凭证（TGC），所以 SSO 认证中心判定用户处于 <code>未登录</code> 状态，重定向用户页面至 SSO 的登录界面，用户在 SSO 的登录页面上进行登录操作。</li>\n<li>SSO 认证中心校验用户身份，创建用户与 SSO 认证中心之间的会话，称为 <code>全局会话</code>，同时创建 <code>授权令牌</code>（ST），SSO 带着授权令牌跳转回最初的系统 A 的请求地址：</li>\n</ol>\n<ul>\n<li>重定向地址为之前写在 <code>query</code> 中的系统 A 的页面地址</li>\n<li>重定向地址的 <code>query</code> 中包含 SSO 服务器派发的 ST</li>\n<li>重定向的 HTTP 响应中包含写 Cookie 的 Header。这个 Cookie 代表用户在 SSO 中的登录状态，它的值就是 TGC</li>\n</ul>\n<ol start=\"5\">\n<li>浏览器重定向至系统 A 服务地址，此时重定向的 URL 中携带着 SSO 服务器生成的 ST</li>\n<li>系统 A 拿着 ST 向 SSO 服务器发送请求，SSO 服务器验证票据的有效性。验证成功后，系统 A 知道用户已经在 SSO 登录了，于是系统 A 服务器使用该令牌创建与用户的会话，称为 <code>局部会话</code>，返回受保护网页资源</li>\n<li>之后用户访问系统 B 受保护资源（域名 <code>b.abc.com</code>），系统 B 检测出用户处于 <code>未登录</code> 状态，跳转至 SSO 服务认证中心，同时地址参数携带授权令牌 ST（每次生成的 ST 都是不一样的）登录成功后回跳的链接</li>\n<li>SSO 认证中心发现用户已登录，跳转回系统 B 的地址，并附上令牌</li>\n<li>系统 B 拿到令牌，去 SSO 认证中心校验令牌是否有效，SSO 认证中心校验令牌，返回有效，注册系统 B</li>\n<li>系统 B 使用该令牌创建与用户的局部会话，返回受保护资源</li>\n</ol>\n<p>至此整个登录流程结束，而在实际开发中，基本上都会根据 CAS 增加更多的判断逻辑，比如，在收到 CAS Server 签发的 ST 后，如果 ST 被 Hacker 窃取，并且 Client 本身没来得及去验证 ST，被 Hacker 抢先一步验证 ST，怎么解决。此时就可以在申请 ST 时添加额外验证因子（如 IP、SessionID 等）。</p>\n<h3 id=\"LDAP-认证登录\"><a href=\"#LDAP-认证登录\" class=\"headerlink\" title=\"LDAP 认证登录\"></a>LDAP 认证登录</h3><p>LDAP 的全称是 Lightweight Directory Access Protocol，即<strong>轻量目录访问协议</strong>，是一个开放、广泛被使用的工业标准（IEFT、RFC）。企业级软件也通常具备 *<em>支持 LDAP</em>- 的功能，比如 Jira、Confluence、OpenVPN 等，企业也经常采用 LDAP 服务器来作为企业的认证源和数据源。但是大家比较常见的误区是，可以使用 LDAP 来实现 SSO。我们可以先分析以下它的主要功能点或场景。</p>\n<ul>\n<li>作为数据源它可以用于存储<ul>\n<li>企业的组织架构树</li>\n<li>企业员工信息</li>\n<li>证书信息</li>\n<li>会议室，打印机等等资源</li>\n</ul>\n</li>\n<li>作为认证源，它也有多种用途<ul>\n<li>存储用户的密码</li>\n<li>对外提供 LDAP 协议的认证方式（通过 LDAP BIND 协议来校验用户名和密码）</li>\n<li>密码策略（密码复杂度，历史密码记录，用户锁定等等）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"信任登录\"><a href=\"#信任登录\" class=\"headerlink\" title=\"信任登录\"></a>信任登录</h2><p>信任登录是指所有不需要用户主动参与的登录，例如建立在私有设备与用户之间的绑定关系，凭证就是私有设备的信息，此时不需要用户再提供额外的凭证。信任登录又指用第三方比较成熟的用户库来校验凭证，并登录当前访问的网站。</p>\n<ol>\n<li>登录服务 *<em>信任业务系统</em>- 的凭证校验结果</li>\n<li>登录服务 *<em>信任第三方登录系统</em>- 的凭证校验结果，前提是必须又本站点的账号体系下的账号与第三方账号的一对一绑定关系，现在流行的授权方式也属于这个模式。</li>\n</ol>\n<p>目前比较常见的第三方信任登录帐号如：QQ 号淘宝帐号、支付宝帐号、微博帐号等。</p>\n<p>信任登录的好处是可以利用第三方庞大的用户群来推广、营销网站，同时减少用户的注册、登录时间。</p>\n<p>提到信任登录，我们就不得不提到 OAuth，正是有了 OAuth，我们的信任登录才得以实现。下面我们就来看下关于 OAuth 的一些介绍。</p>\n<h2 id=\"OAuth2-开发授权\"><a href=\"#OAuth2-开发授权\" class=\"headerlink\" title=\"OAuth2 开发授权\"></a>OAuth2 开发授权</h2><p>OAuth（开放授权）是一个开发标准，允许用户授权 <code>第三方网站</code> 访问他们存储在另外的服务提供商中的信息，而不需要接触到用户名和密码。为了保护数据的安全和隐私，第三方网站访问用户数据前都需要 <code>显式地向用户征求授权</code>。我们常见的 OAuth 认证服务的厂商有微信、QQ、支付宝等。</p>\n<p>OAuth 协议又有 1.0 和 2.0 两个版本，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。</p>\n<p>应用场景有：第三方应用的接入、微服务鉴权互信、接入第三方平台、第一方密码登录等。</p>\n<p>授权模式：</p>\n<ul>\n<li>授权码模式（Authorization Code Grant）</li>\n<li>隐式授权模式（Implicit Grant）</li>\n<li>密码模式（Resource Owner Password Credentials Grant）</li>\n<li>客户端模式（Client Credentials Grant）</li>\n</ul>\n<p>无论哪种授权模式，都必须拥有四种必要的角色参与：<code>客户端</code>、<code>授权服务器</code>、<code>资源服务器</code>，有的还有 <code>用户（资源拥有者）</code>。我们以微信开发平台的授权登录为例解释这四种角色：</p>\n<ul>\n<li>资源拥有者（Resource Owner）：这里指微信用户</li>\n<li>第三方应用（Third-party Application）：指内嵌在微信应用内的第三方应用，形式不限于 Web App、公众号 Web 网页、小程序等等</li>\n<li>授权服务器（Authorization Server）：这里指微信开发平台的授权服务</li>\n<li>资源服务器（Resource Server）：用于存储、获取用户资源，这里指的是微信开放平台的服务器</li>\n</ul>\n<h3 id=\"授权码模式\"><a href=\"#授权码模式\" class=\"headerlink\" title=\"授权码模式\"></a>授权码模式</h3><p>授权码模式是 OAuth 2.0 目前最安全最复杂的授权流程。</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-authorization-code-grant.jpg\" alt=\"授权码模式\"></p>\n<p>授权码模式的授权流程可以分为三个部分：</p>\n<ol>\n<li>Client Side：用户+客户端与授权服务端的交互</li>\n<li>Server Side：客户端与授权服务端之间的交互</li>\n<li>Check Access Token’：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互</li>\n</ol>\n<p>整个流程就是：客户端换取授权码，客户端使用授权码换取 Token，客户端使用 Token 访问资源</p>\n<blockquote>\n<p>前提条件：</p>\n<ul>\n<li>第三方客户端需要提前与资源拥有方（同时也是授权所有方）协商客户端 ID（client_id）以及客户端密钥（client_secret）</li>\n<li>上述流程暂未将 <code>scope</code>、<code>state</code> 等依赖具体框架的内容写进来，这里可以参考 Spring Security OAuth2 的实现</li>\n</ul>\n</blockquote>\n<p><strong>Client Server 客户端换取授权码</strong></p>\n<p>这个客户端可以是浏览器</p>\n<ol>\n<li>客户端将 <code>client_id + client_secret + 授权模式标识（grant_type）+ 回调地址（redirect_uri）</code> 拼接成 URL 访问授权服务器</li>\n<li>授权服务端返回登录界面，要求 <code>用户登录</code>（此时用户提交的账号密码等直接发送到授权服务端，进行校验）</li>\n<li>授权服务端返回授权审批界面，<code>用户授权</code> 完成</li>\n<li>授权服务端 <code>返回授权码到回调地址</code></li>\n</ol>\n<p><strong>Server Side 客户端使用授权码换取 Token</strong></p>\n<ol>\n<li>客户端接收到授权码，并使用 <code>授权码 + client_id + client_secret</code> 访问授权服务端颁发 Token 令牌</li>\n<li>授权服务端校验通过，颁发 Token 返回给客户端</li>\n<li>客户端保存 Token 到存储器</li>\n</ol>\n<p><strong>Check Access Token 客户端使用 Token 访问资源</strong></p>\n<ol>\n<li>客户端在请求头带上 Token，访问资源服务端</li>\n<li>资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）</li>\n<li>资源服务端校验成功，返回资源</li>\n</ol>\n<p>移动应用微信登录是基于 OAuth2.0 协议标准构建的微信 OAuth2.0 授权登录系统，在微信开放平台注册开发者账号，并拥有已审核通过的移动应用，并获得相应的 AppID 和 AppSecret，申请微信登录且通过审核后，可开始接入流程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据 code 参数</span><br><span class=\"line\">2. 通过 code 参数加上 AppId 和 AppSecret 等，通过 API 换取 access_token</span><br><span class=\"line\">3. 通过 access_token 进行接口调用，获取用户基本数据资源或帮助用户实现基本操作</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.mrsingsing.com/authentication-wx-oauth2-access-token.png\" alt=\"微信 OAuth2.0 获取 access_token 时序图\"></p>\n<p>详情可以参阅 <a href=\"https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html\" target=\"_blank\" rel=\"noopener\">微信登录功能 - 移动应用微信登录开发指南</a>，这里的实现就是授权码模式。</p>\n<h3 id=\"隐式授权模式\"><a href=\"#隐式授权模式\" class=\"headerlink\" title=\"隐式授权模式\"></a>隐式授权模式</h3><p><img src=\"http://img.mrsingsing.com/authentication-implicit-grant.jpg\" alt=\"隐式授权模式流程图\"></p>\n<p>隐式授权模式大致可以分为两部分：</p>\n<ol>\n<li>Client Side：用户+客户端与授权服务端的交互</li>\n<li>Check Access Token：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互</li>\n</ol>\n<p>整个流程就是：客户端让用户登录授权服务端换取 Token，客户端使用 Token 访问资源</p>\n<p><strong>Client Side 客户端让用户登录授权服务端换 Token</strong></p>\n<ol>\n<li>客户端（浏览器或单页应用）将 <code>client_id + 授权模式标识（grant_type）+ 回调地址（redirect_url）</code> 拼成 URL 访问授权服务端</li>\n<li>授权服务端跳转用户登录界面，用户登录</li>\n<li>用户授权</li>\n<li>授权服务端 <code>访问回调地址</code> 返回 Token 给客户端</li>\n</ol>\n<p><strong>Check Access Token 客户端使用 Token 访问资源</strong></p>\n<ol>\n<li>客户端在请求头附带 Token 访问资源服务端</li>\n<li>资源服务端收到请求，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）</li>\n<li>资源服务端校验成功，返回资源</li>\n</ol>\n<h3 id=\"密码模式\"><a href=\"#密码模式\" class=\"headerlink\" title=\"密码模式\"></a>密码模式</h3><p><img src=\"http://img.mrsingsing.com/authentication-resource-owner-password-credentials-grant.jpg\" alt=\"密码模式流程图\"></p>\n<p>密码模式的授权流程可以分为两部分：</p>\n<ol>\n<li>Client Side：用户与客户端的交互，客户端与授权服务端的交互</li>\n<li>Check Access Token’：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互</li>\n</ol>\n<p>整个流程就是：用户在客户端提交账号密码换取 Token，客户端使用 Token 访问资源</p>\n<p><strong>Client Server 用户在客户端提交账号密码换取 Token</strong></p>\n<ol>\n<li>客户端要求用户登录</li>\n<li>用户输入密码，客户端将表单中添加客户端的 <code>client_id + client_secret</code> 发送给授权服务端颁发 Token 令牌</li>\n<li>授权服务端校验用户名、用户密码、<code>client_id</code> 和 <code>client_secret</code>，均通过后返回 Token 给客户端</li>\n<li>客户端保存 Token</li>\n</ol>\n<p><strong>Check Access Token 客户端使用 Token 访问资源</strong></p>\n<ol>\n<li>客户端在请求头带上 Token，访问资源服务端</li>\n<li>资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）</li>\n<li>资源服务端校验成功，返回资源</li>\n</ol>\n<h3 id=\"客户端模式\"><a href=\"#客户端模式\" class=\"headerlink\" title=\"客户端模式\"></a>客户端模式</h3><p><img src=\"http://img.mrsingsing.com/authentication-client-credentials-grant.jpg\" alt=\"客户端模式流程图\"></p>\n<p>客户端模式的授权流程可以分为两部分：</p>\n<ol>\n<li>Server Side：客户端与授权服务端之间的交互</li>\n<li>Check Access Token’：客户端与资源服务端，资源服务端与授权服务端之间的交互</li>\n</ol>\n<p>整个流程就是：客户端使用自己的标识换取 Token，客户端使用 Token 访问资源</p>\n<p><strong>Client Server 客户端使用自己的标识换取 Token</strong></p>\n<ol>\n<li>客户端使用 <code>client_id + client_secret + 授权模式标识</code> 发送给授权服务端颁发 Token 令牌</li>\n<li>授权服务端校验通过后返回 Token 给客户端</li>\n<li>客户端保存 Token</li>\n</ol>\n<p><strong>Check Access Token 客户端使用 Token 访问资源</strong></p>\n<ol>\n<li>客户端在请求头带上 Token，访问资源服务端</li>\n<li>资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）</li>\n<li>资源服务端校验成功，返回资源</li>\n</ol>\n<h3 id=\"授权模式选型\"><a href=\"#授权模式选型\" class=\"headerlink\" title=\"授权模式选型\"></a>授权模式选型</h3><p>考虑到授权场景的多样性，可以参考以下两种选型方式：</p>\n<ul>\n<li>按授权需要的多端情况</li>\n<li>按客户端类型与所有者</li>\n</ul>\n<p>按授权需要的多端情况：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">模式</th>\n<th style=\"text-align:left\">需要前端</th>\n<th style=\"text-align:left\">需要后端</th>\n<th style=\"text-align:left\">需要用户响应</th>\n<th style=\"text-align:left\">需要客户端密钥</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">授权码模式 Authorization Code</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">隐式授权模式 Implicit Grant</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✗</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✗</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">密码授权模式 Password Grant</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">客户端授权模式 Client Credentials</td>\n<td style=\"text-align:left\">✗</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✗</td>\n<td style=\"text-align:left\">✓</td>\n</tr>\n</tbody>\n</table>\n<p>按照客户端类型与访问令牌所有者分类：</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-oauth2-mode-selection.jpg\" alt=\"OAuth2.0 模式选型\"></p>\n<h2 id=\"联合登录\"><a href=\"#联合登录\" class=\"headerlink\" title=\"联合登录\"></a>联合登录</h2><p>联合登录指同时包含多种凭证校验的登录服务，同时，也可以理解为使用第三方凭证进行校验的登录服务。这个概念有点像 OAuth2.0 的认证方式。</p>\n<p>最经典的莫过于 APP 内嵌 H5 的使用场景，当用户从 APP 进入内嵌的 H5 时，我们希望 APP 内已登录的用户能够访问到 H5 内受限的资源，而未登录的用户则需要登录后访问。</p>\n<p>这里思路主要有两种，一种是原生跳转内嵌 H5 页面时，将登录态 Token 附加在 URL 参数上，另一种则是内嵌 H5 主动通过与原生客户端制定的协议获取应用内的登录状态。</p>\n<h2 id=\"扫码登录\"><a href=\"#扫码登录\" class=\"headerlink\" title=\"扫码登录\"></a>扫码登录</h2><p>二维码也称为二维条码，是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。一维条码的宽度记载着数据，而其长度没有记载数据。二维码的长度、宽度均记载着数据。二维码有一维条码没有的 <strong>定位点*- 和 </strong>容错机制**。容错机制在即使没有识别到全部的条码、或是说条码有污损时，也可以正确地还原条码上的信息。</p>\n<p>扫码登录通常见于移动端 APP 中，基本操作流程是让已登录用户主动扫描二维码，以使 PC 端的同款应用得以快速登录的方式，常见的具备扫码登录的应用有微信、钉钉、支付宝等。</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-scan-qrcode-login-workflow.jpg\" alt=\"扫码登录流程图\"></p>\n<p>扫码登录可以分为三个阶段：待扫码、已扫码待确认和已确认。</p>\n<h3 id=\"待扫码阶段\"><a href=\"#待扫码阶段\" class=\"headerlink\" title=\"待扫码阶段\"></a>待扫码阶段</h3><p><strong>待扫码阶段</strong>即上述流程图中 1~5 的阶段，亦即生成二维码阶段，这个阶段与移动端没有关系，主要是 PC 端与服务端进行交互的过程。</p>\n<p>首先 PC 端携带设备信息向服务端发起了生成二维码请求，服务端接收到请求后生成 <code>UUID</code> 作为二维码 ID，并将 UUID 与 <code>PC 端的设备信息</code> 关联起来存储在 Redis 服务器中，然后返回给 PC 端。</p>\n<p>当 PC 端收到二维码 ID 之后，将二维码 ID 以 <code>二维码的形式</code> 展示，等待移动端扫码。此时 PC 端开始轮询查询二维码状态，直到登录成功。当然除了使用轮询查询，也能使用 WebSocket 实现查询/推送二维码状态的需求。如果移动端未扫描，那么一段时间后二维码会自动失效。</p>\n<h3 id=\"已扫码待确认阶段\"><a href=\"#已扫码待确认阶段\" class=\"headerlink\" title=\"已扫码待确认阶段\"></a>已扫码待确认阶段</h3><p><strong>已扫码待确认阶段</strong>亦即流程图中的 6~10 的阶段，在 PC 端登录微信时，手机扫码后，PC 端的二维码会显示为已扫码，并提示需要在手机上确认，这个阶段是移动端与服务端交互的过程。</p>\n<p>移动端扫描二维码后，会自动获取到二维码 ID，并将移动端登录的信息凭证（Token）和二维码 ID 作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。</p>\n<p>服务端接受请求后，会将 <code>Token 与二维码 ID</code> 关联，为什么需要关联呢？因为，当我们在使用微信时，移动端退出时，PC 端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个一次性 Token，这个 Token 会返回给移动端，一次性 Token 用作确认时的凭证。</p>\n<p>PC 端轮询到二维码的状态已经发生变化，会将 PC 端的二维码更新为已扫描，请确认。</p>\n<h3 id=\"已确认阶段\"><a href=\"#已确认阶段\" class=\"headerlink\" title=\"已确认阶段\"></a>已确认阶段</h3><p><strong>已确认阶段</strong>为流程图中的步骤 11~15，这是扫码登录的最后阶段，用户确认登录，移动端携带上一步中获取的 <code>临时 Token</code> 发送给服务端校验。服务端校验完成后，会更新二维码状态，并且给 PC 端生成一个 <code>正式的 Token</code>，后续 PC 端就是持有这个 Token 访问服务端。</p>\n<p>PC 端的定时器，轮询到二维码状态为已登录状态，并且会获取到了生成的 Token，完成登录，后续访问都基于 Token 完成。</p>\n<p>在服务端会跟移动端一样，维护着 Token 跟二维码、PC 设备信息、账号等信息。</p>\n<h2 id=\"一键登录\"><a href=\"#一键登录\" class=\"headerlink\" title=\"一键登录\"></a>一键登录</h2><p>最传统的登录方式莫过于提供账号密码校验，但这毫无疑问需要消耗用户的记忆成本。随着无线互联的发展以及手机卡实名制的推广，手机号俨然已成为特别的身份证明，与账号密码相比，手机号可以更好地验证用户的身份，防止恶意注册。</p>\n<p>但是手机号注册还是需要一系列繁琐的操作：输入手机号、等待短信验证码、输入验证码、点击登录。整个流程少说二十秒，而且如果收不到短信，也就登录补了，这类问题有可能导致潜在的用户流失。</p>\n<p>短信验证码的作用就是证明当前操作页面的用户与输入手机号的用户为相同的人，那么实际上只要我们能够获取到当前手机的手机号并与输入的手机号对比匹配后便能达到校验的功能。但是，无论是原生 APP 还是 H5 网页都是不具备直接获取用户手机号的功能的，而这种需求运营商能够通过手机 SIM 卡的流量数据查询。随着运营商开放了相关的服务，我们能够接入运营商提供的 SDK 并付费使用相关的服务。</p>\n<p>下图为一键登录的流程图：</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-one-click-login-workflow.png\" alt=\"一键登录流程图\"></p>\n<p>主要步骤：</p>\n<ol>\n<li>SDK 初始化：调用 SDK 方法，传入平台配置的 AppKey 和 AppSecret</li>\n<li>唤起授权页：调用 SDK 唤起授权接口，SDK 会先向运营商发起获取手机号掩码的请求，请求成功后跳到授权页。授权页会显示手机号掩码以及运营商协议给用户确认。</li>\n<li>同意授权并登录：用户同意相关协议，点击授权页面的登录按钮，SDK 会请求本次取号的 Token，请求成功后将 Token 返回给客户端</li>\n<li>取号：将获取到的 Token 发送到自己的服务器，由服务端携带 Token 调用运营商一键登录的接口，调用陈工就返回手机号码。服务端用手机号进行登录或注册操作，返回操作结果给客户端，完成一键登录。</li>\n</ol>\n<p>由于国内三大运营商各自有独立的 SDK，所以会导致兼容方面的工作会特别繁琐。如果要采用一键登录的方案，不妨采用第三方提供了号码认证服务，下列几家供应商都拥有手机号码认证能力：</p>\n<ul>\n<li><a href=\"https://help.aliyun.com/product/75010.html\" target=\"_blank\" rel=\"noopener\">阿里 - 号码认证服务</a></li>\n<li><a href=\"http://shanyan.253.com/\" target=\"_blank\" rel=\"noopener\">创蓝 - 闪验</a></li>\n<li><a href=\"https://www.jiguang.cn/identify\" target=\"_blank\" rel=\"noopener\">极光 - 极光认证</a></li>\n<li><a href=\"https://www.mob.com/mobService/secverify\" target=\"_blank\" rel=\"noopener\">mob - 秒验</a></li>\n</ul>\n<p>在认证过程中，需要用户打开蜂窝网络，如果手机设备没有插入 SIM 卡、或者关闭蜂窝网络的情况下，是无法完成认证的。所以就算接入一键登录，还是要兼容传统的登录方式，允许用户在失败的情况下，仍能正常完成登录流程。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>鉴权授权是计算机领域无法躲避的技术议题，认证、授权、鉴权和权限控制是围绕这个议题的几个关键概念：认证（Identification）是指根据声明者提供的资料，确认声明者身份；授权（Authorization）则是资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作；鉴权（Authentication）指的对声明者所声明的真实性进行校验。从授权角度出发，会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。</p>\n<ul>\n<li>Authorization 决定你是否有权限去获取资源</li>\n<li>Authentication 校验你说你是谁</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">授权 -&gt; 鉴权 -&gt; 权限控制</span><br></pre></td></tr></table></figure>\n<p>花了一周时间将登录鉴权授权方面的知识总结了一番，确认对各种方案的实施细节，以及设计原理、方案优劣都有了更深一层的了解，在学习的过程中不免会联想到无论是生活中各种类似的场景，也会想到计算机领域中诸如 Linux 系统、数据库等权限控制相关机制。这是个融汇贯通的学习过程，发现这种针对某个议题的体系式整理，对前端技术体系中各个独立的点连通起到了不错的效果。</p>\n<hr>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Basic_access_authentication\" target=\"_blank\" rel=\"noopener\">📖 Wikipedia：Basic Access Authentication</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication\" target=\"_blank\" rel=\"noopener\">📖 HTTP 身份验证 Authentication</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">📖 RFC 7019 - JSON Web Token（JWT）</a></li>\n<li><a href=\"https://apereo.github.io/cas/4.2.x/index.html\" target=\"_blank\" rel=\"noopener\">📖 CAS 官方文档</a></li>\n<li><a href=\"https://juejin.im/entry/5ac175baf265da239e4e3999\" target=\"_blank\" rel=\"noopener\">📝 一文读懂 HTTP Basic 身份认证</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/43527568\" target=\"_blank\" rel=\"noopener\">📝 你在用 JWT 代替 Session？</a></li>\n<li><a href=\"https://juejin.im/post/5cefad23e51d4510774a87f4#heading-4\" target=\"_blank\" rel=\"noopener\">📝 用户认证：基于 JWT 和 Session 的区别和优缺点</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/85873228\" target=\"_blank\" rel=\"noopener\">📝 JWT 身份认证优缺点分析以及常见问题解决方案</a></li>\n<li><a href=\"https://juejin.im/post/5a002b536fb9a045132a1727\" target=\"_blank\" rel=\"noopener\">📝 前端需要了解的 SSO 与 CAS 知识</a></li>\n<li><a href=\"https://juejin.im/post/5b51f39b5188251a9f24a264\" target=\"_blank\" rel=\"noopener\">📝 不务正业的前端之 SSO（单点登录）实践</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/102898335\" target=\"_blank\" rel=\"noopener\">📝 面试题：给我说一下你项目中的单点登录是如何实现的</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/60376970\" target=\"_blank\" rel=\"noopener\">📝 单点登录系统</a></li>\n<li><a href=\"https://www.cnblogs.com/ywlaker/p/6113927.html\" target=\"_blank\" rel=\"noopener\">📝 单点登录原理与简单实现</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/92263756\" target=\"_blank\" rel=\"noopener\">📝 单点登录 LDAP 协议</a></li>\n<li><a href=\"https://www.zhihu.com/question/21387523\" target=\"_blank\" rel=\"noopener\">📝 信任登录与联合登录有什么差异？</a></li>\n<li><a href=\"https://juejin.im/entry/5a93506e6fb9a0634c268da8\" target=\"_blank\" rel=\"noopener\">📝 OAuth2.0 深入了解：以微信开发平台统一登录为例</a></li>\n<li><a href=\"https://www.cnblogs.com/hellxz/p/oauth2_process.html\" target=\"_blank\" rel=\"noopener\">📝 OAuth 2.0 概念及授权流程梳理</a></li>\n<li><a href=\"https://juejin.im/post/5d15d3336fb9a07efb69994f\" target=\"_blank\" rel=\"noopener\">📝 论 H5 嵌入 APP 的联合登录的解决方案</a></li>\n<li><a href=\"https://juejin.im/post/5e83e716e51d4546c27bb559\" target=\"_blank\" rel=\"noopener\">📝 聊一聊二维码扫描登录原理</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/gA0JQp4j2ym9qOyQkC3qkA\" target=\"_blank\" rel=\"noopener\">📝 阿里面试官：分别说说微信和淘宝扫码登录背后的实现原理</a></li>\n<li><a href=\"https://juejin.im/post/5d197adff265da1bb31c4fa9\" target=\"_blank\" rel=\"noopener\">📝 用户一键登录，如何实现</a></li>\n<li><a href=\"https://learnku.com/articles/30704\" target=\"_blank\" rel=\"noopener\">📝 微服务架构下的鉴权，怎么做更优雅？</a></li>\n<li><a href=\"http://www.hyhblog.cn/2018/04/25/user_login_auth_terms/\" target=\"_blank\" rel=\"noopener\">📝 认证、授权、鉴权和权限控制</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>登录鉴权是互联网信息交互中永恒的话题，毕竟在工作中几乎每天都会接触到，适逢最近需要对现有的系统平台进行 SSO 的流程改造，所以趁这个机会好好总结前端工程师接触到的登录方式。</p>\n<p>鉴权也叫身份验证（Authentication），是指验证用户是否拥有访问系统的权利。在日常的生活中，身份验证随处可见，比如：进入高铁站候车室、机场候机楼需要检查票据和身份证件；游玩主题乐园、名胜风景区需要购买门票，并由入口处人员鉴定有效后方可拥有进入园区游玩的权利。</p>\n<p>而在计算机领域中，身份验证的方法有很多种：基于共享密钥的身份验证、基于生物学特征的身份验证和基于公开密钥加密算法的身份验证。不同的身份验证方法，安全性也各自不同。</p>\n<p>下面我将从前端开发工程师的角度出发，梳理 Web 应用前后端数据交互中的各种鉴权方案。</p>","more":"<p>以下为本文大纲：</p>\n<ul>\n<li>HTTP 基本认证</li>\n<li>Session-Cookie 认证<ul>\n<li>koa-session</li>\n</ul>\n</li>\n<li>Token 认证<ul>\n<li>JWT 认证</li>\n<li>koa-jwt</li>\n</ul>\n</li>\n<li>OAuth2 开放授权</li>\n<li>SSO 单点登录</li>\n<li>LDAP 认证登录</li>\n<li>扫码登录</li>\n<li>联合登录</li>\n<li>信任登录</li>\n<li>易混淆概念分析</li>\n</ul>\n<h2 id=\"HTTP-基本认证\"><a href=\"#HTTP-基本认证\" class=\"headerlink\" title=\"HTTP 基本认证\"></a>HTTP 基本认证</h2><p>在 HTTP 中，基本认证方案（Basic Access Authentication）是允许 HTTP 用户代理（通常指的就是网页浏览器）在请求时，通过用户提供用户名和密码的方式，实现对用户身份的验证。</p>\n<p>基本认证中，最关键的是四个要素：</p>\n<ol>\n<li><code>uid</code>：用户的 ID，也就是我们常说的用户名</li>\n<li><code>password</code>：密码</li>\n<li><code>realm</code>：领域，其实就是指当前认证的保护范围</li>\n</ol>\n<p>在进行基本认证的过程中，HTTP 的请求头字段会包含 Authorization 字段，<code>Authorization: Basic &lt;用户凭证&gt;</code>，该用户凭证是 <code>用户名</code> 和 <code>密码</code> 的组合而成的 <strong>Base64 编码</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /securefiles/ HTTP/1.1</span><br><span class=\"line\">Host: www.example.com</span><br><span class=\"line\">Authorization: Basic aHR0cHdhdGNoOmY=</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.mrsingsing.com/authentication-http-basic-access-authentication.jpg\" alt=\"HTTP 基本认证流程图\"></p>\n<ol>\n<li>用户在浏览器中访问了受限制的网页资源，但是没有提供用户的身份信息</li>\n<li>服务端接收到请求后返回 401 应答码（Unauthorized，未被授权的）要求进行身份验证，并附带提供了一个认证域（Access Authentication）<code>WWW-Authenticate</code> 说明如何进行验证的方法，例如 <code>WWW-Authenticate: Basic realm=&quot;Secure Area&quot;</code>，<code>Basic</code> 就是验证的模式，而 <code>realm=&quot;Secure Area&quot;</code> 则为保护域（告知认证的范围），用于与其他请求 URI 作区别</li>\n<li>浏览器收到应答后，会显示该认证域给用户并提示输入用户名和密码，此时用户可以选择录入信息后确定或取消操作</li>\n<li>用户输入了用户名和密码后，浏览器会在原请求头新增认证消息字段 <code>Authorization</code> 并重新发送请求，过程如下：</li>\n</ol>\n<ul>\n<li>将用户名和密码拼接为 <code>用户名:密码</code> 格式的字符串</li>\n<li>如果服务器 <code>WWW-Authenticate</code> 字段有指定编码，则将字符串编译成对应的编码</li>\n<li>将字符串编码为 Base64</li>\n<li>拼接 <code>Basic</code>，设置为 <code>Authorization</code> 字段，假设用户名为 <code>admin</code>，密码为 <code>password</code>，则拼接后为 <code>admin:password</code>，使用 Base64 编码后为 <code>YWRtaW46cGFzc3dvcmQ=</code>，那么最终在 HTTP 头部里会是这样：<code>Authorization: Basic YWRtaW46cGFzc3dvcmQ=</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Buffer.from(<span class=\"string\">'admin:password'</span>).toString(<span class=\"string\">'base64'</span>);</span><br><span class=\"line\"><span class=\"comment\">// YWRtaW46cGFzc3dvcmQ=</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>服务端接收了该认证后并返回了用户请求的网页资源。如果用户凭证非法或无效，服务器可能会再次返回 401 应答码，客户端就需要再次输入用户名和密码</li>\n</ol>\n<p>服务端验证的步骤：</p>\n<ol>\n<li>根据用户请求资源的地址，确定资源对应的 <code>realm</code></li>\n<li>解析 Authorization 请求首部，获得用户名和密码</li>\n<li>判断用户是否有访问该 <code>realm</code> 的权限</li>\n<li>验证用户名、密码是否匹配</li>\n</ol>\n<blockquote>\n<p>当然，也有可能在首次请求中，在请求头附带了认证消息头，那么就不需要再作身份信息的录入步骤</p>\n</blockquote>\n<p>优点：</p>\n<ul>\n<li>唯一的优点是实现简单，被广泛支持</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>由于用户名和密码是以明文的形式在网络中进行传输，容易被嗅探器探测到，所以基本验证方案并不安全</li>\n<li>除此之外，Base64 编码并非加密算法，其无法保证安全与隐私，这里仅用于将用户名和密码中的不兼容的字符转换为均与 HTTP 协议兼容的字符集</li>\n<li>即使认证内容无法被解码为原始的用户名和密码也是不安全的，恶意用户可以再获取了认证内容后使用其不断的享服务器发起请求，这就是所谓的重放攻击</li>\n<li>该方案除了存在安全缺陷外，Basic 认证还存在无法吊销认证的情况</li>\n</ul>\n<blockquote>\n<p>HTTP 的基本验证方案应与 HTTPS / TLS 协议搭配使用。加入没有这些安全方面的增强，那么基本验证方案不应该被用来保护敏感或者极具价值的信息。</p>\n</blockquote>\n<p>应用场景：内部网络，或者对安全要求不是很高的网络</p>\n<h2 id=\"Session-Cookie-认证\"><a href=\"#Session-Cookie-认证\" class=\"headerlink\" title=\"Session-Cookie 认证\"></a>Session-Cookie 认证</h2><p><code>Session-Cookie</code> 认证是利用服务端的 Session（会话）和浏览器（客户端）的 Cookie 来实现的前后端通信认证模式。</p>\n<p>由于 HTTP 请求时是无状态的，服务端正常情况下无法得知请求发送者的身份，这个时候我们如果要记录状态，就需要在服务端创建 Session 会话，将相同客户端的请求都维护在各自的会话记录中，每当请求到达服务端时，先校验请求中的用户标识是否存在于 Session 中，如果有则表示已经认证成功，否则表示认证失败。</p>\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为追踪（如跟踪分析用户行为等）</li>\n</ul>\n<p>下图为 Session-Cookie 认证的工作流程图：</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-session-cookie.jpg\" alt=\"Session-Cookie 认证流程图\"></p>\n<ol>\n<li>服务端在接收到来自客户端的首次访问时，会自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证 <code>session_id</code>（通常称为 <code>sid</code>），并在响应头 <code>Set-Cookie</code> 中设置这个唯一标识符</li>\n<li>签名，对 <code>sid</code> 进行加密处理，服务端会根据这个 <code>secret</code> 密钥进行解密（非必需步骤）</li>\n<li>浏览器收到请求响应后会解析响应头，并自动将 <code>sid</code> 保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息</li>\n<li>服务端在接收客户端请求时会去解析请求头 Cookie 中的 <code>sid</code>，然后根据这个 <code>sid</code> 去找服务端保存的该客户端的 <code>sid</code>，然后判断该请求是否合法</li>\n<li>一旦用户登出，服务端和浏览器将会同时销毁各自保存的会话 ID，服务端会根据数据库验证会话身份凭证，如果验证通过，则继续处理</li>\n</ol>\n<blockquote>\n<p>⚠️ 注意，这里相对于使用服务端，在另一端我使用了 <code>浏览器</code> 而非客户端，主要是因为 Cookie 是仅在浏览器中存在的报文字段，诸如移动原生 APP 是无法解析存储 Cookie 请求/响应头的。</p>\n</blockquote>\n<p>优点：</p>\n<ol>\n<li>Cookie 简单易用，在不受用户干预或过期处理的情况下，Cookie 通常是客户端上持续时间最长的数据保留形式</li>\n<li>Session 数据存储在服务端，相较于 JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的 Session 就可以了，方便管理</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被 CSRF 等攻击）</li>\n<li>Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能</li>\n<li>用户认证后，服务端做认证记录，如果认证的记录被保存在内存中，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权资源，这样在分布式的应用上，相应的限制了负载均衡的能力，也意味着限制了应用的扩展能力</li>\n</ol>\n<h3 id=\"koa-session\"><a href=\"#koa-session\" class=\"headerlink\" title=\"koa-session\"></a>koa-session</h3><p>没有代码谈再多都是空中楼阁，下面尝试在 Koa 中使用 <code>koa-session2</code> 中间件实现 Session-Cookie 这种鉴权方式。</p>\n<p>在实际项目中，与客户端的会话信息往往需要在服务外再设立额外的外部存储机制，外部存储可以是任何的存储机制，例如内存数据结构，也可以是本地的文件系统，或是使用诸如 Redis 等 NoSQL 数据库。</p>\n<p><code>koa-session2</code> 自身实现的存储方式为保存在内存中的，而下面我们就介绍一种拓展 <code>koa-session2</code> 结合 Redis 实现 Session-Cookie 认证方式的方案：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Redis = <span class=\"built_in\">require</span>(<span class=\"string\">'ioredis'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; Store &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-session2'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisStore</span> <span class=\"keyword\">extends</span> <span class=\"title\">Store</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 Redis</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.redis = <span class=\"keyword\">new</span> Redis();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 根据 sid 获取用户信息</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"keyword\">get</span>(sid, ctx) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.redis.get(<span class=\"string\">`SESSION: <span class=\"subst\">$&#123;sid&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 更新 sid 的用户信息</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"keyword\">set</span>(session, &#123; sid = <span class=\"keyword\">this</span>.getID(<span class=\"number\">24</span>), maxAge = <span class=\"number\">1000000</span> &#125; = &#123;&#125;, ctx) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.redis.set(<span class=\"string\">`SESSION: <span class=\"subst\">$&#123;sid&#125;</span>`</span>, <span class=\"built_in\">JSON</span>.stringfy(session));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sid;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 销毁会话信息</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> destroy(sid, ctx) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.redis.del(<span class=\"string\">`SESSION: <span class=\"subst\">$&#123;sid&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = RedisStore;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> session = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-session2'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Store = <span class=\"built_in\">require</span>(<span class=\"string\">'./Store.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(</span><br><span class=\"line\">  session(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 种下 Cookie 的键名</span></span><br><span class=\"line\">    key: <span class=\"string\">'SESSIONID'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 禁止浏览器中 JS 脚本修改 Cookie</span></span><br><span class=\"line\">    httpOnly: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"comment\">// Cookie 加密签名机制</span></span><br><span class=\"line\">    signed: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    store: <span class=\"keyword\">new</span> Store(),</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Ignore favicon.ico</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.path === <span class=\"string\">'/favicon.ico'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> user = <span class=\"keyword\">this</span>.session.user;</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx.session.view = <span class=\"string\">'index'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果设置了会话有效期刷新会话有效期</span></span><br><span class=\"line\">  ctx.session.refresh();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在 <code>koa-session</code> 中会话标识的实现仅是根据时间戳生成的随机字符串，如果担心 Cookie 传输中被恶意篡改或暴露信息，可以通过加入更多标识元素，例如 IP 地址、设备 ID 等。</p>\n<p>Koa 的 Cookie 实现默认带了安全机制，就是 <code>signed</code> 选项为 <code>true</code> 时，会自动给 Cookie 添加一个 SHA256 的签名，类似 <code>koa:sess=pjadZtLAVtiO6-Haw1vnZZWrRm8</code>，从而防止 Cookie 被篡改。</p>\n<p>至于担心的 Session 信息泄漏问题，<code>koa-session</code> 允许用户自定义编解码方法，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> encode = <span class=\"function\"><span class=\"params\">json</span> =&gt;</span> CrytoJS.AES.encrypt(json, <span class=\"string\">'Secret Passphrase'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decode = <span class=\"function\"><span class=\"params\">encrypted</span> =&gt;</span> CryptoJS.AES.decrypt(encrypted, <span class=\"string\">'Secret Passphrase'</span>);</span><br></pre></td></tr></table></figure>\n<p><code>koa-session</code> 为 Koa 官方实现的中间件，功能强大，考虑的情况比较多，所以实现相对复杂。</p>\n<p>而 <code>koa-session2</code> 是社区实现的中间件，简洁易用。如果对实现有兴趣的同学可以在 Github 找到源码阅读。</p>\n<ul>\n<li><a href=\"https://github.com/koajs/session\" target=\"_blank\" rel=\"noopener\">koa-session</a></li>\n<li><a href=\"https://github.com/Secbone/koa-session2\" target=\"_blank\" rel=\"noopener\">koa-session2</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000013039187\" target=\"_blank\" rel=\"noopener\">koa-session 学习笔记</a></li>\n<li><a href=\"https://www.jianshu.com/p/c1eff1b50d23\" target=\"_blank\" rel=\"noopener\">koa-session 的内部实现</a></li>\n<li><a href=\"https://juejin.im/post/5c148fd551882530544f341f\" target=\"_blank\" rel=\"noopener\">从 koa-session 源码解读 session 原理</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000012412299\" target=\"_blank\" rel=\"noopener\">从 koa-session 中间件源码学习 cookie 与 session</a></li>\n</ul>\n<h2 id=\"Token-认证\"><a href=\"#Token-认证\" class=\"headerlink\" title=\"Token 认证\"></a>Token 认证</h2><p>随着 Restful API、微服务的兴起，基于 Token 的认证现在已经越来越普遍。Token 和 Session-Cookie 认证方式中的 Session ID 不同，并非只是一个标识符。Token 一般会包含 <code>用户的相关信息</code>，通过验证 Token 不仅可以完成身份校验，还可以获取预设的信息。像 Twitter、微信、QQ、Github 等公有 API 都是基于这种方式进行认证的，一些开发框架如 OpenStack、Kubernetes 内部 API 调用也是基于 Token 的认证。</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-token-authencation.jpg\" alt=\"Token 认证流程图\"></p>\n<p>基于 Token 的身份验证方法：</p>\n<ol>\n<li>用户输入登录信息并请求登录</li>\n<li>服务端收到请求，验证用户输入的登录信息</li>\n<li>验证成功后，服务端会 <code>签发</code>一个 Token（通常包含用户基础信息、权限范围和有效时间等），并把这个 Token 返回给客户端</li>\n<li>客户端收到 Token 后需要把它存储起来，比如放在 localStorage 或 sessionStorage 里（一般不放 Cookie 因为可能会有跨域问题，以及安全性问题）</li>\n<li>后续客户端每次向服务端请求资源的时候，将 Token 附带于 HTTP 请求头 Authorization 字段中发送请求</li>\n<li>服务端收到请求后，去校验客户端请求中 Token，如果验证成功，就向客户端返回请求的数据，否则拒绝返还</li>\n</ol>\n<p>优点：</p>\n<ul>\n<li><strong>服务端无状态</strong>：Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态</li>\n<li><strong>性能相对较好</strong>：因为在验证 Token 时不用再去访问数据库或远程服务进行权限校验，自然可以提升不少性能</li>\n<li>支持移动设备</li>\n<li>支持跨域跨程序调用，因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题</li>\n<li>有效避免 CSRF 攻击（因为不需要 Cookie），但是会存在 XSS 攻击中被盗的风险，但是可选择 Token 存储在标记为 <code>httpOnly</code> 的 Cookie 中，能够有效避免浏览器中的 JS 脚本对 Cookie 的修改</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>占带宽：正常情况下比 <code>sid</code> 更大，消耗更多流量，挤占更多宽带</li>\n<li>性能问题：相比较于 Session-Cookie 认证来说，Token 需要服务端花费更多时间和性能来对 Token 进行解密验证，其实 Token 相较于 Session—Cookie 来说就是一个时间换空间的方案</li>\n</ul>\n<blockquote>\n<p>Session-Cookie 认证和 Token 认证的比较</p>\n</blockquote>\n<p>Session-Cookie 认证和 Token 认证有很多类似的地方，但是 Token 认证更像是 Session-Cookie 认证的升级改良版。</p>\n<p>Session-Cookie 认证仅仅靠的是 <code>sid</code> 这个生成的唯一标识符，服务端需要根据客户端传来的 <code>sid</code> 查询保存在服务端 Session 里保存的登录状态，当存储的信息数据量超过一定量时会影响服务端的处理效能。而且 Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的。</p>\n<p>而 Token 认证机制特别的是，实质上登录状态是用户登录后存放在客户端的，服务端不会充当保存 <code>用户信息凭证</code> 的角色，当每次客户端请求时附带该凭证，只要服务端根据定义的规则校验是否匹配和合法即可，客户端存储的手段也不限于 Cookie，可以使用 Web Storage 等其他缓存方式。简单来说，Session-Cookie 机制限制了客户端的类型，而 Token 验证机制丰富了客户端类型。</p>\n<p>除此之外，Token 验证比较灵活，除了常见的 JWT 外，可以基于 Token 构建专门用于鉴权的微服务，用它向多个服务的请求进行统一鉴权。</p>\n<h3 id=\"JWT-认证\"><a href=\"#JWT-认证\" class=\"headerlink\" title=\"JWT 认证\"></a>JWT 认证</h3><p>JWT（JSON Web Token）是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登录成功后将相关信息组成 JSON 对象，然后对这个对象进行某种方式的加密，返回给客户端，客户端在下次请求时带上这个 Token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。</p>\n<p>JWT 是 JSON 格式的被加密了的字符串：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON Data + Signature = JWT</span><br></pre></td></tr></table></figure>\n<p>JWT 对象通常由三部分组成：</p>\n<ol>\n<li>头部（Headers）：包括类别（typ）、加密算法（alg）</li>\n</ol>\n<p>头部用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"alg\"</span>: <span class=\"string\">\"HS256\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"typ\"</span>: <span class=\"string\">\"JWT\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们说明了这是一个 JWT，并且我们所使用的签名算法是 HS256 算法。</p>\n<ol start=\"2\">\n<li>Claims：包括需要传递的用户信息</li>\n</ol>\n<p>载荷可以用来存放一些不敏感的信息</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"iss\"</span>: <span class=\"string\">\"Jehoshaphat Tse\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"iat\"</span>: <span class=\"number\">1441593502</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"exp\"</span>: <span class=\"number\">1441594722</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"aud\"</span>: <span class=\"string\">\"www.example.com\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"sub\"</span>: <span class=\"string\">\"mrsingsing@example.com\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"John Doe\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"admin\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面的前五个字段都是由 JWT 的标准所定义的:</p>\n<ul>\n<li><code>iss</code>：该 JWT 的签发者</li>\n<li><code>sub</code>：该 JWT 所面向的用户</li>\n<li><code>aud</code>：接收该 JWT 的一方</li>\n<li><code>exp</code>（expires）：什么时候过期，这是 Unix 时间戳</li>\n<li><code>iat</code>（issued at）：在什么时候签发的。把头部和载荷分别进行 Base64 编码后得到两个字符串，然后再将这两个编码后的字符串用英文句号连接起来（头部在前），形成新的字符</li>\n</ul>\n<ol start=\"3\">\n<li>Signature：</li>\n</ol>\n<p>最后，将上述拼接后的字符串，用 <code>alg</code> 指定的算法（HS256）与私有密钥（Secret）进行加密。加密后的内容也是字符串，最后这个字符串就是签名，把这个签名拼接在刚才的字符串后面就能得到完整的 JWT。Header 部分和 Claims 部分如果被篡改，由于篡改者不知道密钥是什么，也无法生成新的 Signature 部分，服务端也就无法通过，在 JWT 中，消息体是透明的，使用签名可以保证消息不被篡改。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HMACSHA256(base64UrlEncode(Headers) + <span class=\"string\">'.'</span> + base64UrlEncode(Claims), SECREATE_KEY);</span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>不需要在服务端保存会话信息（RESTful API 的原则之一就是无状态），所以易于应用的扩展，即信息不保存在服务端，不会存在 Session 扩展不方便的情况</li>\n<li>JWT 中的载荷可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><strong>过期时间问题</strong>：由于服务端不保存 Session 状态，因此无法在使用过程中废止某个 Token，或是更改 Token 的权限。也就是说，一旦 JWT 签发，在到期之前就会始终有效，除非服务端部署额外的逻辑。因此如果是浏览器端应用的话，使用 JWT 认证机制还需要设计一套 JWT 的主动更新删除的机制，这样就增加了系统的复杂性。</li>\n<li><strong>安全性</strong>：由于 JWT 的 Claims 是 Base64 编码的，并没有加密，因此 JWT 中不能存储敏感数据</li>\n<li><strong>性能问题</strong>：JWT 占用空间过大，Cookie 限制一般是 4k，可能会无法容纳，所以 JWT 一般放 LocalStorage 里面，并且用户在系统的每次 HTTP 请求都会把 JWT 携带在 Header 里面，HTTP 请求的 Header 可能比 Body 还要大。</li>\n</ol>\n<h3 id=\"koa-jwt\"><a href=\"#koa-jwt\" class=\"headerlink\" title=\"koa-jwt\"></a>koa-jwt</h3><p>下面介绍 Koa 中使用 <code>koa-jwt</code> 进行颁发、校验 Token 的使用方法。</p>\n<p>服务端生成 Token</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-router'</span>)();</span><br><span class=\"line\"><span class=\"keyword\">const</span> jwt = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-jwt'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 这里使用的是 MongoDB 数据库</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> userModel = <span class=\"built_in\">require</span>(<span class=\"string\">'../model/userModel'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> secretOrPublicKey = <span class=\"string\">'TOKEN_EXAMPLE'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/login'</span>, <span class=\"keyword\">async</span> ctx =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = ctx.request.body;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 根据用户提供的用户名和密码查询数据库中是否存在对应的用户信息</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> userInfo = <span class=\"keyword\">await</span> userModel.findOne(&#123; <span class=\"attr\">name</span>: data.name, <span class=\"attr\">password</span>: data.password &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (userInfo !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据用户信息签发 Token，设定有效时间为 2h</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> token = jwt.sign(&#123; <span class=\"attr\">name</span>: userInfo.name, <span class=\"attr\">_id</span>: userInfo._id &#125;, secretOrPublicKey, &#123;</span><br><span class=\"line\">      expiresIn: <span class=\"string\">'2h'</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    result = &#123;</span><br><span class=\"line\">      code: <span class=\"number\">200</span>,</span><br><span class=\"line\">      token: token,</span><br><span class=\"line\">      msg: <span class=\"string\">'登录成功'</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = &#123;</span><br><span class=\"line\">      code: <span class=\"number\">400</span>,</span><br><span class=\"line\">      token: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      msg: <span class=\"string\">'登录失败'</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (ctx.body = result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>前端获取 Token：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求登录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">login</span>(<span class=\"params\">userName, password</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios</span><br><span class=\"line\">    .post(<span class=\"string\">'/login'</span>, &#123;</span><br><span class=\"line\">      name: userName,</span><br><span class=\"line\">      password: password,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res.code === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        localStorage.setItem(<span class=\"string\">'access_token'</span>, res.data.token);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'登录失败'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.error(e));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后续获取 Token 后续的 API 请求</span></span><br><span class=\"line\"><span class=\"comment\">// 通过 Axios 拦截器加上 Authorization 请求头部字段</span></span><br><span class=\"line\">axios.interceptors.request.use(<span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = localStorage.getItem(<span class=\"string\">'token'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  config.headers.common[<span class=\"string\">'Authorization'</span>] = <span class=\"string\">'Bearer '</span> + token;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>服务端校验前端发送来的请求：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> jwt = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-jwt'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"><span class=\"keyword\">const</span> secretOrPublicKey = <span class=\"string\">'TOKEN_EXAMPLE'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">app</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    jwt(&#123;</span><br><span class=\"line\">      secret: secretOrPublicKey,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .unless(&#123;</span><br><span class=\"line\">    path: [<span class=\"regexp\">/\\register/</span>, /\\/login/],</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>在 <code>koa-jwt</code> 的源码实现中，我们可以知道 Token 的鉴定是先判断请求头中是否带了 Authorization：</p>\n<ul>\n<li>有，则通过正则将 <code>token</code> 从 Authorization 中分离出来，Token 中是带有 Bearer 这个单词</li>\n<li>没有，则代表了客户端没有传 Token 到服务器，这时候就抛出 401 错误状态</li>\n</ul>\n<p>源码文件中的 <code>verify.js</code> 中，调用了 <code>jsonwebtoken</code> 库原生提供的 <code>verify()</code> 方法进行验证返回结果。</p>\n<p><a href=\"https://github.com/auth0/node-jsonwebtoken\" target=\"_blank\" rel=\"noopener\">jsonwebtoken</a> 的 <code>sign()</code> 用于生成 <code>token</code>，而 <code>verify()</code> 方法当然则是用来解析 <code>token</code>。属于 JWT 配对生产的两个方法，所以 <code>koa-jwt</code> 这个中间件也没做什么事，无非就是用正则解析请求头，调用 <code>jsonwebtoken</code> 的 <code>verify()</code> 验证 <code>token</code>，在 <code>koa-jwt</code> 文件夹的 <code>index.js</code> 中，<code>koa-jwt</code> 还调用 <code>koa-unless</code> 进行路由权限分发。</p>\n<ul>\n<li><a href=\"http://www.uxys.com/html/JavaScript/20190722/52733.html\" target=\"_blank\" rel=\"noopener\">Koa2 服务端使用 JWT 进行鉴权及路由权限分发的流程分析</a></li>\n</ul>\n<h3 id=\"Token-认证常见问题及解决方案\"><a href=\"#Token-认证常见问题及解决方案\" class=\"headerlink\" title=\"Token 认证常见问题及解决方案\"></a>Token 认证常见问题及解决方案</h3><h4 id=\"注销登录\"><a href=\"#注销登录\" class=\"headerlink\" title=\"注销登录\"></a>注销登录</h4><p>注销登录等场景下 Token 仍有效类似的场景：</p>\n<ul>\n<li>退出登录</li>\n<li>修改密码</li>\n<li>服务端修改了某个用户具有的权限或角色</li>\n<li>用户的账户被删除/暂停</li>\n<li>用户由管理员注销</li>\n</ul>\n<p>这个问题仅存在于 Token 认证中，因为 Session-Cookie 认证模式中，这些情况能够通过删除服务端 Session 中对应的记录解决，而 Token 认证中，如果服务端不增加其他逻辑的话，在失效前 Token 都是有效的。</p>\n<p>下面列出几种针对这些场景的解决方案：</p>\n<ul>\n<li><strong>将 Token 存储在内存数据库</strong>：将 Token 存入类似于 Redis 的内存数据库中。如果需要让某个 Token 失效就直接从 Redis 中删除这个 Token 即可。但是这样会导致每次使用 Token 发送请求都要先从 DB 中查询 Token 是否存在的步骤，而且违背了 JWT 无状态原则。</li>\n<li><strong>黑名单机制</strong>：和上述方案类似，使用内存数据库维护一份黑名单，如果想让某个 Token 失效的话就直接将这个 Token 放入到黑名单内即可。每次使用 Token 进行请求时都会先判断 Token 是否存在于黑名单中。</li>\n<li><strong>修改密钥 Secret</strong>：为每个用户创建专属密钥，如果想让某个 Token 失效，我们直接修改对应用户的密钥即可。但是，这样相较于前两种引入内存数据带入的危害更大：<ul>\n<li>如果服务是分布式的，每次发出新的 Token 时都必须在多台及其同步密钥。为此，你需要将机密存在数据库或其他外部服务中，这样和 Session 认证就没有太大区别了</li>\n<li>如果用户同时在两个浏览器打开系统，或者在移动设备上打开系统，当它从一个地方将账号退出时，那么其他终端都需要重新登录认证，这是不可取的</li>\n</ul>\n</li>\n<li><strong>保持令牌的有效期限短并经常轮换</strong><ul>\n<li>很简单的方式，但是会导致用户登录状态不会被持久记录，而且需要用户经常登录</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"续签问题\"><a href=\"#续签问题\" class=\"headerlink\" title=\"续签问题\"></a>续签问题</h4><p>Token 的续签问题：</p>\n<p>Token 有效期一般不建议设置过长，而 Token 过期后如何认证，如何 <code>动态刷新</code> Token 等需要有效的方案解决。</p>\n<p>在 Session-Cookie 认证中，假设 Session 有效期为 30 分钟，如果 30 分钟内有资源请求访问，那么就把 Session 的有效期自动延长 30 分钟。</p>\n<ul>\n<li><strong>类似于 Session 人中的做法</strong>：当客户端访问服务端，发现 Token 即将过期时，服务端重新颁发新的 Token 给客户端</li>\n<li><strong>每次请求都返回新 Token</strong>：实现思路简单明了，但是开销较大</li>\n<li><strong>Token 有效期设置到半夜</strong>：折衷方案，保证大部分用户正常工作时间可以正常登录，适用于安全性要求不高的系统</li>\n<li><strong>用户登录返回两个 Token</strong>：第一个是 <code>accessToken</code>，它的过期时间设置比如半个小时，另一个是 <code>refreshToken</code>，它的过期时间更长一点，例如 1 天。客户端登录后，将 <code>accessToken</code> 和 <code>refreshToken</code> 保存在本地，每次访问将 <code>accessToken</code> 传给服务端。服务端校验 <code>accessToken</code> 的有效性，如果过期的话，就将 <code>refreshToken</code> 传给服务端。如果有效，服务端就生成新的 <code>accessToken</code> 给客户端。否则，客户端就重新登录即可。该方案不足的是：<ul>\n<li>需要客户端配合</li>\n<li>用户注销的时候需要同时保证两个 Token 都无效</li>\n<li>重新请求获取 Token 的过程中会有短暂 Token 不可用的情况（可以通过在客户端设置定时器，当 <code>accessToken</code> 快过期的时候，提前去通过 <code>refreshToken</code> 获取新的 <code>accessToken</code>）</li>\n</ul>\n</li>\n</ul>\n<p>JWT 最适合的场景是不需要服务端保存用户状态的场景，如果考虑到 Token 注销和续签等场景的话，目前来说没有特别好的解决方案，大部分解决方案都给 Token 加上状态，这实际上就有点类似 Session-Cookie 认证了。</p>\n<h2 id=\"单点登录\"><a href=\"#单点登录\" class=\"headerlink\" title=\"单点登录\"></a>单点登录</h2><p><strong>单点登录</strong>（Single Sign-on）又称 SSO，是指在多系统应用群中登录单个系统，便可在其他所有系统中得到授权而无需再次登录。</p>\n<p>传统的 All-in-one 型应用的认证系统和业务系统集合在一起的，当用户认证通过时，将用户信息存入 Session 中。其他业务只需要从业务中通过对应会话身份凭证取到用户信息进行相关业务处理即可。</p>\n<p>传统的 Session 是将用户信息存入内存，维护一个哈希表。每次请求携带会话身份凭证 SessionID（Tomcat 中是 <code>JSESSIONID</code>）到服务端，根据此 SessionID 查找到对应的用户信息。</p>\n<p>利用 Redis 等内存数据库进行用户信息的存储，自定义 Token 生成规则将用户信息写入 Redis 中。这样将用户信息的存储和业务系统进行拆分，使系统更加健壮，更易于扩展。新增系统只需要从 SSO 中获取相关的认证即可进行横向的业务扩展。而且 Redis 本身的性质也易于进行 <code>集群化</code> 的部署。</p>\n<p>下面详述各种场景下 SSO 的实现方案。</p>\n<h3 id=\"同域-SSO\"><a href=\"#同域-SSO\" class=\"headerlink\" title=\"同域 SSO\"></a>同域 SSO</h3><p>当存在两个相同域名下的系统 A <code>a.abc.com</code> 和系统 B <code>b.abc.com</code> 时，以下为他们实现 SSO 的步骤：</p>\n<ol>\n<li>用户访问某个子系统时（例如 <code>a.abc.com</code>），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录</li>\n<li>登录认证后，服务端把登录用户的信息存储于 Session 中，并为用户生成对应的会话身份凭证附加在响应头的 <code>Set-Cookie</code> 字段中，随着请求返回写入浏览器中，并回跳到设定的子系统链接中</li>\n<li>下次发送请求时，当用户访问同域名的系统 B 时，由于 A 和 B 在相同域名下，也是 <code>abc.com</code>，浏览器会自动带上之前的 Cookie。此时服务端就可以通过该 Cookie 来验证登录状态了。</li>\n</ol>\n<p>这实际上使用的就是 Session-Cookie 认证的登录方式。</p>\n<h3 id=\"跨域-SSO\"><a href=\"#跨域-SSO\" class=\"headerlink\" title=\"跨域 SSO\"></a>跨域 SSO</h3><p>上述所提及的同域名 SSO 并不支持跨域名的登录认证，这显然不符合当今互联网发展潮流，毕竟大多数中大型企业内外部的系统都是部署在不同的域名下，下面我们介绍实现单点登录的标准流程。</p>\n<p><strong>CAS</strong>（Central Authentication Service）中央授权服务，本身是一个开源协议，分为 1.0 版本和 2.0 版本。1.0 称为基础模式，2.0 称为代理模式，适用于存在非 Web 应用之间的单点登录。</p>\n<p>CAS 的实现需要三方角色：</p>\n<ul>\n<li>Client：用户</li>\n<li>Server：中央授权服务，也是 SSO 中心负责单点登录的服务器</li>\n<li>Service：需要使用单点登录鉴权的各个业务服务，相当于上文中的系统 A / B</li>\n</ul>\n<p>CAS 的实现需要提供以下四个接口：</p>\n<ul>\n<li><code>/login</code>：登录接口，用于登录到中央授权服务</li>\n<li><code>/logout</code>：登出接口，用于从中央授权服务中登出</li>\n<li><code>/validate</code>：用于验证用户是否登录中央授权服务</li>\n<li><code>/serviceValidate</code>：用于让各个 Service 验证用户是否登录中央授权服务</li>\n</ul>\n<p>CAS 票据：</p>\n<ul>\n<li><strong>TGT（Ticket Grangting Ticket）</strong>：TGT 是 CAS 为用户签发的 <code>登录票据</code>，拥有了 TGT，用户就可以证明自己在 CAS 成功登录过。TGT 封装了 Cookie 值以及此 Cookie 值对应的用户信息。当 HTTP 请求到来时，CAS 以此 Cookie 值（TGC）为 <code>key</code> 查询缓存中是否有 TGT，如果有，则表示用户已登录过。</li>\n<li><strong>TGC（Ticket Granting Cookie）</strong>：CAS Service 生成 TGC 放入自己的 Session 中，而 TGC 就是这个 Session 的唯一标识（SessionID），以 Cookie 形式放到浏览器端，是 CAS Service 用来明确用户身份的凭证</li>\n<li><strong>ST（Service Ticket）</strong>：ST 是 CAS 为用户签发的访问某个 Service 的票据。用户访问 Service 时，Service 发现用户没有 ST，则要求用户去 CAS 获取 ST。用户向 CAS 发出 ST 的请求，CAS 发现用户有 TGT，则签发一个 ST，返回给用户。用户拿着 ST 去访问 Service，Service 拿 ST 去 CAS 验证，验证通过后，允许用户访问资源。</li>\n</ul>\n<p>这里可能概念太多会非常难理解，简单说明下，客户端需要各自维护与不同系统的登录状态，包括与中央授权服务的登录状态。所以，实际上 TGC 和 TGT 是维护客户端与中央授权服务登录状态的会话身份凭证的 <code>key-value</code> 键名值，而 ST 票据则是资源服务向中央授权服务获取用户登录状态、信息的交换凭证，只不过资源服务需要经用户的“手”上才能获取到该票据。</p>\n<p>详细步骤：</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-cas-workflow.png\" alt=\"CAS 验证流程时序图\"></p>\n<ol>\n<li>用户访问系统 A 的受保护资源（域名是 <code>a.abc.com</code>），系统 A 检测出用户处于 <code>未登录</code> 状态，重定向（应答码 302）至 SSO 服务认证中心的登录接口，同时地址参数携带登录成功后回跳到系统 A 的页面链接（跳转的链接形如 <code>sso.abc.com/login?service=https%3A%2F%2Fwww.a.abc.com</code>）</li>\n<li>由于请求没有携带 SSO 服务器上登录的票据凭证（TGC），所以 SSO 认证中心判定用户处于 <code>未登录</code> 状态，重定向用户页面至 SSO 的登录界面，用户在 SSO 的登录页面上进行登录操作。</li>\n<li>SSO 认证中心校验用户身份，创建用户与 SSO 认证中心之间的会话，称为 <code>全局会话</code>，同时创建 <code>授权令牌</code>（ST），SSO 带着授权令牌跳转回最初的系统 A 的请求地址：</li>\n</ol>\n<ul>\n<li>重定向地址为之前写在 <code>query</code> 中的系统 A 的页面地址</li>\n<li>重定向地址的 <code>query</code> 中包含 SSO 服务器派发的 ST</li>\n<li>重定向的 HTTP 响应中包含写 Cookie 的 Header。这个 Cookie 代表用户在 SSO 中的登录状态，它的值就是 TGC</li>\n</ul>\n<ol start=\"5\">\n<li>浏览器重定向至系统 A 服务地址，此时重定向的 URL 中携带着 SSO 服务器生成的 ST</li>\n<li>系统 A 拿着 ST 向 SSO 服务器发送请求，SSO 服务器验证票据的有效性。验证成功后，系统 A 知道用户已经在 SSO 登录了，于是系统 A 服务器使用该令牌创建与用户的会话，称为 <code>局部会话</code>，返回受保护网页资源</li>\n<li>之后用户访问系统 B 受保护资源（域名 <code>b.abc.com</code>），系统 B 检测出用户处于 <code>未登录</code> 状态，跳转至 SSO 服务认证中心，同时地址参数携带授权令牌 ST（每次生成的 ST 都是不一样的）登录成功后回跳的链接</li>\n<li>SSO 认证中心发现用户已登录，跳转回系统 B 的地址，并附上令牌</li>\n<li>系统 B 拿到令牌，去 SSO 认证中心校验令牌是否有效，SSO 认证中心校验令牌，返回有效，注册系统 B</li>\n<li>系统 B 使用该令牌创建与用户的局部会话，返回受保护资源</li>\n</ol>\n<p>至此整个登录流程结束，而在实际开发中，基本上都会根据 CAS 增加更多的判断逻辑，比如，在收到 CAS Server 签发的 ST 后，如果 ST 被 Hacker 窃取，并且 Client 本身没来得及去验证 ST，被 Hacker 抢先一步验证 ST，怎么解决。此时就可以在申请 ST 时添加额外验证因子（如 IP、SessionID 等）。</p>\n<h3 id=\"LDAP-认证登录\"><a href=\"#LDAP-认证登录\" class=\"headerlink\" title=\"LDAP 认证登录\"></a>LDAP 认证登录</h3><p>LDAP 的全称是 Lightweight Directory Access Protocol，即<strong>轻量目录访问协议</strong>，是一个开放、广泛被使用的工业标准（IEFT、RFC）。企业级软件也通常具备 *<em>支持 LDAP</em>- 的功能，比如 Jira、Confluence、OpenVPN 等，企业也经常采用 LDAP 服务器来作为企业的认证源和数据源。但是大家比较常见的误区是，可以使用 LDAP 来实现 SSO。我们可以先分析以下它的主要功能点或场景。</p>\n<ul>\n<li>作为数据源它可以用于存储<ul>\n<li>企业的组织架构树</li>\n<li>企业员工信息</li>\n<li>证书信息</li>\n<li>会议室，打印机等等资源</li>\n</ul>\n</li>\n<li>作为认证源，它也有多种用途<ul>\n<li>存储用户的密码</li>\n<li>对外提供 LDAP 协议的认证方式（通过 LDAP BIND 协议来校验用户名和密码）</li>\n<li>密码策略（密码复杂度，历史密码记录，用户锁定等等）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"信任登录\"><a href=\"#信任登录\" class=\"headerlink\" title=\"信任登录\"></a>信任登录</h2><p>信任登录是指所有不需要用户主动参与的登录，例如建立在私有设备与用户之间的绑定关系，凭证就是私有设备的信息，此时不需要用户再提供额外的凭证。信任登录又指用第三方比较成熟的用户库来校验凭证，并登录当前访问的网站。</p>\n<ol>\n<li>登录服务 *<em>信任业务系统</em>- 的凭证校验结果</li>\n<li>登录服务 *<em>信任第三方登录系统</em>- 的凭证校验结果，前提是必须又本站点的账号体系下的账号与第三方账号的一对一绑定关系，现在流行的授权方式也属于这个模式。</li>\n</ol>\n<p>目前比较常见的第三方信任登录帐号如：QQ 号淘宝帐号、支付宝帐号、微博帐号等。</p>\n<p>信任登录的好处是可以利用第三方庞大的用户群来推广、营销网站，同时减少用户的注册、登录时间。</p>\n<p>提到信任登录，我们就不得不提到 OAuth，正是有了 OAuth，我们的信任登录才得以实现。下面我们就来看下关于 OAuth 的一些介绍。</p>\n<h2 id=\"OAuth2-开发授权\"><a href=\"#OAuth2-开发授权\" class=\"headerlink\" title=\"OAuth2 开发授权\"></a>OAuth2 开发授权</h2><p>OAuth（开放授权）是一个开发标准，允许用户授权 <code>第三方网站</code> 访问他们存储在另外的服务提供商中的信息，而不需要接触到用户名和密码。为了保护数据的安全和隐私，第三方网站访问用户数据前都需要 <code>显式地向用户征求授权</code>。我们常见的 OAuth 认证服务的厂商有微信、QQ、支付宝等。</p>\n<p>OAuth 协议又有 1.0 和 2.0 两个版本，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。</p>\n<p>应用场景有：第三方应用的接入、微服务鉴权互信、接入第三方平台、第一方密码登录等。</p>\n<p>授权模式：</p>\n<ul>\n<li>授权码模式（Authorization Code Grant）</li>\n<li>隐式授权模式（Implicit Grant）</li>\n<li>密码模式（Resource Owner Password Credentials Grant）</li>\n<li>客户端模式（Client Credentials Grant）</li>\n</ul>\n<p>无论哪种授权模式，都必须拥有四种必要的角色参与：<code>客户端</code>、<code>授权服务器</code>、<code>资源服务器</code>，有的还有 <code>用户（资源拥有者）</code>。我们以微信开发平台的授权登录为例解释这四种角色：</p>\n<ul>\n<li>资源拥有者（Resource Owner）：这里指微信用户</li>\n<li>第三方应用（Third-party Application）：指内嵌在微信应用内的第三方应用，形式不限于 Web App、公众号 Web 网页、小程序等等</li>\n<li>授权服务器（Authorization Server）：这里指微信开发平台的授权服务</li>\n<li>资源服务器（Resource Server）：用于存储、获取用户资源，这里指的是微信开放平台的服务器</li>\n</ul>\n<h3 id=\"授权码模式\"><a href=\"#授权码模式\" class=\"headerlink\" title=\"授权码模式\"></a>授权码模式</h3><p>授权码模式是 OAuth 2.0 目前最安全最复杂的授权流程。</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-authorization-code-grant.jpg\" alt=\"授权码模式\"></p>\n<p>授权码模式的授权流程可以分为三个部分：</p>\n<ol>\n<li>Client Side：用户+客户端与授权服务端的交互</li>\n<li>Server Side：客户端与授权服务端之间的交互</li>\n<li>Check Access Token’：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互</li>\n</ol>\n<p>整个流程就是：客户端换取授权码，客户端使用授权码换取 Token，客户端使用 Token 访问资源</p>\n<blockquote>\n<p>前提条件：</p>\n<ul>\n<li>第三方客户端需要提前与资源拥有方（同时也是授权所有方）协商客户端 ID（client_id）以及客户端密钥（client_secret）</li>\n<li>上述流程暂未将 <code>scope</code>、<code>state</code> 等依赖具体框架的内容写进来，这里可以参考 Spring Security OAuth2 的实现</li>\n</ul>\n</blockquote>\n<p><strong>Client Server 客户端换取授权码</strong></p>\n<p>这个客户端可以是浏览器</p>\n<ol>\n<li>客户端将 <code>client_id + client_secret + 授权模式标识（grant_type）+ 回调地址（redirect_uri）</code> 拼接成 URL 访问授权服务器</li>\n<li>授权服务端返回登录界面，要求 <code>用户登录</code>（此时用户提交的账号密码等直接发送到授权服务端，进行校验）</li>\n<li>授权服务端返回授权审批界面，<code>用户授权</code> 完成</li>\n<li>授权服务端 <code>返回授权码到回调地址</code></li>\n</ol>\n<p><strong>Server Side 客户端使用授权码换取 Token</strong></p>\n<ol>\n<li>客户端接收到授权码，并使用 <code>授权码 + client_id + client_secret</code> 访问授权服务端颁发 Token 令牌</li>\n<li>授权服务端校验通过，颁发 Token 返回给客户端</li>\n<li>客户端保存 Token 到存储器</li>\n</ol>\n<p><strong>Check Access Token 客户端使用 Token 访问资源</strong></p>\n<ol>\n<li>客户端在请求头带上 Token，访问资源服务端</li>\n<li>资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）</li>\n<li>资源服务端校验成功，返回资源</li>\n</ol>\n<p>移动应用微信登录是基于 OAuth2.0 协议标准构建的微信 OAuth2.0 授权登录系统，在微信开放平台注册开发者账号，并拥有已审核通过的移动应用，并获得相应的 AppID 和 AppSecret，申请微信登录且通过审核后，可开始接入流程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据 code 参数</span><br><span class=\"line\">2. 通过 code 参数加上 AppId 和 AppSecret 等，通过 API 换取 access_token</span><br><span class=\"line\">3. 通过 access_token 进行接口调用，获取用户基本数据资源或帮助用户实现基本操作</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img.mrsingsing.com/authentication-wx-oauth2-access-token.png\" alt=\"微信 OAuth2.0 获取 access_token 时序图\"></p>\n<p>详情可以参阅 <a href=\"https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html\" target=\"_blank\" rel=\"noopener\">微信登录功能 - 移动应用微信登录开发指南</a>，这里的实现就是授权码模式。</p>\n<h3 id=\"隐式授权模式\"><a href=\"#隐式授权模式\" class=\"headerlink\" title=\"隐式授权模式\"></a>隐式授权模式</h3><p><img src=\"http://img.mrsingsing.com/authentication-implicit-grant.jpg\" alt=\"隐式授权模式流程图\"></p>\n<p>隐式授权模式大致可以分为两部分：</p>\n<ol>\n<li>Client Side：用户+客户端与授权服务端的交互</li>\n<li>Check Access Token：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互</li>\n</ol>\n<p>整个流程就是：客户端让用户登录授权服务端换取 Token，客户端使用 Token 访问资源</p>\n<p><strong>Client Side 客户端让用户登录授权服务端换 Token</strong></p>\n<ol>\n<li>客户端（浏览器或单页应用）将 <code>client_id + 授权模式标识（grant_type）+ 回调地址（redirect_url）</code> 拼成 URL 访问授权服务端</li>\n<li>授权服务端跳转用户登录界面，用户登录</li>\n<li>用户授权</li>\n<li>授权服务端 <code>访问回调地址</code> 返回 Token 给客户端</li>\n</ol>\n<p><strong>Check Access Token 客户端使用 Token 访问资源</strong></p>\n<ol>\n<li>客户端在请求头附带 Token 访问资源服务端</li>\n<li>资源服务端收到请求，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）</li>\n<li>资源服务端校验成功，返回资源</li>\n</ol>\n<h3 id=\"密码模式\"><a href=\"#密码模式\" class=\"headerlink\" title=\"密码模式\"></a>密码模式</h3><p><img src=\"http://img.mrsingsing.com/authentication-resource-owner-password-credentials-grant.jpg\" alt=\"密码模式流程图\"></p>\n<p>密码模式的授权流程可以分为两部分：</p>\n<ol>\n<li>Client Side：用户与客户端的交互，客户端与授权服务端的交互</li>\n<li>Check Access Token’：客户端与资源服务端之间的交互 + 资源服务端与授权服务端之间的交互</li>\n</ol>\n<p>整个流程就是：用户在客户端提交账号密码换取 Token，客户端使用 Token 访问资源</p>\n<p><strong>Client Server 用户在客户端提交账号密码换取 Token</strong></p>\n<ol>\n<li>客户端要求用户登录</li>\n<li>用户输入密码，客户端将表单中添加客户端的 <code>client_id + client_secret</code> 发送给授权服务端颁发 Token 令牌</li>\n<li>授权服务端校验用户名、用户密码、<code>client_id</code> 和 <code>client_secret</code>，均通过后返回 Token 给客户端</li>\n<li>客户端保存 Token</li>\n</ol>\n<p><strong>Check Access Token 客户端使用 Token 访问资源</strong></p>\n<ol>\n<li>客户端在请求头带上 Token，访问资源服务端</li>\n<li>资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）</li>\n<li>资源服务端校验成功，返回资源</li>\n</ol>\n<h3 id=\"客户端模式\"><a href=\"#客户端模式\" class=\"headerlink\" title=\"客户端模式\"></a>客户端模式</h3><p><img src=\"http://img.mrsingsing.com/authentication-client-credentials-grant.jpg\" alt=\"客户端模式流程图\"></p>\n<p>客户端模式的授权流程可以分为两部分：</p>\n<ol>\n<li>Server Side：客户端与授权服务端之间的交互</li>\n<li>Check Access Token’：客户端与资源服务端，资源服务端与授权服务端之间的交互</li>\n</ol>\n<p>整个流程就是：客户端使用自己的标识换取 Token，客户端使用 Token 访问资源</p>\n<p><strong>Client Server 客户端使用自己的标识换取 Token</strong></p>\n<ol>\n<li>客户端使用 <code>client_id + client_secret + 授权模式标识</code> 发送给授权服务端颁发 Token 令牌</li>\n<li>授权服务端校验通过后返回 Token 给客户端</li>\n<li>客户端保存 Token</li>\n</ol>\n<p><strong>Check Access Token 客户端使用 Token 访问资源</strong></p>\n<ol>\n<li>客户端在请求头带上 Token，访问资源服务端</li>\n<li>资源服务端收到请求后，先调用校验 Token 的方法（可以是远程调用授权服务端校验 Token，也可以直接访问授权存储器手动校验）</li>\n<li>资源服务端校验成功，返回资源</li>\n</ol>\n<h3 id=\"授权模式选型\"><a href=\"#授权模式选型\" class=\"headerlink\" title=\"授权模式选型\"></a>授权模式选型</h3><p>考虑到授权场景的多样性，可以参考以下两种选型方式：</p>\n<ul>\n<li>按授权需要的多端情况</li>\n<li>按客户端类型与所有者</li>\n</ul>\n<p>按授权需要的多端情况：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">模式</th>\n<th style=\"text-align:left\">需要前端</th>\n<th style=\"text-align:left\">需要后端</th>\n<th style=\"text-align:left\">需要用户响应</th>\n<th style=\"text-align:left\">需要客户端密钥</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">授权码模式 Authorization Code</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">隐式授权模式 Implicit Grant</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✗</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✗</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">密码授权模式 Password Grant</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✓</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">客户端授权模式 Client Credentials</td>\n<td style=\"text-align:left\">✗</td>\n<td style=\"text-align:left\">✓</td>\n<td style=\"text-align:left\">✗</td>\n<td style=\"text-align:left\">✓</td>\n</tr>\n</tbody>\n</table>\n<p>按照客户端类型与访问令牌所有者分类：</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-oauth2-mode-selection.jpg\" alt=\"OAuth2.0 模式选型\"></p>\n<h2 id=\"联合登录\"><a href=\"#联合登录\" class=\"headerlink\" title=\"联合登录\"></a>联合登录</h2><p>联合登录指同时包含多种凭证校验的登录服务，同时，也可以理解为使用第三方凭证进行校验的登录服务。这个概念有点像 OAuth2.0 的认证方式。</p>\n<p>最经典的莫过于 APP 内嵌 H5 的使用场景，当用户从 APP 进入内嵌的 H5 时，我们希望 APP 内已登录的用户能够访问到 H5 内受限的资源，而未登录的用户则需要登录后访问。</p>\n<p>这里思路主要有两种，一种是原生跳转内嵌 H5 页面时，将登录态 Token 附加在 URL 参数上，另一种则是内嵌 H5 主动通过与原生客户端制定的协议获取应用内的登录状态。</p>\n<h2 id=\"扫码登录\"><a href=\"#扫码登录\" class=\"headerlink\" title=\"扫码登录\"></a>扫码登录</h2><p>二维码也称为二维条码，是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。一维条码的宽度记载着数据，而其长度没有记载数据。二维码的长度、宽度均记载着数据。二维码有一维条码没有的 <strong>定位点*- 和 </strong>容错机制**。容错机制在即使没有识别到全部的条码、或是说条码有污损时，也可以正确地还原条码上的信息。</p>\n<p>扫码登录通常见于移动端 APP 中，基本操作流程是让已登录用户主动扫描二维码，以使 PC 端的同款应用得以快速登录的方式，常见的具备扫码登录的应用有微信、钉钉、支付宝等。</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-scan-qrcode-login-workflow.jpg\" alt=\"扫码登录流程图\"></p>\n<p>扫码登录可以分为三个阶段：待扫码、已扫码待确认和已确认。</p>\n<h3 id=\"待扫码阶段\"><a href=\"#待扫码阶段\" class=\"headerlink\" title=\"待扫码阶段\"></a>待扫码阶段</h3><p><strong>待扫码阶段</strong>即上述流程图中 1~5 的阶段，亦即生成二维码阶段，这个阶段与移动端没有关系，主要是 PC 端与服务端进行交互的过程。</p>\n<p>首先 PC 端携带设备信息向服务端发起了生成二维码请求，服务端接收到请求后生成 <code>UUID</code> 作为二维码 ID，并将 UUID 与 <code>PC 端的设备信息</code> 关联起来存储在 Redis 服务器中，然后返回给 PC 端。</p>\n<p>当 PC 端收到二维码 ID 之后，将二维码 ID 以 <code>二维码的形式</code> 展示，等待移动端扫码。此时 PC 端开始轮询查询二维码状态，直到登录成功。当然除了使用轮询查询，也能使用 WebSocket 实现查询/推送二维码状态的需求。如果移动端未扫描，那么一段时间后二维码会自动失效。</p>\n<h3 id=\"已扫码待确认阶段\"><a href=\"#已扫码待确认阶段\" class=\"headerlink\" title=\"已扫码待确认阶段\"></a>已扫码待确认阶段</h3><p><strong>已扫码待确认阶段</strong>亦即流程图中的 6~10 的阶段，在 PC 端登录微信时，手机扫码后，PC 端的二维码会显示为已扫码，并提示需要在手机上确认，这个阶段是移动端与服务端交互的过程。</p>\n<p>移动端扫描二维码后，会自动获取到二维码 ID，并将移动端登录的信息凭证（Token）和二维码 ID 作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。</p>\n<p>服务端接受请求后，会将 <code>Token 与二维码 ID</code> 关联，为什么需要关联呢？因为，当我们在使用微信时，移动端退出时，PC 端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个一次性 Token，这个 Token 会返回给移动端，一次性 Token 用作确认时的凭证。</p>\n<p>PC 端轮询到二维码的状态已经发生变化，会将 PC 端的二维码更新为已扫描，请确认。</p>\n<h3 id=\"已确认阶段\"><a href=\"#已确认阶段\" class=\"headerlink\" title=\"已确认阶段\"></a>已确认阶段</h3><p><strong>已确认阶段</strong>为流程图中的步骤 11~15，这是扫码登录的最后阶段，用户确认登录，移动端携带上一步中获取的 <code>临时 Token</code> 发送给服务端校验。服务端校验完成后，会更新二维码状态，并且给 PC 端生成一个 <code>正式的 Token</code>，后续 PC 端就是持有这个 Token 访问服务端。</p>\n<p>PC 端的定时器，轮询到二维码状态为已登录状态，并且会获取到了生成的 Token，完成登录，后续访问都基于 Token 完成。</p>\n<p>在服务端会跟移动端一样，维护着 Token 跟二维码、PC 设备信息、账号等信息。</p>\n<h2 id=\"一键登录\"><a href=\"#一键登录\" class=\"headerlink\" title=\"一键登录\"></a>一键登录</h2><p>最传统的登录方式莫过于提供账号密码校验，但这毫无疑问需要消耗用户的记忆成本。随着无线互联的发展以及手机卡实名制的推广，手机号俨然已成为特别的身份证明，与账号密码相比，手机号可以更好地验证用户的身份，防止恶意注册。</p>\n<p>但是手机号注册还是需要一系列繁琐的操作：输入手机号、等待短信验证码、输入验证码、点击登录。整个流程少说二十秒，而且如果收不到短信，也就登录补了，这类问题有可能导致潜在的用户流失。</p>\n<p>短信验证码的作用就是证明当前操作页面的用户与输入手机号的用户为相同的人，那么实际上只要我们能够获取到当前手机的手机号并与输入的手机号对比匹配后便能达到校验的功能。但是，无论是原生 APP 还是 H5 网页都是不具备直接获取用户手机号的功能的，而这种需求运营商能够通过手机 SIM 卡的流量数据查询。随着运营商开放了相关的服务，我们能够接入运营商提供的 SDK 并付费使用相关的服务。</p>\n<p>下图为一键登录的流程图：</p>\n<p><img src=\"http://img.mrsingsing.com/authentication-one-click-login-workflow.png\" alt=\"一键登录流程图\"></p>\n<p>主要步骤：</p>\n<ol>\n<li>SDK 初始化：调用 SDK 方法，传入平台配置的 AppKey 和 AppSecret</li>\n<li>唤起授权页：调用 SDK 唤起授权接口，SDK 会先向运营商发起获取手机号掩码的请求，请求成功后跳到授权页。授权页会显示手机号掩码以及运营商协议给用户确认。</li>\n<li>同意授权并登录：用户同意相关协议，点击授权页面的登录按钮，SDK 会请求本次取号的 Token，请求成功后将 Token 返回给客户端</li>\n<li>取号：将获取到的 Token 发送到自己的服务器，由服务端携带 Token 调用运营商一键登录的接口，调用陈工就返回手机号码。服务端用手机号进行登录或注册操作，返回操作结果给客户端，完成一键登录。</li>\n</ol>\n<p>由于国内三大运营商各自有独立的 SDK，所以会导致兼容方面的工作会特别繁琐。如果要采用一键登录的方案，不妨采用第三方提供了号码认证服务，下列几家供应商都拥有手机号码认证能力：</p>\n<ul>\n<li><a href=\"https://help.aliyun.com/product/75010.html\" target=\"_blank\" rel=\"noopener\">阿里 - 号码认证服务</a></li>\n<li><a href=\"http://shanyan.253.com/\" target=\"_blank\" rel=\"noopener\">创蓝 - 闪验</a></li>\n<li><a href=\"https://www.jiguang.cn/identify\" target=\"_blank\" rel=\"noopener\">极光 - 极光认证</a></li>\n<li><a href=\"https://www.mob.com/mobService/secverify\" target=\"_blank\" rel=\"noopener\">mob - 秒验</a></li>\n</ul>\n<p>在认证过程中，需要用户打开蜂窝网络，如果手机设备没有插入 SIM 卡、或者关闭蜂窝网络的情况下，是无法完成认证的。所以就算接入一键登录，还是要兼容传统的登录方式，允许用户在失败的情况下，仍能正常完成登录流程。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>鉴权授权是计算机领域无法躲避的技术议题，认证、授权、鉴权和权限控制是围绕这个议题的几个关键概念：认证（Identification）是指根据声明者提供的资料，确认声明者身份；授权（Authorization）则是资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作；鉴权（Authentication）指的对声明者所声明的真实性进行校验。从授权角度出发，会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。</p>\n<ul>\n<li>Authorization 决定你是否有权限去获取资源</li>\n<li>Authentication 校验你说你是谁</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">授权 -&gt; 鉴权 -&gt; 权限控制</span><br></pre></td></tr></table></figure>\n<p>花了一周时间将登录鉴权授权方面的知识总结了一番，确认对各种方案的实施细节，以及设计原理、方案优劣都有了更深一层的了解，在学习的过程中不免会联想到无论是生活中各种类似的场景，也会想到计算机领域中诸如 Linux 系统、数据库等权限控制相关机制。这是个融汇贯通的学习过程，发现这种针对某个议题的体系式整理，对前端技术体系中各个独立的点连通起到了不错的效果。</p>\n<hr>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Basic_access_authentication\" target=\"_blank\" rel=\"noopener\">📖 Wikipedia：Basic Access Authentication</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication\" target=\"_blank\" rel=\"noopener\">📖 HTTP 身份验证 Authentication</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"noopener\">📖 RFC 7019 - JSON Web Token（JWT）</a></li>\n<li><a href=\"https://apereo.github.io/cas/4.2.x/index.html\" target=\"_blank\" rel=\"noopener\">📖 CAS 官方文档</a></li>\n<li><a href=\"https://juejin.im/entry/5ac175baf265da239e4e3999\" target=\"_blank\" rel=\"noopener\">📝 一文读懂 HTTP Basic 身份认证</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/43527568\" target=\"_blank\" rel=\"noopener\">📝 你在用 JWT 代替 Session？</a></li>\n<li><a href=\"https://juejin.im/post/5cefad23e51d4510774a87f4#heading-4\" target=\"_blank\" rel=\"noopener\">📝 用户认证：基于 JWT 和 Session 的区别和优缺点</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/85873228\" target=\"_blank\" rel=\"noopener\">📝 JWT 身份认证优缺点分析以及常见问题解决方案</a></li>\n<li><a href=\"https://juejin.im/post/5a002b536fb9a045132a1727\" target=\"_blank\" rel=\"noopener\">📝 前端需要了解的 SSO 与 CAS 知识</a></li>\n<li><a href=\"https://juejin.im/post/5b51f39b5188251a9f24a264\" target=\"_blank\" rel=\"noopener\">📝 不务正业的前端之 SSO（单点登录）实践</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/102898335\" target=\"_blank\" rel=\"noopener\">📝 面试题：给我说一下你项目中的单点登录是如何实现的</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/60376970\" target=\"_blank\" rel=\"noopener\">📝 单点登录系统</a></li>\n<li><a href=\"https://www.cnblogs.com/ywlaker/p/6113927.html\" target=\"_blank\" rel=\"noopener\">📝 单点登录原理与简单实现</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/92263756\" target=\"_blank\" rel=\"noopener\">📝 单点登录 LDAP 协议</a></li>\n<li><a href=\"https://www.zhihu.com/question/21387523\" target=\"_blank\" rel=\"noopener\">📝 信任登录与联合登录有什么差异？</a></li>\n<li><a href=\"https://juejin.im/entry/5a93506e6fb9a0634c268da8\" target=\"_blank\" rel=\"noopener\">📝 OAuth2.0 深入了解：以微信开发平台统一登录为例</a></li>\n<li><a href=\"https://www.cnblogs.com/hellxz/p/oauth2_process.html\" target=\"_blank\" rel=\"noopener\">📝 OAuth 2.0 概念及授权流程梳理</a></li>\n<li><a href=\"https://juejin.im/post/5d15d3336fb9a07efb69994f\" target=\"_blank\" rel=\"noopener\">📝 论 H5 嵌入 APP 的联合登录的解决方案</a></li>\n<li><a href=\"https://juejin.im/post/5e83e716e51d4546c27bb559\" target=\"_blank\" rel=\"noopener\">📝 聊一聊二维码扫描登录原理</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/gA0JQp4j2ym9qOyQkC3qkA\" target=\"_blank\" rel=\"noopener\">📝 阿里面试官：分别说说微信和淘宝扫码登录背后的实现原理</a></li>\n<li><a href=\"https://juejin.im/post/5d197adff265da1bb31c4fa9\" target=\"_blank\" rel=\"noopener\">📝 用户一键登录，如何实现</a></li>\n<li><a href=\"https://learnku.com/articles/30704\" target=\"_blank\" rel=\"noopener\">📝 微服务架构下的鉴权，怎么做更优雅？</a></li>\n<li><a href=\"http://www.hyhblog.cn/2018/04/25/user_login_auth_terms/\" target=\"_blank\" rel=\"noopener\">📝 认证、授权、鉴权和权限控制</a></li>\n</ul>"},{"title":"常用移动前端开发调试方式","date":"2020-05-27T00:00:00.000Z","_content":"\n# 常用移动前端开发调试方式\n\n因为日常开发经常需要在移动设备上调试测试开发的 H5 页面，但是一直都没怎么总结过移动前端开发相关的调试工具或方法，今天稍微总结一下比较好用的调试工具，也罗列了一些没有用过但是值得了解的工具\n\n## 通用调试工具方法\n\n### Chrome 移动设备模拟器\n\nChrome 浏览器开发者工具内置了可用于模拟移动设备的功能，这也是最常用的调试方式，这里只是简单说明操作步骤：\n\n1. 在 PC 端打开 Chrome 浏览器并打开目标页面，然后 F12 打开开发者工具\n2. 点击开发者工具左上角的手机图标，刷新页面后即可调试\n3. 页面顶部设备选择下拉菜单可选择默认的多种品牌机型，以及仿真的网络状态\n4. 选择下来菜单中的 `Edit` 进入适配设备的机型选择，既有浏览器提供的机型，也可以根据需要设定自定义机型（主要是测试宽高比）\n\n因为使用起来方便，所以开发调试的大部分都能满足需求，但是要更仿真更严谨还是需要在真机中调试。\n\n### vConsole 移动端网页上的调试控制台\n\n[vConsole](https://github.com/Tencent/vConsole) 是一款轻量级、可拓展、针对手机网页的前端开发者调试面板。\n\n通过该工具可以方便地在移动真机的 Web 页面中通过以下特性实现调试功能：\n\n- 查看 console 日志\n- 查看网络请求信息\n- 查看页面 element 结构\n- 查看 Cookie、localStorage 和 SessionStorage\n- 手动执行 JavaScript 命令行\n- 自定义插件\n\n<!-- more -->\n\n这款类库应该是使用最广泛的工具，而且使用起来也比较简单，与 PC 端 Chrome 等开发者调试工具使用方式类似，所以就不多叙述了。\n\n更多关于此工具的使用教程可以参阅 [vConsole 使用教程](https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md)\n\n除此之外，有个同样是 AlloyTeam 出品的错误监控上报、支持生产环境通过 URL 带参数唤起 vConsole 的库 [AlloyLever](https://github.com/AlloyTeam/AlloyLever) 也值得关注一下。\n\n同类型的产品有 [eruda](https://github.com/liriliri/eruda)\n\n#### 实现原理\n\n通过在页面注入 JavaScript 脚本实现模拟类似 Chrome DevTool 的调试面板。\n\n通过重写 `XHMLHttpRequest`、`fetch`、`console` 方法实现网络请求和日志打印的拦截，并输出到控制面板中的 `Network` 和 `Console` 标签。\n\n通过遍历 Cookie、LocalStorage、SessionStorage 对象下的所有存储键值以获取当前网页的本地存储数据。\n\n而 `Element` 标签中的页面 DOM 树结构，则通过从 `document.documentElement` 节点开始向子孙节点递归生成。\n\n### Charles 数据传输抓包工具\n\n试想以下在日常开发中可能会遇到的场景：\n\n1. 在本地开发完移动 H5 页面后，想与后端联调接口，但是接口部署在机房服务器上，域名非 IP 地址，这个时候联调会存在跨域问题，应该怎样解决？\n2. 线上 Web App 表现异常，没法在线上页面使用调试面板进行调试，怎样定位问题？\n3. 线上 Web App 表现异常，接口请求响应表现正常，单从代码层面无法定位问题根源，怎样更好地定位问题？\n\n在 Charles 强大的抓包功能面前，这些问题通通都不是问题。我们先介绍一下 Charles：\n\n[Charles](https://www.charlesproxy.com/) 是一款基于 HTTP 协议的代理服务器，通过截取请求和请求结果达到分析抓包的目的。\n\n以下是 Charles 的功能特性：\n\n- 支持 HTTP 和 HTTPS 代理，截取分析 SSL 请求\n- 支持流量控制，可以模拟弱网测试环境\n- 支持接口并发请求\n- 支持重发网络请求，方便后端调试\n- 支持修改网络请求参数\n- 支持网络请求的截获并动态修改\n- 支持断点调试，构建异常的测试场景\n\n#### 使用方式\n\n使用 Charles 抓包手机向服务器发送请求的操作步骤：\n\n1. 安装根证书：`菜单 -> Help -> SSL Proxying -> Install Charles Root Certificate`\n\n![安装根证书](http://img.mrsingsing.com/wireless-debugger-install-charles-certificate.jpg)\n\n2. 找到安装好 Charles 的根证书后，确保证书的所有选项均为始终信任（这个证书后续会下载到你的手机中使用）\n\n![总是信任](http://img.mrsingsing.com/wireless-debugger-always-trust-certificate.jpg)\n\n3. 然后开启 Charles 的代理服务：`Proxy -> Proxy Setting`，`port` 端口填 `8888`，选中 `Enable transparent HTTP proxying`\n\n找到当前使用的 Mac 笔记本的 IP 地址（通过 `Charles -> Help -> Local IP Address` 可以获取）\n\n![开启Charles代理](http://img.mrsingsing.com/wireless-debugger-enable-charles-proxying.jpg)\n\n4. 给 iPhone 设置代理\n\n- 打开 iPhone，连接 Wifi（需要确保 iPhone 与 Mac 连接的是相同的 Wifi）\n- 打开 Wifi 名后的蓝色感叹号，在最下面找到 `HTTP 代理`，点击进入\n- 选择 `手动`，服务器上填上端口号 `8888`\n\n5. 随便打开网页，这个时候 Charles 会弹出请求连接的确认菜单，选择左边选项 `Allow`\n\n6) 在手机浏览器中（最好是 Safari），输入 `chls.pro/ssl`，会弹出安装证书的请求，输入密码，一直点安装即可\n\n- 打开设置，点击 `通用 -> 关于本机 -> 证书信任设置`，找到当前要作为代理的电脑名，打开信任开关\n\n这个时候既可以截取到 HTTP/HTTPS 的网络请求了。\n\n#### 实现原理\n\n![Charles实现原理](http://img.mrsingsing.com/wireless-debugger-charles-principle.jpg)\n\n事实上 Charles 就是充当所谓的 `中间人` 角色，把我们的设备发送的请求拦截下来，并转发给我们的目标服务器，而后将响应的信息返回给我们的设备。\n\n前提是设备上需要安装并信任 Charles 的证书，这个为了当 HTTPS 传输时，Charles 需要拦截解密数据并利用服务端的证书公钥和 HTTPS 连接的对称密钥做后续的传输加密。\n\n由于本人使用 Charles 比较多，但其实还有很多类似的抓包工具，例如：\n\n- 软件类\n  - [Fiddler](https://www.telerik.com/fiddler)\n  - [Wireshark](https://www.wireshark.org/download.html)\n  - [Weinre](https://github.com/nupthale/weinre)：基于 Web Inspector 的远程调试工具，可以在 PC 上直接调试运行在手机上的页面\n- 工具包类\n  - [spy-debugger](https://github.com/wuchangming/spy-debugger)：一站式页面调试、抓包工具，能远程调试任何手机浏览器页面，任何手机移动端 Webview，无需 USB 连接设备（实现原理与 Charles 类似）\n  - [whistle](https://github.com/avwo/whistle)：基于 Node 实现的跨平台抓包调试代理工具，功能强大，支持 WebSocket、反响代理、插件扩展等特性\n\n## 基于 iOS 的开发调试\n\n### Safari + 数据线 远程设备调试\n\n前期准备：iPhone + MacBook + 各自安装 Safari\n\n调试方式：\n\n1. 打开 iPhone `设置 -> Safari 浏览器 -> 高级 -> Web 检查器`\n2. 打开 MacBook 上的 Safari 浏览器 `偏好设置 -> 高级 -> 在菜单栏中显示“开发”菜单`\n3. 用数据线连接 iPhone 和 MacBook，并选择 `信任` 设备，在 iPhone 上的 Safari 浏览器打开需要调试的页面，并在 MacBook 上的 Safari 中选择 `开发 -> （连接设备名称）-> （调试页面域名）`\n4. 选中后会出现如下图所示的界面，这样就可以实现如 PC 端的调试功能\n\n如果 Safari 调试面板一片空白可以下载个 [Safari Technology Preview](https://developer.apple.com/safari/download/)\n\n## 基于 Android 的开发调试\n\n### Chrome + USB 远程设备调试\n\n通过安卓手机与任意系统的电脑同时安装 Chrome 浏览器，并通过 USB 进行有线连接，可以通过浏览器内置的功能实现远程调试，简单来说就是通过 PC 端 Chrome 的开发者工具调试手机上 Chrome 打开的网页。\n\n调试方式：\n\n1. Android 手机和 PC 电脑同时下载 Chrome 浏览器\n2. 打开 Android 手机 `设置 -> 开发者选项 -> USB 调试`（可能不同厂商的设定不一致，最终目的就是打开 USB 调试，如果打开路径不一样的，可以自行探索或搜索对应设备打开 USB 调试的方式）。\n3. 利用 USB 数据线，将 Android 手机与 PC 电脑连接，手机理论上会提示是否允许 USB 调试，选择 `确认` 的选项的就好了\n4. 打开 PC 电脑上的 Chrome 浏览器，打开开发者工具 `Console -> 右侧 Customize and control DevTools -> More tools -> Remote devices`\n5. 每个页面右侧均有一个 Inspect 检查的按钮，点击就会出现你熟悉的画面，\n\n更详尽的调试方式可以参考 Google 官方的开发者文档相关章节：\n\n- [Android 设备的远程调试入门](https://developers.google.com/web/tools/chrome-devtools/remote-debugging/)\n- [访问本地服务器](https://developers.google.com/web/tools/chrome-devtools/remote-debugging/local-server)\n- [远程调试 WebView](https://developers.google.com/web/tools/chrome-devtools/remote-debugging/webviews)\n\n## 微信\n\n### 微信开发者工具\n\n微信生态包括公共号网页开发、小程序、小游戏等使用微信开发者工具就行了，这没有什么争议，毕竟官方提供的工具。\n\n[文档：微信开发者工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html)\n\n### 缓存清除方法\n\n这里提提搜到的一个微信内网页缓存的清除方法：\n\n1. 微信中打开网页 [http://debugx5.qq.com](http://debugx5.qq.com)\n2. 滑动到底部，选中四个缓存选项 `Cookie`、`文件缓存`、`广告过滤缓存` 和 `DNS 缓存`，点击清除即可\n\n## 其他付费服务\n\n在调研过程中也发现了一些挺不错的付费调试工具：\n\n- [岩鼠：提供租用的云端真机平台远程调试，覆盖市面热门品牌机型](https://yanshu.effirst.com/)\n- Charles Proxy on iOS：iOS 版的 Charles，可以直接在 iPhone 手机上调试\n\n---\n\n**参考资料：**\n\n- [移动端前端开发调试](https://yujiangshui.com/multidevice-frontend-debug/)\n- [各种真机远程调试方法汇总](https://github.com/jieyou/remote_inspect_web_on_real_device)\n- [H5 移动调试全攻略](https://zhuanlan.zhihu.com/p/51794821)\n- [移动端调试痛点？送你五款开发利器](https://juejin.im/post/5b72e1f66fb9a009d018fb94)\n- [你需要的 App 内 H5 的调试方法](https://zhuanlan.zhihu.com/p/103642413)\n- [微信开发如何做本地调试](https://www.zhihu.com/question/25456655)\n","source":"_posts/summary-of-common-development-and-debugging-methods-of-mobile-front-end.md","raw":"---\ntitle: 常用移动前端开发调试方式\ndate: '2020-05-27'\n---\n\n# 常用移动前端开发调试方式\n\n因为日常开发经常需要在移动设备上调试测试开发的 H5 页面，但是一直都没怎么总结过移动前端开发相关的调试工具或方法，今天稍微总结一下比较好用的调试工具，也罗列了一些没有用过但是值得了解的工具\n\n## 通用调试工具方法\n\n### Chrome 移动设备模拟器\n\nChrome 浏览器开发者工具内置了可用于模拟移动设备的功能，这也是最常用的调试方式，这里只是简单说明操作步骤：\n\n1. 在 PC 端打开 Chrome 浏览器并打开目标页面，然后 F12 打开开发者工具\n2. 点击开发者工具左上角的手机图标，刷新页面后即可调试\n3. 页面顶部设备选择下拉菜单可选择默认的多种品牌机型，以及仿真的网络状态\n4. 选择下来菜单中的 `Edit` 进入适配设备的机型选择，既有浏览器提供的机型，也可以根据需要设定自定义机型（主要是测试宽高比）\n\n因为使用起来方便，所以开发调试的大部分都能满足需求，但是要更仿真更严谨还是需要在真机中调试。\n\n### vConsole 移动端网页上的调试控制台\n\n[vConsole](https://github.com/Tencent/vConsole) 是一款轻量级、可拓展、针对手机网页的前端开发者调试面板。\n\n通过该工具可以方便地在移动真机的 Web 页面中通过以下特性实现调试功能：\n\n- 查看 console 日志\n- 查看网络请求信息\n- 查看页面 element 结构\n- 查看 Cookie、localStorage 和 SessionStorage\n- 手动执行 JavaScript 命令行\n- 自定义插件\n\n<!-- more -->\n\n这款类库应该是使用最广泛的工具，而且使用起来也比较简单，与 PC 端 Chrome 等开发者调试工具使用方式类似，所以就不多叙述了。\n\n更多关于此工具的使用教程可以参阅 [vConsole 使用教程](https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md)\n\n除此之外，有个同样是 AlloyTeam 出品的错误监控上报、支持生产环境通过 URL 带参数唤起 vConsole 的库 [AlloyLever](https://github.com/AlloyTeam/AlloyLever) 也值得关注一下。\n\n同类型的产品有 [eruda](https://github.com/liriliri/eruda)\n\n#### 实现原理\n\n通过在页面注入 JavaScript 脚本实现模拟类似 Chrome DevTool 的调试面板。\n\n通过重写 `XHMLHttpRequest`、`fetch`、`console` 方法实现网络请求和日志打印的拦截，并输出到控制面板中的 `Network` 和 `Console` 标签。\n\n通过遍历 Cookie、LocalStorage、SessionStorage 对象下的所有存储键值以获取当前网页的本地存储数据。\n\n而 `Element` 标签中的页面 DOM 树结构，则通过从 `document.documentElement` 节点开始向子孙节点递归生成。\n\n### Charles 数据传输抓包工具\n\n试想以下在日常开发中可能会遇到的场景：\n\n1. 在本地开发完移动 H5 页面后，想与后端联调接口，但是接口部署在机房服务器上，域名非 IP 地址，这个时候联调会存在跨域问题，应该怎样解决？\n2. 线上 Web App 表现异常，没法在线上页面使用调试面板进行调试，怎样定位问题？\n3. 线上 Web App 表现异常，接口请求响应表现正常，单从代码层面无法定位问题根源，怎样更好地定位问题？\n\n在 Charles 强大的抓包功能面前，这些问题通通都不是问题。我们先介绍一下 Charles：\n\n[Charles](https://www.charlesproxy.com/) 是一款基于 HTTP 协议的代理服务器，通过截取请求和请求结果达到分析抓包的目的。\n\n以下是 Charles 的功能特性：\n\n- 支持 HTTP 和 HTTPS 代理，截取分析 SSL 请求\n- 支持流量控制，可以模拟弱网测试环境\n- 支持接口并发请求\n- 支持重发网络请求，方便后端调试\n- 支持修改网络请求参数\n- 支持网络请求的截获并动态修改\n- 支持断点调试，构建异常的测试场景\n\n#### 使用方式\n\n使用 Charles 抓包手机向服务器发送请求的操作步骤：\n\n1. 安装根证书：`菜单 -> Help -> SSL Proxying -> Install Charles Root Certificate`\n\n![安装根证书](http://img.mrsingsing.com/wireless-debugger-install-charles-certificate.jpg)\n\n2. 找到安装好 Charles 的根证书后，确保证书的所有选项均为始终信任（这个证书后续会下载到你的手机中使用）\n\n![总是信任](http://img.mrsingsing.com/wireless-debugger-always-trust-certificate.jpg)\n\n3. 然后开启 Charles 的代理服务：`Proxy -> Proxy Setting`，`port` 端口填 `8888`，选中 `Enable transparent HTTP proxying`\n\n找到当前使用的 Mac 笔记本的 IP 地址（通过 `Charles -> Help -> Local IP Address` 可以获取）\n\n![开启Charles代理](http://img.mrsingsing.com/wireless-debugger-enable-charles-proxying.jpg)\n\n4. 给 iPhone 设置代理\n\n- 打开 iPhone，连接 Wifi（需要确保 iPhone 与 Mac 连接的是相同的 Wifi）\n- 打开 Wifi 名后的蓝色感叹号，在最下面找到 `HTTP 代理`，点击进入\n- 选择 `手动`，服务器上填上端口号 `8888`\n\n5. 随便打开网页，这个时候 Charles 会弹出请求连接的确认菜单，选择左边选项 `Allow`\n\n6) 在手机浏览器中（最好是 Safari），输入 `chls.pro/ssl`，会弹出安装证书的请求，输入密码，一直点安装即可\n\n- 打开设置，点击 `通用 -> 关于本机 -> 证书信任设置`，找到当前要作为代理的电脑名，打开信任开关\n\n这个时候既可以截取到 HTTP/HTTPS 的网络请求了。\n\n#### 实现原理\n\n![Charles实现原理](http://img.mrsingsing.com/wireless-debugger-charles-principle.jpg)\n\n事实上 Charles 就是充当所谓的 `中间人` 角色，把我们的设备发送的请求拦截下来，并转发给我们的目标服务器，而后将响应的信息返回给我们的设备。\n\n前提是设备上需要安装并信任 Charles 的证书，这个为了当 HTTPS 传输时，Charles 需要拦截解密数据并利用服务端的证书公钥和 HTTPS 连接的对称密钥做后续的传输加密。\n\n由于本人使用 Charles 比较多，但其实还有很多类似的抓包工具，例如：\n\n- 软件类\n  - [Fiddler](https://www.telerik.com/fiddler)\n  - [Wireshark](https://www.wireshark.org/download.html)\n  - [Weinre](https://github.com/nupthale/weinre)：基于 Web Inspector 的远程调试工具，可以在 PC 上直接调试运行在手机上的页面\n- 工具包类\n  - [spy-debugger](https://github.com/wuchangming/spy-debugger)：一站式页面调试、抓包工具，能远程调试任何手机浏览器页面，任何手机移动端 Webview，无需 USB 连接设备（实现原理与 Charles 类似）\n  - [whistle](https://github.com/avwo/whistle)：基于 Node 实现的跨平台抓包调试代理工具，功能强大，支持 WebSocket、反响代理、插件扩展等特性\n\n## 基于 iOS 的开发调试\n\n### Safari + 数据线 远程设备调试\n\n前期准备：iPhone + MacBook + 各自安装 Safari\n\n调试方式：\n\n1. 打开 iPhone `设置 -> Safari 浏览器 -> 高级 -> Web 检查器`\n2. 打开 MacBook 上的 Safari 浏览器 `偏好设置 -> 高级 -> 在菜单栏中显示“开发”菜单`\n3. 用数据线连接 iPhone 和 MacBook，并选择 `信任` 设备，在 iPhone 上的 Safari 浏览器打开需要调试的页面，并在 MacBook 上的 Safari 中选择 `开发 -> （连接设备名称）-> （调试页面域名）`\n4. 选中后会出现如下图所示的界面，这样就可以实现如 PC 端的调试功能\n\n如果 Safari 调试面板一片空白可以下载个 [Safari Technology Preview](https://developer.apple.com/safari/download/)\n\n## 基于 Android 的开发调试\n\n### Chrome + USB 远程设备调试\n\n通过安卓手机与任意系统的电脑同时安装 Chrome 浏览器，并通过 USB 进行有线连接，可以通过浏览器内置的功能实现远程调试，简单来说就是通过 PC 端 Chrome 的开发者工具调试手机上 Chrome 打开的网页。\n\n调试方式：\n\n1. Android 手机和 PC 电脑同时下载 Chrome 浏览器\n2. 打开 Android 手机 `设置 -> 开发者选项 -> USB 调试`（可能不同厂商的设定不一致，最终目的就是打开 USB 调试，如果打开路径不一样的，可以自行探索或搜索对应设备打开 USB 调试的方式）。\n3. 利用 USB 数据线，将 Android 手机与 PC 电脑连接，手机理论上会提示是否允许 USB 调试，选择 `确认` 的选项的就好了\n4. 打开 PC 电脑上的 Chrome 浏览器，打开开发者工具 `Console -> 右侧 Customize and control DevTools -> More tools -> Remote devices`\n5. 每个页面右侧均有一个 Inspect 检查的按钮，点击就会出现你熟悉的画面，\n\n更详尽的调试方式可以参考 Google 官方的开发者文档相关章节：\n\n- [Android 设备的远程调试入门](https://developers.google.com/web/tools/chrome-devtools/remote-debugging/)\n- [访问本地服务器](https://developers.google.com/web/tools/chrome-devtools/remote-debugging/local-server)\n- [远程调试 WebView](https://developers.google.com/web/tools/chrome-devtools/remote-debugging/webviews)\n\n## 微信\n\n### 微信开发者工具\n\n微信生态包括公共号网页开发、小程序、小游戏等使用微信开发者工具就行了，这没有什么争议，毕竟官方提供的工具。\n\n[文档：微信开发者工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html)\n\n### 缓存清除方法\n\n这里提提搜到的一个微信内网页缓存的清除方法：\n\n1. 微信中打开网页 [http://debugx5.qq.com](http://debugx5.qq.com)\n2. 滑动到底部，选中四个缓存选项 `Cookie`、`文件缓存`、`广告过滤缓存` 和 `DNS 缓存`，点击清除即可\n\n## 其他付费服务\n\n在调研过程中也发现了一些挺不错的付费调试工具：\n\n- [岩鼠：提供租用的云端真机平台远程调试，覆盖市面热门品牌机型](https://yanshu.effirst.com/)\n- Charles Proxy on iOS：iOS 版的 Charles，可以直接在 iPhone 手机上调试\n\n---\n\n**参考资料：**\n\n- [移动端前端开发调试](https://yujiangshui.com/multidevice-frontend-debug/)\n- [各种真机远程调试方法汇总](https://github.com/jieyou/remote_inspect_web_on_real_device)\n- [H5 移动调试全攻略](https://zhuanlan.zhihu.com/p/51794821)\n- [移动端调试痛点？送你五款开发利器](https://juejin.im/post/5b72e1f66fb9a009d018fb94)\n- [你需要的 App 内 H5 的调试方法](https://zhuanlan.zhihu.com/p/103642413)\n- [微信开发如何做本地调试](https://www.zhihu.com/question/25456655)\n","slug":"summary-of-common-development-and-debugging-methods-of-mobile-front-end","published":1,"updated":"2021-08-18T03:28:40.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckshc99z3000cv31psdt663jn","content":"<h1 id=\"常用移动前端开发调试方式\"><a href=\"#常用移动前端开发调试方式\" class=\"headerlink\" title=\"常用移动前端开发调试方式\"></a>常用移动前端开发调试方式</h1><p>因为日常开发经常需要在移动设备上调试测试开发的 H5 页面，但是一直都没怎么总结过移动前端开发相关的调试工具或方法，今天稍微总结一下比较好用的调试工具，也罗列了一些没有用过但是值得了解的工具</p>\n<h2 id=\"通用调试工具方法\"><a href=\"#通用调试工具方法\" class=\"headerlink\" title=\"通用调试工具方法\"></a>通用调试工具方法</h2><h3 id=\"Chrome-移动设备模拟器\"><a href=\"#Chrome-移动设备模拟器\" class=\"headerlink\" title=\"Chrome 移动设备模拟器\"></a>Chrome 移动设备模拟器</h3><p>Chrome 浏览器开发者工具内置了可用于模拟移动设备的功能，这也是最常用的调试方式，这里只是简单说明操作步骤：</p>\n<ol>\n<li>在 PC 端打开 Chrome 浏览器并打开目标页面，然后 F12 打开开发者工具</li>\n<li>点击开发者工具左上角的手机图标，刷新页面后即可调试</li>\n<li>页面顶部设备选择下拉菜单可选择默认的多种品牌机型，以及仿真的网络状态</li>\n<li>选择下来菜单中的 <code>Edit</code> 进入适配设备的机型选择，既有浏览器提供的机型，也可以根据需要设定自定义机型（主要是测试宽高比）</li>\n</ol>\n<p>因为使用起来方便，所以开发调试的大部分都能满足需求，但是要更仿真更严谨还是需要在真机中调试。</p>\n<h3 id=\"vConsole-移动端网页上的调试控制台\"><a href=\"#vConsole-移动端网页上的调试控制台\" class=\"headerlink\" title=\"vConsole 移动端网页上的调试控制台\"></a>vConsole 移动端网页上的调试控制台</h3><p><a href=\"https://github.com/Tencent/vConsole\" target=\"_blank\" rel=\"noopener\">vConsole</a> 是一款轻量级、可拓展、针对手机网页的前端开发者调试面板。</p>\n<p>通过该工具可以方便地在移动真机的 Web 页面中通过以下特性实现调试功能：</p>\n<ul>\n<li>查看 console 日志</li>\n<li>查看网络请求信息</li>\n<li>查看页面 element 结构</li>\n<li>查看 Cookie、localStorage 和 SessionStorage</li>\n<li>手动执行 JavaScript 命令行</li>\n<li>自定义插件</li>\n</ul>\n<a id=\"more\"></a>\n<p>这款类库应该是使用最广泛的工具，而且使用起来也比较简单，与 PC 端 Chrome 等开发者调试工具使用方式类似，所以就不多叙述了。</p>\n<p>更多关于此工具的使用教程可以参阅 <a href=\"https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md\" target=\"_blank\" rel=\"noopener\">vConsole 使用教程</a></p>\n<p>除此之外，有个同样是 AlloyTeam 出品的错误监控上报、支持生产环境通过 URL 带参数唤起 vConsole 的库 <a href=\"https://github.com/AlloyTeam/AlloyLever\" target=\"_blank\" rel=\"noopener\">AlloyLever</a> 也值得关注一下。</p>\n<p>同类型的产品有 <a href=\"https://github.com/liriliri/eruda\" target=\"_blank\" rel=\"noopener\">eruda</a></p>\n<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p>通过在页面注入 JavaScript 脚本实现模拟类似 Chrome DevTool 的调试面板。</p>\n<p>通过重写 <code>XHMLHttpRequest</code>、<code>fetch</code>、<code>console</code> 方法实现网络请求和日志打印的拦截，并输出到控制面板中的 <code>Network</code> 和 <code>Console</code> 标签。</p>\n<p>通过遍历 Cookie、LocalStorage、SessionStorage 对象下的所有存储键值以获取当前网页的本地存储数据。</p>\n<p>而 <code>Element</code> 标签中的页面 DOM 树结构，则通过从 <code>document.documentElement</code> 节点开始向子孙节点递归生成。</p>\n<h3 id=\"Charles-数据传输抓包工具\"><a href=\"#Charles-数据传输抓包工具\" class=\"headerlink\" title=\"Charles 数据传输抓包工具\"></a>Charles 数据传输抓包工具</h3><p>试想以下在日常开发中可能会遇到的场景：</p>\n<ol>\n<li>在本地开发完移动 H5 页面后，想与后端联调接口，但是接口部署在机房服务器上，域名非 IP 地址，这个时候联调会存在跨域问题，应该怎样解决？</li>\n<li>线上 Web App 表现异常，没法在线上页面使用调试面板进行调试，怎样定位问题？</li>\n<li>线上 Web App 表现异常，接口请求响应表现正常，单从代码层面无法定位问题根源，怎样更好地定位问题？</li>\n</ol>\n<p>在 Charles 强大的抓包功能面前，这些问题通通都不是问题。我们先介绍一下 Charles：</p>\n<p><a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"noopener\">Charles</a> 是一款基于 HTTP 协议的代理服务器，通过截取请求和请求结果达到分析抓包的目的。</p>\n<p>以下是 Charles 的功能特性：</p>\n<ul>\n<li>支持 HTTP 和 HTTPS 代理，截取分析 SSL 请求</li>\n<li>支持流量控制，可以模拟弱网测试环境</li>\n<li>支持接口并发请求</li>\n<li>支持重发网络请求，方便后端调试</li>\n<li>支持修改网络请求参数</li>\n<li>支持网络请求的截获并动态修改</li>\n<li>支持断点调试，构建异常的测试场景</li>\n</ul>\n<h4 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><p>使用 Charles 抓包手机向服务器发送请求的操作步骤：</p>\n<ol>\n<li>安装根证书：<code>菜单 -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate</code></li>\n</ol>\n<p><img src=\"http://img.mrsingsing.com/wireless-debugger-install-charles-certificate.jpg\" alt=\"安装根证书\"></p>\n<ol start=\"2\">\n<li>找到安装好 Charles 的根证书后，确保证书的所有选项均为始终信任（这个证书后续会下载到你的手机中使用）</li>\n</ol>\n<p><img src=\"http://img.mrsingsing.com/wireless-debugger-always-trust-certificate.jpg\" alt=\"总是信任\"></p>\n<ol start=\"3\">\n<li>然后开启 Charles 的代理服务：<code>Proxy -&gt; Proxy Setting</code>，<code>port</code> 端口填 <code>8888</code>，选中 <code>Enable transparent HTTP proxying</code></li>\n</ol>\n<p>找到当前使用的 Mac 笔记本的 IP 地址（通过 <code>Charles -&gt; Help -&gt; Local IP Address</code> 可以获取）</p>\n<p><img src=\"http://img.mrsingsing.com/wireless-debugger-enable-charles-proxying.jpg\" alt=\"开启Charles代理\"></p>\n<ol start=\"4\">\n<li>给 iPhone 设置代理</li>\n</ol>\n<ul>\n<li>打开 iPhone，连接 Wifi（需要确保 iPhone 与 Mac 连接的是相同的 Wifi）</li>\n<li>打开 Wifi 名后的蓝色感叹号，在最下面找到 <code>HTTP 代理</code>，点击进入</li>\n<li>选择 <code>手动</code>，服务器上填上端口号 <code>8888</code></li>\n</ul>\n<ol start=\"5\">\n<li>随便打开网页，这个时候 Charles 会弹出请求连接的确认菜单，选择左边选项 <code>Allow</code></li>\n</ol>\n<p>6) 在手机浏览器中（最好是 Safari），输入 <code>chls.pro/ssl</code>，会弹出安装证书的请求，输入密码，一直点安装即可</p>\n<ul>\n<li>打开设置，点击 <code>通用 -&gt; 关于本机 -&gt; 证书信任设置</code>，找到当前要作为代理的电脑名，打开信任开关</li>\n</ul>\n<p>这个时候既可以截取到 HTTP/HTTPS 的网络请求了。</p>\n<h4 id=\"实现原理-1\"><a href=\"#实现原理-1\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p><img src=\"http://img.mrsingsing.com/wireless-debugger-charles-principle.jpg\" alt=\"Charles实现原理\"></p>\n<p>事实上 Charles 就是充当所谓的 <code>中间人</code> 角色，把我们的设备发送的请求拦截下来，并转发给我们的目标服务器，而后将响应的信息返回给我们的设备。</p>\n<p>前提是设备上需要安装并信任 Charles 的证书，这个为了当 HTTPS 传输时，Charles 需要拦截解密数据并利用服务端的证书公钥和 HTTPS 连接的对称密钥做后续的传输加密。</p>\n<p>由于本人使用 Charles 比较多，但其实还有很多类似的抓包工具，例如：</p>\n<ul>\n<li>软件类<ul>\n<li><a href=\"https://www.telerik.com/fiddler\" target=\"_blank\" rel=\"noopener\">Fiddler</a></li>\n<li><a href=\"https://www.wireshark.org/download.html\" target=\"_blank\" rel=\"noopener\">Wireshark</a></li>\n<li><a href=\"https://github.com/nupthale/weinre\" target=\"_blank\" rel=\"noopener\">Weinre</a>：基于 Web Inspector 的远程调试工具，可以在 PC 上直接调试运行在手机上的页面</li>\n</ul>\n</li>\n<li>工具包类<ul>\n<li><a href=\"https://github.com/wuchangming/spy-debugger\" target=\"_blank\" rel=\"noopener\">spy-debugger</a>：一站式页面调试、抓包工具，能远程调试任何手机浏览器页面，任何手机移动端 Webview，无需 USB 连接设备（实现原理与 Charles 类似）</li>\n<li><a href=\"https://github.com/avwo/whistle\" target=\"_blank\" rel=\"noopener\">whistle</a>：基于 Node 实现的跨平台抓包调试代理工具，功能强大，支持 WebSocket、反响代理、插件扩展等特性</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基于-iOS-的开发调试\"><a href=\"#基于-iOS-的开发调试\" class=\"headerlink\" title=\"基于 iOS 的开发调试\"></a>基于 iOS 的开发调试</h2><h3 id=\"Safari-数据线-远程设备调试\"><a href=\"#Safari-数据线-远程设备调试\" class=\"headerlink\" title=\"Safari + 数据线 远程设备调试\"></a>Safari + 数据线 远程设备调试</h3><p>前期准备：iPhone + MacBook + 各自安装 Safari</p>\n<p>调试方式：</p>\n<ol>\n<li>打开 iPhone <code>设置 -&gt; Safari 浏览器 -&gt; 高级 -&gt; Web 检查器</code></li>\n<li>打开 MacBook 上的 Safari 浏览器 <code>偏好设置 -&gt; 高级 -&gt; 在菜单栏中显示“开发”菜单</code></li>\n<li>用数据线连接 iPhone 和 MacBook，并选择 <code>信任</code> 设备，在 iPhone 上的 Safari 浏览器打开需要调试的页面，并在 MacBook 上的 Safari 中选择 <code>开发 -&gt; （连接设备名称）-&gt; （调试页面域名）</code></li>\n<li>选中后会出现如下图所示的界面，这样就可以实现如 PC 端的调试功能</li>\n</ol>\n<p>如果 Safari 调试面板一片空白可以下载个 <a href=\"https://developer.apple.com/safari/download/\" target=\"_blank\" rel=\"noopener\">Safari Technology Preview</a></p>\n<h2 id=\"基于-Android-的开发调试\"><a href=\"#基于-Android-的开发调试\" class=\"headerlink\" title=\"基于 Android 的开发调试\"></a>基于 Android 的开发调试</h2><h3 id=\"Chrome-USB-远程设备调试\"><a href=\"#Chrome-USB-远程设备调试\" class=\"headerlink\" title=\"Chrome + USB 远程设备调试\"></a>Chrome + USB 远程设备调试</h3><p>通过安卓手机与任意系统的电脑同时安装 Chrome 浏览器，并通过 USB 进行有线连接，可以通过浏览器内置的功能实现远程调试，简单来说就是通过 PC 端 Chrome 的开发者工具调试手机上 Chrome 打开的网页。</p>\n<p>调试方式：</p>\n<ol>\n<li>Android 手机和 PC 电脑同时下载 Chrome 浏览器</li>\n<li>打开 Android 手机 <code>设置 -&gt; 开发者选项 -&gt; USB 调试</code>（可能不同厂商的设定不一致，最终目的就是打开 USB 调试，如果打开路径不一样的，可以自行探索或搜索对应设备打开 USB 调试的方式）。</li>\n<li>利用 USB 数据线，将 Android 手机与 PC 电脑连接，手机理论上会提示是否允许 USB 调试，选择 <code>确认</code> 的选项的就好了</li>\n<li>打开 PC 电脑上的 Chrome 浏览器，打开开发者工具 <code>Console -&gt; 右侧 Customize and control DevTools -&gt; More tools -&gt; Remote devices</code></li>\n<li>每个页面右侧均有一个 Inspect 检查的按钮，点击就会出现你熟悉的画面，</li>\n</ol>\n<p>更详尽的调试方式可以参考 Google 官方的开发者文档相关章节：</p>\n<ul>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/remote-debugging/\" target=\"_blank\" rel=\"noopener\">Android 设备的远程调试入门</a></li>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/remote-debugging/local-server\" target=\"_blank\" rel=\"noopener\">访问本地服务器</a></li>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/remote-debugging/webviews\" target=\"_blank\" rel=\"noopener\">远程调试 WebView</a></li>\n</ul>\n<h2 id=\"微信\"><a href=\"#微信\" class=\"headerlink\" title=\"微信\"></a>微信</h2><h3 id=\"微信开发者工具\"><a href=\"#微信开发者工具\" class=\"headerlink\" title=\"微信开发者工具\"></a>微信开发者工具</h3><p>微信生态包括公共号网页开发、小程序、小游戏等使用微信开发者工具就行了，这没有什么争议，毕竟官方提供的工具。</p>\n<p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html\" target=\"_blank\" rel=\"noopener\">文档：微信开发者工具</a></p>\n<h3 id=\"缓存清除方法\"><a href=\"#缓存清除方法\" class=\"headerlink\" title=\"缓存清除方法\"></a>缓存清除方法</h3><p>这里提提搜到的一个微信内网页缓存的清除方法：</p>\n<ol>\n<li>微信中打开网页 <a href=\"http://debugx5.qq.com\" target=\"_blank\" rel=\"noopener\">http://debugx5.qq.com</a></li>\n<li>滑动到底部，选中四个缓存选项 <code>Cookie</code>、<code>文件缓存</code>、<code>广告过滤缓存</code> 和 <code>DNS 缓存</code>，点击清除即可</li>\n</ol>\n<h2 id=\"其他付费服务\"><a href=\"#其他付费服务\" class=\"headerlink\" title=\"其他付费服务\"></a>其他付费服务</h2><p>在调研过程中也发现了一些挺不错的付费调试工具：</p>\n<ul>\n<li><a href=\"https://yanshu.effirst.com/\" target=\"_blank\" rel=\"noopener\">岩鼠：提供租用的云端真机平台远程调试，覆盖市面热门品牌机型</a></li>\n<li>Charles Proxy on iOS：iOS 版的 Charles，可以直接在 iPhone 手机上调试</li>\n</ul>\n<hr>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li><a href=\"https://yujiangshui.com/multidevice-frontend-debug/\" target=\"_blank\" rel=\"noopener\">移动端前端开发调试</a></li>\n<li><a href=\"https://github.com/jieyou/remote_inspect_web_on_real_device\" target=\"_blank\" rel=\"noopener\">各种真机远程调试方法汇总</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/51794821\" target=\"_blank\" rel=\"noopener\">H5 移动调试全攻略</a></li>\n<li><a href=\"https://juejin.im/post/5b72e1f66fb9a009d018fb94\" target=\"_blank\" rel=\"noopener\">移动端调试痛点？送你五款开发利器</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/103642413\" target=\"_blank\" rel=\"noopener\">你需要的 App 内 H5 的调试方法</a></li>\n<li><a href=\"https://www.zhihu.com/question/25456655\" target=\"_blank\" rel=\"noopener\">微信开发如何做本地调试</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"常用移动前端开发调试方式\"><a href=\"#常用移动前端开发调试方式\" class=\"headerlink\" title=\"常用移动前端开发调试方式\"></a>常用移动前端开发调试方式</h1><p>因为日常开发经常需要在移动设备上调试测试开发的 H5 页面，但是一直都没怎么总结过移动前端开发相关的调试工具或方法，今天稍微总结一下比较好用的调试工具，也罗列了一些没有用过但是值得了解的工具</p>\n<h2 id=\"通用调试工具方法\"><a href=\"#通用调试工具方法\" class=\"headerlink\" title=\"通用调试工具方法\"></a>通用调试工具方法</h2><h3 id=\"Chrome-移动设备模拟器\"><a href=\"#Chrome-移动设备模拟器\" class=\"headerlink\" title=\"Chrome 移动设备模拟器\"></a>Chrome 移动设备模拟器</h3><p>Chrome 浏览器开发者工具内置了可用于模拟移动设备的功能，这也是最常用的调试方式，这里只是简单说明操作步骤：</p>\n<ol>\n<li>在 PC 端打开 Chrome 浏览器并打开目标页面，然后 F12 打开开发者工具</li>\n<li>点击开发者工具左上角的手机图标，刷新页面后即可调试</li>\n<li>页面顶部设备选择下拉菜单可选择默认的多种品牌机型，以及仿真的网络状态</li>\n<li>选择下来菜单中的 <code>Edit</code> 进入适配设备的机型选择，既有浏览器提供的机型，也可以根据需要设定自定义机型（主要是测试宽高比）</li>\n</ol>\n<p>因为使用起来方便，所以开发调试的大部分都能满足需求，但是要更仿真更严谨还是需要在真机中调试。</p>\n<h3 id=\"vConsole-移动端网页上的调试控制台\"><a href=\"#vConsole-移动端网页上的调试控制台\" class=\"headerlink\" title=\"vConsole 移动端网页上的调试控制台\"></a>vConsole 移动端网页上的调试控制台</h3><p><a href=\"https://github.com/Tencent/vConsole\" target=\"_blank\" rel=\"noopener\">vConsole</a> 是一款轻量级、可拓展、针对手机网页的前端开发者调试面板。</p>\n<p>通过该工具可以方便地在移动真机的 Web 页面中通过以下特性实现调试功能：</p>\n<ul>\n<li>查看 console 日志</li>\n<li>查看网络请求信息</li>\n<li>查看页面 element 结构</li>\n<li>查看 Cookie、localStorage 和 SessionStorage</li>\n<li>手动执行 JavaScript 命令行</li>\n<li>自定义插件</li>\n</ul>","more":"<p>这款类库应该是使用最广泛的工具，而且使用起来也比较简单，与 PC 端 Chrome 等开发者调试工具使用方式类似，所以就不多叙述了。</p>\n<p>更多关于此工具的使用教程可以参阅 <a href=\"https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md\" target=\"_blank\" rel=\"noopener\">vConsole 使用教程</a></p>\n<p>除此之外，有个同样是 AlloyTeam 出品的错误监控上报、支持生产环境通过 URL 带参数唤起 vConsole 的库 <a href=\"https://github.com/AlloyTeam/AlloyLever\" target=\"_blank\" rel=\"noopener\">AlloyLever</a> 也值得关注一下。</p>\n<p>同类型的产品有 <a href=\"https://github.com/liriliri/eruda\" target=\"_blank\" rel=\"noopener\">eruda</a></p>\n<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p>通过在页面注入 JavaScript 脚本实现模拟类似 Chrome DevTool 的调试面板。</p>\n<p>通过重写 <code>XHMLHttpRequest</code>、<code>fetch</code>、<code>console</code> 方法实现网络请求和日志打印的拦截，并输出到控制面板中的 <code>Network</code> 和 <code>Console</code> 标签。</p>\n<p>通过遍历 Cookie、LocalStorage、SessionStorage 对象下的所有存储键值以获取当前网页的本地存储数据。</p>\n<p>而 <code>Element</code> 标签中的页面 DOM 树结构，则通过从 <code>document.documentElement</code> 节点开始向子孙节点递归生成。</p>\n<h3 id=\"Charles-数据传输抓包工具\"><a href=\"#Charles-数据传输抓包工具\" class=\"headerlink\" title=\"Charles 数据传输抓包工具\"></a>Charles 数据传输抓包工具</h3><p>试想以下在日常开发中可能会遇到的场景：</p>\n<ol>\n<li>在本地开发完移动 H5 页面后，想与后端联调接口，但是接口部署在机房服务器上，域名非 IP 地址，这个时候联调会存在跨域问题，应该怎样解决？</li>\n<li>线上 Web App 表现异常，没法在线上页面使用调试面板进行调试，怎样定位问题？</li>\n<li>线上 Web App 表现异常，接口请求响应表现正常，单从代码层面无法定位问题根源，怎样更好地定位问题？</li>\n</ol>\n<p>在 Charles 强大的抓包功能面前，这些问题通通都不是问题。我们先介绍一下 Charles：</p>\n<p><a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"noopener\">Charles</a> 是一款基于 HTTP 协议的代理服务器，通过截取请求和请求结果达到分析抓包的目的。</p>\n<p>以下是 Charles 的功能特性：</p>\n<ul>\n<li>支持 HTTP 和 HTTPS 代理，截取分析 SSL 请求</li>\n<li>支持流量控制，可以模拟弱网测试环境</li>\n<li>支持接口并发请求</li>\n<li>支持重发网络请求，方便后端调试</li>\n<li>支持修改网络请求参数</li>\n<li>支持网络请求的截获并动态修改</li>\n<li>支持断点调试，构建异常的测试场景</li>\n</ul>\n<h4 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><p>使用 Charles 抓包手机向服务器发送请求的操作步骤：</p>\n<ol>\n<li>安装根证书：<code>菜单 -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate</code></li>\n</ol>\n<p><img src=\"http://img.mrsingsing.com/wireless-debugger-install-charles-certificate.jpg\" alt=\"安装根证书\"></p>\n<ol start=\"2\">\n<li>找到安装好 Charles 的根证书后，确保证书的所有选项均为始终信任（这个证书后续会下载到你的手机中使用）</li>\n</ol>\n<p><img src=\"http://img.mrsingsing.com/wireless-debugger-always-trust-certificate.jpg\" alt=\"总是信任\"></p>\n<ol start=\"3\">\n<li>然后开启 Charles 的代理服务：<code>Proxy -&gt; Proxy Setting</code>，<code>port</code> 端口填 <code>8888</code>，选中 <code>Enable transparent HTTP proxying</code></li>\n</ol>\n<p>找到当前使用的 Mac 笔记本的 IP 地址（通过 <code>Charles -&gt; Help -&gt; Local IP Address</code> 可以获取）</p>\n<p><img src=\"http://img.mrsingsing.com/wireless-debugger-enable-charles-proxying.jpg\" alt=\"开启Charles代理\"></p>\n<ol start=\"4\">\n<li>给 iPhone 设置代理</li>\n</ol>\n<ul>\n<li>打开 iPhone，连接 Wifi（需要确保 iPhone 与 Mac 连接的是相同的 Wifi）</li>\n<li>打开 Wifi 名后的蓝色感叹号，在最下面找到 <code>HTTP 代理</code>，点击进入</li>\n<li>选择 <code>手动</code>，服务器上填上端口号 <code>8888</code></li>\n</ul>\n<ol start=\"5\">\n<li>随便打开网页，这个时候 Charles 会弹出请求连接的确认菜单，选择左边选项 <code>Allow</code></li>\n</ol>\n<p>6) 在手机浏览器中（最好是 Safari），输入 <code>chls.pro/ssl</code>，会弹出安装证书的请求，输入密码，一直点安装即可</p>\n<ul>\n<li>打开设置，点击 <code>通用 -&gt; 关于本机 -&gt; 证书信任设置</code>，找到当前要作为代理的电脑名，打开信任开关</li>\n</ul>\n<p>这个时候既可以截取到 HTTP/HTTPS 的网络请求了。</p>\n<h4 id=\"实现原理-1\"><a href=\"#实现原理-1\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p><img src=\"http://img.mrsingsing.com/wireless-debugger-charles-principle.jpg\" alt=\"Charles实现原理\"></p>\n<p>事实上 Charles 就是充当所谓的 <code>中间人</code> 角色，把我们的设备发送的请求拦截下来，并转发给我们的目标服务器，而后将响应的信息返回给我们的设备。</p>\n<p>前提是设备上需要安装并信任 Charles 的证书，这个为了当 HTTPS 传输时，Charles 需要拦截解密数据并利用服务端的证书公钥和 HTTPS 连接的对称密钥做后续的传输加密。</p>\n<p>由于本人使用 Charles 比较多，但其实还有很多类似的抓包工具，例如：</p>\n<ul>\n<li>软件类<ul>\n<li><a href=\"https://www.telerik.com/fiddler\" target=\"_blank\" rel=\"noopener\">Fiddler</a></li>\n<li><a href=\"https://www.wireshark.org/download.html\" target=\"_blank\" rel=\"noopener\">Wireshark</a></li>\n<li><a href=\"https://github.com/nupthale/weinre\" target=\"_blank\" rel=\"noopener\">Weinre</a>：基于 Web Inspector 的远程调试工具，可以在 PC 上直接调试运行在手机上的页面</li>\n</ul>\n</li>\n<li>工具包类<ul>\n<li><a href=\"https://github.com/wuchangming/spy-debugger\" target=\"_blank\" rel=\"noopener\">spy-debugger</a>：一站式页面调试、抓包工具，能远程调试任何手机浏览器页面，任何手机移动端 Webview，无需 USB 连接设备（实现原理与 Charles 类似）</li>\n<li><a href=\"https://github.com/avwo/whistle\" target=\"_blank\" rel=\"noopener\">whistle</a>：基于 Node 实现的跨平台抓包调试代理工具，功能强大，支持 WebSocket、反响代理、插件扩展等特性</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基于-iOS-的开发调试\"><a href=\"#基于-iOS-的开发调试\" class=\"headerlink\" title=\"基于 iOS 的开发调试\"></a>基于 iOS 的开发调试</h2><h3 id=\"Safari-数据线-远程设备调试\"><a href=\"#Safari-数据线-远程设备调试\" class=\"headerlink\" title=\"Safari + 数据线 远程设备调试\"></a>Safari + 数据线 远程设备调试</h3><p>前期准备：iPhone + MacBook + 各自安装 Safari</p>\n<p>调试方式：</p>\n<ol>\n<li>打开 iPhone <code>设置 -&gt; Safari 浏览器 -&gt; 高级 -&gt; Web 检查器</code></li>\n<li>打开 MacBook 上的 Safari 浏览器 <code>偏好设置 -&gt; 高级 -&gt; 在菜单栏中显示“开发”菜单</code></li>\n<li>用数据线连接 iPhone 和 MacBook，并选择 <code>信任</code> 设备，在 iPhone 上的 Safari 浏览器打开需要调试的页面，并在 MacBook 上的 Safari 中选择 <code>开发 -&gt; （连接设备名称）-&gt; （调试页面域名）</code></li>\n<li>选中后会出现如下图所示的界面，这样就可以实现如 PC 端的调试功能</li>\n</ol>\n<p>如果 Safari 调试面板一片空白可以下载个 <a href=\"https://developer.apple.com/safari/download/\" target=\"_blank\" rel=\"noopener\">Safari Technology Preview</a></p>\n<h2 id=\"基于-Android-的开发调试\"><a href=\"#基于-Android-的开发调试\" class=\"headerlink\" title=\"基于 Android 的开发调试\"></a>基于 Android 的开发调试</h2><h3 id=\"Chrome-USB-远程设备调试\"><a href=\"#Chrome-USB-远程设备调试\" class=\"headerlink\" title=\"Chrome + USB 远程设备调试\"></a>Chrome + USB 远程设备调试</h3><p>通过安卓手机与任意系统的电脑同时安装 Chrome 浏览器，并通过 USB 进行有线连接，可以通过浏览器内置的功能实现远程调试，简单来说就是通过 PC 端 Chrome 的开发者工具调试手机上 Chrome 打开的网页。</p>\n<p>调试方式：</p>\n<ol>\n<li>Android 手机和 PC 电脑同时下载 Chrome 浏览器</li>\n<li>打开 Android 手机 <code>设置 -&gt; 开发者选项 -&gt; USB 调试</code>（可能不同厂商的设定不一致，最终目的就是打开 USB 调试，如果打开路径不一样的，可以自行探索或搜索对应设备打开 USB 调试的方式）。</li>\n<li>利用 USB 数据线，将 Android 手机与 PC 电脑连接，手机理论上会提示是否允许 USB 调试，选择 <code>确认</code> 的选项的就好了</li>\n<li>打开 PC 电脑上的 Chrome 浏览器，打开开发者工具 <code>Console -&gt; 右侧 Customize and control DevTools -&gt; More tools -&gt; Remote devices</code></li>\n<li>每个页面右侧均有一个 Inspect 检查的按钮，点击就会出现你熟悉的画面，</li>\n</ol>\n<p>更详尽的调试方式可以参考 Google 官方的开发者文档相关章节：</p>\n<ul>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/remote-debugging/\" target=\"_blank\" rel=\"noopener\">Android 设备的远程调试入门</a></li>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/remote-debugging/local-server\" target=\"_blank\" rel=\"noopener\">访问本地服务器</a></li>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/remote-debugging/webviews\" target=\"_blank\" rel=\"noopener\">远程调试 WebView</a></li>\n</ul>\n<h2 id=\"微信\"><a href=\"#微信\" class=\"headerlink\" title=\"微信\"></a>微信</h2><h3 id=\"微信开发者工具\"><a href=\"#微信开发者工具\" class=\"headerlink\" title=\"微信开发者工具\"></a>微信开发者工具</h3><p>微信生态包括公共号网页开发、小程序、小游戏等使用微信开发者工具就行了，这没有什么争议，毕竟官方提供的工具。</p>\n<p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html\" target=\"_blank\" rel=\"noopener\">文档：微信开发者工具</a></p>\n<h3 id=\"缓存清除方法\"><a href=\"#缓存清除方法\" class=\"headerlink\" title=\"缓存清除方法\"></a>缓存清除方法</h3><p>这里提提搜到的一个微信内网页缓存的清除方法：</p>\n<ol>\n<li>微信中打开网页 <a href=\"http://debugx5.qq.com\" target=\"_blank\" rel=\"noopener\">http://debugx5.qq.com</a></li>\n<li>滑动到底部，选中四个缓存选项 <code>Cookie</code>、<code>文件缓存</code>、<code>广告过滤缓存</code> 和 <code>DNS 缓存</code>，点击清除即可</li>\n</ol>\n<h2 id=\"其他付费服务\"><a href=\"#其他付费服务\" class=\"headerlink\" title=\"其他付费服务\"></a>其他付费服务</h2><p>在调研过程中也发现了一些挺不错的付费调试工具：</p>\n<ul>\n<li><a href=\"https://yanshu.effirst.com/\" target=\"_blank\" rel=\"noopener\">岩鼠：提供租用的云端真机平台远程调试，覆盖市面热门品牌机型</a></li>\n<li>Charles Proxy on iOS：iOS 版的 Charles，可以直接在 iPhone 手机上调试</li>\n</ul>\n<hr>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li><a href=\"https://yujiangshui.com/multidevice-frontend-debug/\" target=\"_blank\" rel=\"noopener\">移动端前端开发调试</a></li>\n<li><a href=\"https://github.com/jieyou/remote_inspect_web_on_real_device\" target=\"_blank\" rel=\"noopener\">各种真机远程调试方法汇总</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/51794821\" target=\"_blank\" rel=\"noopener\">H5 移动调试全攻略</a></li>\n<li><a href=\"https://juejin.im/post/5b72e1f66fb9a009d018fb94\" target=\"_blank\" rel=\"noopener\">移动端调试痛点？送你五款开发利器</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/103642413\" target=\"_blank\" rel=\"noopener\">你需要的 App 内 H5 的调试方法</a></li>\n<li><a href=\"https://www.zhihu.com/question/25456655\" target=\"_blank\" rel=\"noopener\">微信开发如何做本地调试</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}